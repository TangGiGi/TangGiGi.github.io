<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MMX课内实验</title>
      <link href="/2018/12/15/Computer%20Organization%20&amp;%20Architecture/MMX/"/>
      <url>/2018/12/15/Computer%20Organization%20&amp;%20Architecture/MMX/</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h1><p>使用普通和 MMX 技术实现淡入淡出效果，比较其时间花费。<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>1996 年，Intel 开始将 MMX 技术引入 Pentium 产品系列，MMX 十一组用于多媒体人物的优化指令，共有 57 条新指令。这些新指令以一种 SIMD(single-instruction-multiple-data,但指令多数据)方式来处理数据。于是，它能一次在多个数据元素上同时完成加、乘这样的运算。一般，每条指令执行只用一个时钟周期。对于何时的应用，与不适用 MMX 指令相比，这些快速地并行操作能产生 2-8 倍的加速效果。随着 x86 体系结构推出 64 位的处理器，Intel 也扩展了这些指令，使它们能处理双 quadword(128 位)操作数和浮点运算。在 MMX 指令中，引入了饱和(saturation)算术。在通常的无符号算术中，在运算出现上溢时(最高位向上进位)，则此额外位会被舍掉。这被称为环绕(wraparound)运算，因为从结果上看，舍掉进位使两个数加法之和小于被加的两个数。在饱和算术中，如果加法导致上溢，减法导致下溢，那么结果分别被设置成可表示的最大值和最小值。<br>下载地址:<a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a></p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a><strong>实验环境</strong></h1><p>实验所使用的软件为 Visual Studio 2017 和 SDL 2.0<br>SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X 等）的应用软件。目前SDL 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。SDL 使用 GNU 宽通用公共许可证为授权方式，意指动态链接（dynamic link 其库并不需要开放本身的源代码。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a><strong>实验过程</strong></h1><ol><li>打开Visual Studio，创建一个新的空白C++工程。</li><li>右键项目名-&gt;属性菜单-&gt;C/C++-&gt;常规-&gt;附加包含目录-&gt;选择SDL/include 文件夹</li><li>属性菜单-&gt;C/C++-&gt;代码生成-&gt;运行库-&gt;改为”多线程 DLL (/MD)”</li><li>属性菜单-&gt;Linker-&gt;常规-&gt;附加库目录-&gt;选择SDL/lib/X86</li><li>属性菜单-&gt;Linker-&gt;输入-&gt;附加依赖项-&gt;填入<code>SDL2.lib; SDL2main.lib;</code></li><li>属性菜单-&gt;Linker-&gt;系统-&gt;子系统-&gt;改为未设置</li><li>如果出现<code>找不到SDL2.lib</code>的错误,可以尝试把<code>SDL2.lib</code>复制到项目的可执行文件的同一级目录下</li></ol><h1 id="SDL-准备工作"><a href="#SDL-准备工作" class="headerlink" title="SDL 准备工作"></a><strong>SDL 准备工作</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SCREEN_WIDTH = <span class="hljs-number">1920</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SCREEN_HEIGHT = <span class="hljs-number">1080</span>;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = SCREEN_WIDTH * SCREEN_HEIGHT * <span class="hljs-number">4</span>;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  T = <span class="hljs-number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* tar, *pic1, *pic2;</span><br><span class="line">SDL_Window *gWindow = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_Surface *gScreenSurface = <span class="hljs-literal">nullptr</span>, *gpic1 = <span class="hljs-literal">nullptr</span>, *gpic2 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//开始测试之前的准备工作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//初始化SDL视频子系统</span></span><br><span class="line"><span class="hljs-keyword">if</span> (SDL_Init(SDL_INIT_VIDEO) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Window could not be created! SDL_Error: %s\n"</span>, SDL_GetError());</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//创建窗口</span></span><br><span class="line">gWindow = SDL_CreateWindow(<span class="hljs-string">"SHOW BMP"</span>,<span class="hljs-comment">//窗口标题</span></span><br><span class="line">    SDL_WINDOWPOS_CENTERED,<span class="hljs-comment">//窗口位置设置</span></span><br><span class="line">    SDL_WINDOWPOS_CENTERED,</span><br><span class="line">    SCREEN_WIDTH,<span class="hljs-comment">//窗口的宽度</span></span><br><span class="line">    SCREEN_HEIGHT,<span class="hljs-comment">//窗口的高度</span></span><br><span class="line">    SDL_WINDOW_SHOWN<span class="hljs-comment">//显示窗口</span></span><br><span class="line">);</span><br><span class="line"><span class="hljs-keyword">if</span> (gWindow == <span class="hljs-literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Window could not be created! SDL_Error: %s\n"</span>, SDL_GetError());</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//将gWindow和gScreenSurface链接</span></span><br><span class="line">gScreenSurface = SDL_GetWindowSurface(gWindow);</span><br><span class="line"><span class="hljs-comment">//找到输出图像所在的位置</span></span><br><span class="line">tar = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gScreenSurface-&gt;pixels);</span><br><span class="line"><span class="hljs-comment">//获取图像文件的数据大小</span></span><br><span class="line">len = gScreenSurface-&gt;h * gScreenSurface-&gt;pitch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">SDL_FreeSurface(gpic1);<span class="hljs-comment">//释放空间</span></span><br><span class="line">SDL_FreeSurface(gpic2);</span><br><span class="line">gpic1 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">gpic2 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_DestroyWindow(gWindow);<span class="hljs-comment">//销毁窗口</span></span><br><span class="line">gWindow = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_Quit();<span class="hljs-comment">//退出SDL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a><strong>普通方法</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brute_force</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> time_st = SDL_GetTicks(), cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (SDL_GetTicks() - time_st &lt; T) &#123;</span><br><span class="line"><span class="hljs-keyword">double</span> shade = (<span class="hljs-keyword">double</span>)(SDL_GetTicks() - time_st) / T; <span class="hljs-comment">//获取当前渐变进度</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    tar[i] = pic1[i] + (pic2[i] - pic1[i]) * shade;</span><br><span class="line">&#125;</span><br><span class="line">++cnt;</span><br><span class="line">SDL_UpdateWindowSurface(gWindow); <span class="hljs-comment">//完成计算后刷新图像</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"FPS = %d\n"</span>, cnt * <span class="hljs-number">1000</span>/ T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MMX方法"><a href="#MMX方法" class="headerlink" title="MMX方法"></a><strong>MMX方法</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mmx</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> time_st = SDL_GetTicks();</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (SDL_GetTicks() - time_st &lt; T) &#123;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> ff2 = (SDL_GetTicks() - time_st) * <span class="hljs-number">256</span> / T;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> ff1 = <span class="hljs-number">256</span> - ff2;</span><br><span class="line">    <span class="hljs-comment">//将4个16位整数拼在一起，当读取的时候会被当做一个64位整数进行处理</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> f2[<span class="hljs-number">4</span>] = &#123; ff2,ff2,ff2,ff2 &#125;;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> f1[<span class="hljs-number">4</span>] = &#123; ff1,ff1,ff1,ff1 &#125;;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> p1, p2, *ptar;</span><br><span class="line">    <span class="hljs-comment">//4位的并行处理，因此循环次数位原先的四分之一</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">        p1 = ((<span class="hljs-keyword">uint32_t</span>*)pic1)[i];</span><br><span class="line">        p2 = ((<span class="hljs-keyword">uint32_t</span>*)pic2)[i];</span><br><span class="line">        ptar = &amp;(((<span class="hljs-keyword">uint32_t</span>*)tar)[i]);</span><br><span class="line">__asm &#123;</span><br><span class="line"><span class="hljs-comment">//将所需数据移入寄存器</span></span><br><span class="line">movd mm0, [p1]    <span class="hljs-comment">//load 4  pixel components from image A 把低 32位赋值给mm0</span></span><br><span class="line">movd mm1, [p2]  <span class="hljs-comment">//load 4  pixel components from image B</span></span><br><span class="line">mov edi, ptar</span><br><span class="line">pxor mm7, mm7  <span class="hljs-comment">//zero out mm7</span></span><br><span class="line"><span class="hljs-comment">//load fade value replicated 4 times</span></span><br><span class="line">movq mm3, [f1]  <span class="hljs-comment">//f1的64位赋值给mm3</span></span><br><span class="line">movq mm4, [f2]  </span><br><span class="line"><span class="hljs-comment">//将mm0和mm1解开，构成 00XX 00XX 00XX 00XX形式</span></span><br><span class="line">punpcklbw mm0, mm7</span><br><span class="line">punpcklbw mm1, mm7</span><br><span class="line"></span><br><span class="line">pmullw mm1, mm4</span><br><span class="line">pmullw mm0, mm3</span><br><span class="line"><span class="hljs-comment">//将结果相加后右移8位，再从拆开后的形式转回</span></span><br><span class="line">paddw mm0, mm1</span><br><span class="line">psrlw mm0, <span class="hljs-number">8</span><span class="hljs-comment">//XXYY XXYY XXYY XXYY =&gt; 00XX 00XX 00XX 00XX</span></span><br><span class="line">packuswb mm0, mm7 <span class="hljs-comment">//00XX 00XX 00XX 00XX =&gt; XX XX XX XX</span></span><br><span class="line"><span class="hljs-comment">//将结果传回目标位置</span></span><br><span class="line">movd[edi], mm0</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">    SDL_UpdateWindowSurface(gWindow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"FPS = %d\n"</span>, cnt * <span class="hljs-number">1000</span> / T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a><strong>主函数</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SDL.h"</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-comment">//未设置时需要这一行</span></span><br><span class="line"><span class="hljs-comment">//系统改为 window子系统时需要注释掉</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">before();</span><br><span class="line"><span class="hljs-comment">//加载图片并获取地址</span></span><br><span class="line">gpic1 = SDL_ConvertSurface(SDL_LoadBMP(<span class="hljs-string">"C:\\Users\\xiaoxin\\Desktop\\5.bmp"</span>), gScreenSurface-&gt;format, <span class="hljs-number">0</span>);</span><br><span class="line">gpic2 = SDL_ConvertSurface(SDL_LoadBMP(<span class="hljs-string">"C:\\Users\\xiaoxin\\Desktop\\6.bmp"</span>), gScreenSurface-&gt;format, <span class="hljs-number">0</span>);</span><br><span class="line">pic1 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gpic1-&gt;pixels);</span><br><span class="line">pic2 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gpic2-&gt;pixels);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//surface的快速复制</span></span><br><span class="line">SDL_BlitSurface(gpic1, <span class="hljs-literal">nullptr</span>, gScreenSurface, <span class="hljs-literal">nullptr</span>);</span><br><span class="line">SDL_UpdateWindowSurface(gWindow);<span class="hljs-comment">//更新显示</span></span><br><span class="line">SDL_Delay(<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">SDL_BlitSurface(gpic2, <span class="hljs-literal">nullptr</span>, gScreenSurface, <span class="hljs-literal">nullptr</span>);</span><br><span class="line">SDL_UpdateWindowSurface(gWindow);<span class="hljs-comment">//更新显示</span></span><br><span class="line">SDL_Delay(<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">brute_force();</span><br><span class="line">mmx();</span><br><span class="line">SDL_Delay(<span class="hljs-number">15000</span>);</span><br><span class="line"></span><br><span class="line">after();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a><strong>运行结果</strong></h1><ol><li>图片1<br><img src="\img\COA\MMX课内实验\1.png" alt=""></li><li>渐变<br><img src="\img\COA\MMX课内实验\2.png" alt=""></li><li>渐变<br><img src="\img\COA\MMX课内实验\3.png" alt=""></li><li>图片2<br><img src="\img\COA\MMX课内实验\4.png" alt=""></li><li>FPS 比较<br><img src="\img\COA\MMX课内实验\FPS.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Organization &amp; Architecture </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>期末总结</title>
      <link href="/2018/12/13/Operating%20System/summary/"/>
      <url>/2018/12/13/Operating%20System/summary/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h1><p><strong>OS structure</strong> <a href="#OSstructure"> <img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Process</strong><a href="#Process"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Thread</strong><a href="#Thread"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>CPU Scheduling</strong><a href="#CPUScheduling"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Process Synchronization</strong><a href="#ProcessSynchronization"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Deadlock</strong><a href="#Deadlock"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Memory Management</strong><a href="#MemoryManagement"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Virtual Memory</strong><a href="#VirtualMemory"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>File System</strong><a href="#FileSystem"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>IO System</strong><a href="#IOSystem"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><strong>Secondary Storage</strong><a href="#SecondaryStorage"><img src="/img/OS/s.gif" width="20" height="20"> </a><br><a id="more"></a></p><p id="OSstructure"></p><h1 id="OS-structure"><a href="#OS-structure" class="headerlink" title="OS structure"></a><strong>OS structure</strong></h1><ol><li><h2 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务:"></a>操作系统服务:</h2><ul><li>用户界面 程序执行 I/O操作 文件系统操作 通信 错误检查 资源分配 保护</li></ul></li><li><h2 id="System-Calls系统调用："><a href="#System-Calls系统调用：" class="headerlink" title="System Calls系统调用："></a>System Calls系统调用：</h2><ul><li>系统调用提供在运行程序和操作系统之间的接口 主要通过高级应用程序接口(API)而不是直接系统调用来访问三种常用方式用于在运行程序和操作系统之间的参数传递：寄存器 内存中的表 参数入栈</li></ul></li><li><h2 id="System-Structure-–-Layered-Approach系统结构"><a href="#System-Structure-–-Layered-Approach系统结构" class="headerlink" title="System Structure – Layered Approach系统结构"></a>System Structure – Layered Approach系统结构</h2><ul><li>层次化结构操作系统划分为若干层，在低层上构建高层。底层（0层）为硬件；最高层（ N层）为用户层，考虑模块化，层的选择是每层只使用低层次的功能和服务，以便于系统调试和验证。</li><li><strong>优点：</strong></li><li>低层和高层可分别实现（便于扩充）；</li><li>高层错误不会影响到低层，便于调试、利于功能的增删改；</li><li>调用关系清晰（高层对低层单向依赖），避免递归调用，有利于保证设计和实现的正确性 </li><li><strong>缺点：</strong></li><li>系统中所有进程的控制转移、通讯等任务全部交给系统的核心去管理，要花费一定的代价</li></ul></li><li><h2 id="Microkernels-微内核"><a href="#Microkernels-微内核" class="headerlink" title="Microkernels  微内核"></a>Microkernels  微内核</h2>通过划分系统程序和用户程序，把所有不必要的部件移出内核，形成一个小内核，提供最少量的进程管理存储管理，以及通信功能.<ul><li><strong>优点：</strong></li><li>易于扩充，易于移植</li><li>提高系统的可靠性：</li><li>提供多种操作环境</li><li>便于实现分布计算：以同样的调用形式，在下层可通过核心中的网络传送到远方服务器上  (RPC,Remote Procedure Call)</li><li><strong>缺点：</strong></li><li>消息传递方式增加开销，使响应变慢</li></ul></li><li><h2 id="用户目标"><a href="#用户目标" class="headerlink" title="用户目标"></a>用户目标</h2><ul><li>操作系统应该便于使用，易学，可靠，安全并且快捷</li></ul></li><li><h2 id="系统目标"><a href="#系统目标" class="headerlink" title="系统目标"></a>系统目标</h2><ul><li>操作系统应该容易设计、实现和维护，还要灵活、可靠、无错误和高效</li></ul></li></ol><p></p><p id="Process"></p><p></p><h1 id="Process"><a href="#Process" class="headerlink" title="Process"></a><strong>Process</strong></h1><ol><li><h2 id="进程-在执行中的程序；"><a href="#进程-在执行中的程序；" class="headerlink" title="进程 - 在执行中的程序；"></a>进程 - 在执行中的程序；</h2><ul><li>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是进程。</li></ul></li><li><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><strong>结构特征：</strong>进程实体=程序段+相关的数据段+PCB进程控制块。<br><strong>动态性：</strong>进程的实质是进程实体的一次执行过程，因此动态性是进程的最基本的特征。<br><strong>并发性: </strong>多个进程实体同存在于内存中，且能在一段时间内同时运行。是最重要的特征。<br><strong>独立性：</strong>指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。<br><strong>异步性: </strong>进程按各自独立的、不可预知的速度向前推进。</li><li><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="/img/OS/summary/1.png" alt=""></li><li><h2 id="Schedulers调度"><a href="#Schedulers调度" class="headerlink" title="Schedulers调度"></a>Schedulers调度</h2>长程调度（或作业调度）- 选择可以进入就绪队列的进程<br>短程调度（或CPU调度）- 选择可被下一个执行分配CPU的进程<br>中程调度：为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上（挂起），降低多道程序的度。当这些进程重新具备运行条件时，再从外存上调入内存。</li><li><h2 id="Context-Switch上下文切换"><a href="#Context-Switch上下文切换" class="headerlink" title="Context Switch上下文切换"></a>Context Switch上下文切换</h2><ul><li>当CPU切换至另一个进程时，系统必须保存旧进程状态并为新进程调入所保留的状态</li><li>上下文切换的时间开销较重；在切换时，系统没有做有用的工作</li><li>时间取决于硬件的支持        </li></ul></li><li><h1 id="进程创建的过程"><a href="#进程创建的过程" class="headerlink" title="进程创建的过程"></a>进程创建的过程</h1><ul><li>申请空白的PCB 为新建立的进程分配资源 初始化程序控制块     将新进程插入就绪队列</li></ul></li><li><p>编写一段程序，使用fork()创建两个子进程。<br>当此程序运行时，在系统中有一个父进程和两个子进程活动。让每一个进程在屏幕上显示一个字符：父进程显示字符“a”；子进程分别显示字符“b”和字符“c”。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> p1,p2;</span><br><span class="line"><span class="hljs-keyword">while</span>((p1 = fork()) == <span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span>(p1==<span class="hljs-number">0</span>)------------创建成功一子进程</span><br><span class="line"><span class="hljs-built_in">putchar</span>(<span class="hljs-string">'b'</span>);</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">while</span>((p2 = fork()) == <span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span>(p2 == <span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-built_in">putchar</span>(‘c’); -------创建成功,另一子进程</span><br><span class="line"><span class="hljs-keyword">else</span>      <span class="hljs-built_in">putchar</span>(‘a’);--------父进程</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程的控制<br>修改已编写的程序，将每个进程输出一个字符改为每个进程输出一句话.如果在程序中使用系统调用lockf()来给每一个进程加锁，可以实现进程之间的互斥，观察并分析出现的现象。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;<span class="hljs-keyword">int</span> p1,p2,i;</span><br><span class="line"><span class="hljs-keyword">while</span>((p1 = fork()) == <span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (p1==<span class="hljs-number">0</span>)</span><br><span class="line">&#123;lockf(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"son %d\n"</span>,i);</span><br><span class="line">lockf(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">&#123;<span class="hljs-keyword">while</span>((p2 = fork()) == <span class="hljs-number">-1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span>(p2 == <span class="hljs-number">0</span>)</span><br><span class="line">&#123;lockf(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"daughter %d\n"</span>,i);</span><br><span class="line">lockf(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> </span><br><span class="line">&#123;lockf(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"parent %d\n"</span>,i);</span><br><span class="line">lockf(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p></p><p id="Thread"></p><p></p><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a><strong>Thread</strong></h1><ol><li>进程：资源分配和CPU调度<br>线程：作为CPU调度单位，而进程只作为其他资源分配单位。<br>只拥有必不可少的资源，如：线程状态、程序计数器、寄存器上下文和栈<br>同样具有就绪、阻塞和执行三种基本状态<br>与同属一个进程的其它线程共享进程拥有的全部资源<br>可并发执行</li><li>线程的优点：<br>减小并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度。<br>线程的创建时间比进程短；<br>线程的终止时间比进程短；<br>同进程内的线程切换时间比进程短；<br>由于同进程内线程间共享内存和文件资源，可直接进行不通过内核的通信；</li><li>Kernel Threads内核线程：由内核支持，在内核空间执行线程创建、调度和管理。依赖于OS核心，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。</li><li>User Threads 用户线程：不依赖于OS核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</li><li>多线程模型<br>多对一：多个用户级线程映像进单个内核线程，任一时刻只能有一个线程可以访问内核(并发性低)，一个用户线程发起系统调用而阻塞，则整个进程阻塞。<br>一对一：每个用户级线程映像进内核线程，提供了更好的并发性，带来了额外开销,所以许多系统限制应用中的线程数目<br>多对多：不限制应用的线程数、多个线程可以并发</li><li>LightWeight Process 轻权进程：它是内核支持的用户线程,是内核数据结构，驻留在内核空间。一个进程可有一个或多个轻权进程，每个轻权进程由一个单独的内核线程来支持。</li><li>Resource needs of thread types: 线程需要的资源<br>内核线程：小数据结构及栈；线程切换不需要内存访问信息 - 相对快<br>LWP:带有寄存器数据的PCB，记账和内存信息；在LWP之间切换相对慢<br>用户级线程：只需栈及程序计数器；无内核涉及所以切换快。内核只关注支持用户级线程的LWP<br><img src="/img/OS/summary/2.png" alt=""></li></ol><p></p><p id="CPUScheduling"></p><p></p><h1 id="CPU-Scheduling"><a href="#CPU-Scheduling" class="headerlink" title="CPU Scheduling"></a><strong>CPU Scheduling</strong></h1><ol><li><p>CPU的三级调度<br>高级(Long-term)调度——作业调度<br>决定把外存输入井上处于作业后备队列上的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后再将新创建的进程排在就绪队列上，准备执行。<br>低级(Short-term)调度——进程调度<br>决定就绪队列中哪个进程将获得处理机，然后由分派程序执行把处理机分配给该进程的操作。<br><img src="/img/OS/summary/3.png" alt=""></p></li><li><p>CPU脉冲的分布<br>在系统中,存在许多短CPU脉冲,只有少量的长CPU脉冲<br>比如:I/O型作业具有许多短CPU脉冲,而CPU型作业则会有几个长CPU脉冲,这个分布规律对CPU调度算法的选择是非常重要的.</p></li><li><p>CPU的调度方式<br>非抢占方式(nonpreemptive)<br>把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机。<br>优点:实现简单、系统开销小，适用于大多数批处理系统环境<br>缺点:难以满足紧急任务的要求，不适用于实时、分时系统要求<br>抢占方式（Preemptive mode）<br>允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程。时间片原则 优先权原则 短作业优先</p></li><li><p>Dispatcher 分派程序：负责将对CPU的控制权转交给短调度选择的进程</p></li><li>Scheduling Criteria(调度准则)<br>CPU utilization – keep the CPU as busy as possible（CPU利用率 – 使CPU尽可能的忙碌）<br>Throughput – the number of processes that complete their execution per time unit（吞吐量 – 单位时间内运行完的进程数）<br>Turnaround time – the interval from submission to completion     （周转时间 – 进程从提交到运行结束的全部时间 ）<br>Waiting time – amount of time a process has been waiting in the ready queue（等待时间 – 进程在就绪队列中等待调度的时间片总和 ）<br>Response time – amount of time it takes from when a request was submitted until the first response is produced, not output  (for time-sharing environment)（响应时间 – 从进程提出请求到首次被响应的时间段[在分时系统环境下不是输出完结果的时间] ）</li><li>Scheduling  Algorithm调度算法<br>·先来先服务(FCFS)<br>可用于作业或进程调度<br>算法的原则是按照作业到达后备作业队列（或进程进入就绪队    列）的先后次序来选择作业（或进程）<br>属于非抢占方式<br>易于实现，表面上很公平，实际上有利于长作业，不利于短作    业；有利于CPU繁忙型，不利于I/O繁忙型。</li></ol><p>·短作业优先(SJF)<br>非抢占与抢占都可以<br>SJF是最优的 – 对一组指定的进程而言，它给出了最短的平    均等待时间。采用SJF有利于系统减少平均周转时间,提高系统    吞吐量。</p><p>·优先权调度(Priority Scheduling)<br>每个进程都有自己的优先数[整数]<br>CPU分配给最高优先级的进程[假定最小的整数最高的优先级]<br>SJF是以下一次CPU脉冲长度为优先数的优先级调度<br>在用户进程中，I/O繁忙的进程应优先于CPU繁忙的进程，以保证CPU和I/O设备之间的并行操作。<br>进程执行时间及内存需要少的进程应赋予较高的优先权；<br>由用户的紧迫程度及用户所付费用来确定进程的优先权。<br>在分时系统中，前台进程应优先于后台进程</p><p>·时间片轮转(Round Robin)<br>每个进程将得到小单位的CPU时间[时间片]，通常为10-100毫 秒。时间片用完后，该进程将被抢占并插入就绪队列末尾<br>一般来说，RR的平均周转时间比SJF长，但响应时间要短</p><p>·多级队列调度(Multilevel Queue)<br>按进程的属性来分类，如进程的类型、优先权、占用内存的多少,每类进程组成一个就绪队列，每个进程固定地处于某一个队列</p><p><img src="/img/OS/summary/4.png" alt=""><br>多级反馈队列调度算法(Multilevel Feedback Queue)<br>存在多个就绪队列，具有不同的优先级，各自按时间片轮转法调度<br>允许进程在队列之间移动<br>各个就绪队列中时间片的大小各不相同，优先级越高的队列时间片越小。<br>当一个进程执行完一个完整的时间片后被抢占处理器，被抢占的进程优先级降低一级而进入下级就绪队列，如此继续，直至降到进程的基本优先级。而一个进程从阻塞态变为就绪态时要提高优先级<br>最后会将I/O型和交互式进程留在较高优先级队列</p><p>·Highest Response Ratio Next (HRRN)高响应比优先调度算法<br>高响应比优先调度算法—基于优先权算法<br>   在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP,然后选择其值最大的作业投入运行。<br>RP值定义为：<br>    RP＝（已等待时间＋要求运行时间）／要求运行时间<br>       ＝1＋已等待时间／要求运行时间<br>HRRN算法实际上是FCFS算法和SJF算法的折衷<br>优点：<br>等待时间相同，则SJF；<br>要求的服务时间相同，则FCFS；<br>长作业的优先级随着等待时间的增加而提高，不会出现得不到响应的情况。</p><ol start="7"><li>CPU调度算法很多,如何选择适当的算法?<br>首先定义一个标准 (根据要实现的系统所追求的目标,如CPU利用    率\系统吞吐量\平均周转时间\响应时间等)<br>然后根据标准来选择适当的算法<br>采用相应的模型来评价算法</li></ol><p></p><p id="ProcessSynchronization"></p><p></p><h1 id="Process-Synchronization"><a href="#Process-Synchronization" class="headerlink" title="Process Synchronization"></a><strong>Process Synchronization</strong></h1><ol><li>进程间的交互关系<br>互斥，指多个进程不能同时使用同一个资源；<br>同步，进程之间的协作；<br>死锁，指多个进程互不相让，都得不到足够的资源；<br>饥饿，指一个进程一直得不到资源<pre><code>（其他进程可能轮流占用资源）</code></pre></li><li><p>为了保证数据的一致性,需要有同步机制来保证多个进程对共享数据的互斥访问.<br>临界区(critical section)：进程中访问临界资源的一段代码。<br>实现进程对临界资源的互斥访问—各进程互斥的进入自己的临界区。假定一个系统有n个进程{P0,P1,……,Pn-1},每个进程有一个代码段称为临界区,在该区中进程可能修改共享变量\更新一个表\写一个文件等.当一个进程在临界区中执行时,其他进程都不能进入临界区</p></li><li><p>同步机制应遵循的准则<br>空闲则入：其他进程均不处于临界区；<br>忙则等待：已有进程处于其临界区；<br>有限等待：等待进入临界区的进程不能”死等”；<br>让权等待：不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</p></li><li>算法123 详见ppt 不重要 主要看信号量和PV操作</li><li>死锁 – 两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的</li><li>Semaphore机制（信号量）</li><li>PV操作讨论（需要做题练习）<br>步骤：<br>信号量的设置；<br>给信号量赋初值（常用的互斥和同步信号量值的大小）；<br>P、V操作安排的位置, PV 操作要成对出现</li><li>管程</li></ol><p></p><p id="Deadlock"></p><p></p><h1 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a><strong>Deadlock</strong></h1><ol><li>死锁Deadlock：计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种互相等待的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。</li><li><p>Each process utilizes a resource as follows<br>（每一个进程如下的利用资源）<br>request （申请）：如果申请不能立即被允许，那么进程必须等待直到能获取资源。（通过系统调用或者信号量来进行资源的申请和释放）<br>use （使用）：进程使用资源进行相关操作<br>Release（释放）：进程释放资源</p></li><li><p>死锁的原因<br>·竞争资源引起死锁<br>当系统中供多个进程所使用的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁<br>·进程推进顺序不当引起死锁<br>在多道程序系统中，并发执行的进程推进序列不可预测<br>有些推进顺序，进程可以顺利完成<br>有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成死锁</p></li><li>Deadlock Characterization（死锁的特性）<br>四个条件同时出现，死锁将会发生<br>Mutual exclusion 互斥：一次只有一个进程可以使用一个资源<br>Hold and wait 占有并等待：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源<br>No preemption 不可抢占：一个资源只有当持有它的进程完成任务后，自由的释放<br>Circular wait 循环等待：等待资源的进程之间存在环</li><li>资源分配图<br>如果图没有环，那么不会有死锁<br>如果图有环<br>如果每一种资源类型只有一个实例，那么死锁发生<br>如果每种资源类型有多个实例，可能死锁<br><img src="/img/OS/summary/5.png" alt=""></li><li>处理死锁的方法<br>忽略、预防、避免、检测、解除<br>忽略：鸵鸟策略<br>预防：<br>互斥：共享资源不是必须的，必须保持非共享资源<br>占有并等待：必须保证进程申请资源的时候没有占有其他资源。没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源<br>非抢占：如果一个进程的申请没有实现，它要释放所有占有的资源。抢占的资源放入进程等待资源列表中。只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始<br>循环等待：将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源</li></ol><p>避免：确保系统永远不会进入不安全状态<br>银行家算法 安全算法实例！找安全序列 大题<br>检测：检测算法<br>解除：处理死锁：操作员人工处理 进程终止 资源抢占</p><p></p><p id="MemoryManagement"></p><p></p><h1 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a><strong>Memory Management</strong></h1><ol><li>Logical address – generated by the CPU; also referred to as virtual address.（逻辑地址—由CPU产生；也叫做虚拟空间。）</li><li>Physical address – address seen by the memory unit.（物理地址—内存设备所读入的地址）</li><li>地址重定位：将程序装入到与其地址空间不一致的物理空间，所引起的一系列地址变换过程。</li><li>在MMU策略中，在其值送入内存的时候，基址寄存器Relocation register中的值被加入到用户进程所产生的每个地址中。</li><li>动态加载 动态链接 覆盖 交换</li><li>存储管理方式：连续分配方式：为一个程序分配一段连续的内存空间，主要有：<br>a)    单一连续区管理方式：用户区 只能容纳一道作业，基址寄存器策略由来保护用户进程。基址寄存器包含最小物理地址的值；限长寄存器包含逻辑地址的范围，每个逻辑地址必需比限长寄存器的值小。<br>b)    多分区管理方式，是一种可用于多道程序的较简单的存储管理方式，又分为:<br>i.    固定分区方式：</li><li>固定式分区是在作业装入之前，内存就被划分成若干个固定大小的连续分区。</li><li>划分工作可以由系统管理员完成，也可以由操作系统实现。</li><li>一旦划分完成，在系统运行期间不再重新划分，即分区的个数不可变，分区的大小不可变，所以，固定式分区又称为静态分区。</li><li>优点：易于实现，开销小。</li><li>缺点：<br>分区大小固定: 内碎片<br>分区总数固定: 限制并发执行的进程数目。</li><li>采用的数据结构：分区表－－记录分区的大小和使用情况<br>ii.    可变分区方式：分区的划分是动态的,不是预先确定的</li><li>分区分配算法<br>a)     First-fit（首先适应）:  从空闲分区表的第一个表目开始查找，把找到的第一个满足要求的空闲区分配给作业，目的在于减少查找时间。通常将空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序。<br>特点：<br>i.    分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。<br>ii.    随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。<br>iii.    在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外碎片。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。</li></ol><p>b)    最佳适应算法（Best Fit）：从全部空闲区中找出能满足作业要求的、且最小的空闲分区. 能使碎片尽量小。为提高查找效率，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配<br>特点：<br>i.    从个别来看，外碎片较小，但从整体来看，会形成较多无法利用的碎片。<br>ii.    较大的空闲分区可以被保留。<br>c)    Worst-fit（最差适应）：搜索整个序列，寻找最大的分区进行分配。</p><ol start="8"><li>碎片Fragmentation<br>a)    External fragmentation（外碎片） – total memory space exists to satisfy a request, but it is not contiguous.（整个内存空间用来满足一个请求，但它不是连续的。）原因：因为这种分配要求把作业必须安置在一连续存储区内的缘故。<br>b)    Internal fragmentation（内碎片） – allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used.（分配的内存可能比申请的内存大一点，这两者之间的差别是内部不被使用的簇）<br>c)    只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行，通过紧缩来减少外碎片，把一些小的空闲内存结合成一个大的块。但要移动大量信息从而浪费处理机时间,代价比较高,且 必须获得硬件支持。<br>d)    分页存储管理是解决存储碎片的一种方法，要避开连续性要求，允许进程的物理地址空间不连续。</li><li>Paging分页：进程的逻辑地址空间可以是不连续的，如果有可用的物理内存，它将分给进程。把物理内存分成大小固定的块，把逻辑内存也分为固定大小的块，叫做页。运行一个有N页大小的程序，需要找到N个空的页框读入程序。建立一个页表，把逻辑地址转换为物理地址。<br>（CPU产生的地址被分为）:<br>a)    Page number (p) （页号）– used as an index into a page table which contains base address of each page in physical memory.（它包含每个页在物理内存中的基址，用来作为页表的索引。）<br>b)    Page offset (d) （偏移）– combined with base address to define the physical memory address that is sent to the memory unit.（同基址相结合，用来确定送入内存设备的物理内存地址。）</li></ol><p><img src="/img/OS/summary/6.png" alt=""></p><ol start="10"><li>页表的实现：页表被保存在主存中。<br>a)    Page-table base register (PTBR) points to the page table.（页表基址寄存器指向页表）<br>b)    Page-table length register (PRLR) indicates size of the page table.（页表限长寄存器表明页表的长度）<br>c)    在这个机制中，每一次的数据/指令存取需要两次内存存取，一次是存取页表，一次是存取数据<br>d)    associative registers  (通过一个联想寄存器，可以解决两次存取的问题）translation look-aside buffers (TLBs).翻译旁氏缓冲器</li><li>联想寄存器(TLBs).：<br><img src="/img/OS/summary/7.png" alt=""><br><img src="/img/OS/summary/8.png" alt=""></li><li>基本的地址变换机构：从逻辑地址到物理地址的转换:将用户程序中的页号变换成内存中的物理块号</li><li>地址变换过程ch09 ppt56页 看不懂。。</li><li>多级页表：由于每一级都分开的以表的形式存储在内存中，把一个逻辑地址转换为一个物理地址可能要进行4次内存存取。）<br>多级页表的引入，使逻辑地址到物理地址的变换时间增加了。<br>尽管每次内存存取的时间是很大的，高速缓存使执行的时间还是可以接受的。</li><li>Hashed Page Tables散列页表</li><li>Inverted Page Table 反向页表：倒置页表，按照整个物理内存建造一张表。减少了页表占用的内存空间量,但是增加了查找表的时间，因为页表是按物理块的顺序组织的，而查找是按虚地址进行的</li><li>Shared Pages 贡献页表</li><li><p>纯分页：没有外碎片，每个内碎片不超过页大小。<br>一个程序不必连续存放。程序全部装入内存。</p></li><li><p>Segmentation 分段：一个程序是一些段的集合，一个段是一个逻辑单位<br><img src="/img/OS/summary/9.png" alt=""><br><img src="/img/OS/summary/10.png" alt=""><br><img src="/img/OS/summary/11.png" alt=""><br><img src="/img/OS/summary/12.png" alt=""></p></li><li>Segmentation with Paging段页式：既具有分页系统能有效地提高内存利用率的优点，又具有分段系统能很好地满足用户需要的长处，是一种有效的存储管理方式。<br><img src="/img/OS/summary/13.png" alt=""><br><img src="/img/OS/summary/14.png" alt=""><br><img src="/img/OS/summary/15.png" alt=""><br><img src="/img/OS/summary/16.png" alt=""></li></ol><p></p><p id="VirtualMemory"></p><p></p><h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a><strong>Virtual Memory</strong></h1><ol><li>背景：进程必须全部放入内存后方可运行，</li><li>如果进程大于内存的容量或者内存中同时运行多个进程，解决的方法是：从物理上扩充内存容量<br>从逻辑上扩充内存容量</li><li>常规存储器的特征<br>一次性： 作业在运行前需要一次性的全部装入内存<br>驻留性：作业装入内存后，便一直驻留在内存中，直到作业结束。</li><li>局部性原则：时间 空间</li><li>虚拟内存：允许进程部分装入内存就可以执行的技术。只有运行的部分程序需要在内存中，逻辑地址空间能够比物理地址空间大。必须允许页面能够被换入和换出</li><li>虚拟内存通过请求页式和请求段式来执行</li><li>特点：离散性（最基本特征） 多次性（最重要特征）<br>对换性：内存和外村的兑换区之间换入换出<br>虚拟性：从逻辑上扩充内存容量</li><li>优点：小内存执行较大用户程序 可容纳更多程序并发执行  简化编程操作不影响编程的程序结构 虚拟空间大于物理内存</li><li>页面调入策略：预调页策略 主动准确率不高 用于首次调<br>请求调页策略：进程运行中发生缺页时，由系统将缺页调入内存，目前大多采用此策略。开销较大<br><img src="/img/OS/summary/17.png" alt=""><br><img src="/img/OS/summary/18.png" alt=""></li><li>缺页中断机构：在请求分页系统中，每当所要访问的页面不在内存时，便要产生一次缺页中断，请求OS将所缺页调入内存。与一般中断的主要区别在于：<br>a)    缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号。<br>b)    缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一条指令执行。<br>c)    一条指令在执行期间，可能产生多次缺页中断。</li><li>处理页面错误的步骤：<br>a)    check the internal page table to determine whether the reference was a valid or invalid 查找页表来确定此次地址访问是否合法<br>b)    2. if it was invalid, terminates the process. If it was valid, but not in memory, then page it in.如果不合法,则中止该进程; 否则如果有效但不在内存，即发生了缺页,则需要将其调入内存<br>c)    3. find the page in backing store所需页在外存，找到该页<br>d)    4. find a free frame, schedule a disk operation to read the desired page into memory  找到一个空闲物理块，启动磁盘,把该页读入内存<br>e)    5. modify the page table after the disk read is complete读磁盘结束后,修改页表以指出该页已在内存中<br>f)    6. restart the instruction that interrupted  重新开始执行刚才发生缺页中断的指令,这时它可以访问刚才调入的页</li><li>Page Replacement页面置换：找到内存中并没有真正使用的一些页，换出</li><li>Page-Replacement Algorithms页面置换算法<br><img src="/img/OS/summary/19.png" alt=""><br><img src="/img/OS/summary/20.png" alt=""></li><li>Allocation of Frames页帧分配<br>Each process needs minimum number of pages（每个进程所需要的最少的页的数目）</li><li>major allocation schemes（主要的分配策略）.<br>a)    equal allocation（平均分配）<br>b)    Proportional allocation（按比例分配）<br>c)    priority allocation（优先分配）</li><li>固定分配 可变分配<br><img src="/img/OS/summary/21.png" alt=""><br>抖动 颠簸Thrashing:刚被换出的页很快又被访问，需重新调入，导致系统频繁地交换页面，以致大部分CPU时间花费在完成页面置换的工作上。</li><li>Working set工作集  基本思想：<br>a)    根据程序的局部性原理，进程在一段时间内总是集中访问一些页面(活跃页面).<br>b)    如果分配给一个进程的物理块数太少了，使该进程的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生缺页<br>c)    如果能为进程提供与活跃页面数相等的物理块数，则可减少缺页中断次数</li><li>  working-set window  a fixed number of page references 工作集窗口（Δ）是指对于给定的访问序列选取定长的区间，落在工作集窗口中的页面集合称为工作集<br>正确选择工作集窗口（Δ）的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。</li><li>工作集理论可用于预调页，用于防止颠簸，但不够灵活<br>一种更加直接的防止颠簸的方法是控制缺页频率（ Page-Fault Frequency ）：<br>颠簸具有较高的缺页率，所以通过控制缺页频率，可以有效地防止颠簸的发生。</li><li>Page size selection（页面尺寸选择）<br>a)    Fragmentation（碎片）页面大，则内碎片大<br>b)    table size （表大小）页面小，则页表占用的空间大<br>c)    I/O overhead（I/O开销）磁盘I/O时间中传输时间和数据量有关系，但它占的比例很小，而寻道时间和旋转延迟时间占了很大的比例。所以页面尺寸比较大会有利于减少磁盘I/O时间。<br>d)    减少I/O及内存的占用：要求页面尺寸小 ，采用小页，总的I/O就会降低，因为小页能够更精确的匹配局部<br>e)    减少缺页率：要求页面尺寸大<br>f)    总的趋势：页面尺寸越来越大，这是由于CPU速度和内存容量的增长超过了磁盘速度的加快</li><li>ppt10章 101页例题无敌</li></ol><p></p><p id="FileSystem"></p><p></p><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a><strong>File System</strong></h1><p>文件：具有文件名的一组相关信息的集合。</p><ol start="2"><li>文件系统：OS中与文件管理有关的那部分软件及被它们管理的文件和文件属性的集合。</li><li>使用：用户通过文件系统提供的系统调用来实施对文件的操作：建、删除、写、读、打开、关闭等</li><li>文件的逻辑结构：顺序，索引，索引顺序<br>物理结构：连续，链接，索引</li><li>文件的管理 : 用户按逻辑结构使用文件，文件系统按物理结构管理文件。因此，当用户请求读写文件时，文件系统必须实现文件的逻辑结构与物理结构之间的转换。</li><li>连续分配: 每一个文件占用一个连续的磁盘块的集合<br>a)    优点：简单、顺序访问速度快、支持随机存取<br>b)    缺点：外碎片、空间利用率低、不利于文件的动态增长（需事先知道文件的长度）</li><li>链接分配（离散分配方式）<br>a)    隐式链接：指针。外碎片、允许作业动态增长；可靠性差、只适于顺序访问, 更多的寻道次数和寻道时间<br>b)    显式链接（文件分配表FAT）：不支持高效的随机存取，FAT表占用空间</li><li>索引分配（离散分配方式）<br>a)    每个文件建立一张索引表，指出分配给该文件的所有物理块号<br>b)    支持高效随机存取、消除了外碎片、允许文件动态增长；但索引表占用较多空间</li><li>混合索引分配方式（UNIX采用）<br>a)    i 结点中设13个地址项：直接地址（0-9） 、一次间址（10）、二次间址（11）、三次间址（12）</li><li>File Directory文件目录：一个包含着所有文件信息的节点的集合，目录结构和文件都磁盘上。文件控制块的有序集合</li><li>文件控制块FCB<br>a)    用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的盘物理地址<br>b)    文件控制块的有序集合称为文件目录，即一个文件控制块FCB就是一个文件目录项。</li><li>Two-Level Directory两级目录<br>a)    一级称为主文件目录（MFD），给出用户名，用户子目录所在的物理位置；<br>b)    二级称为用户文件目录（UFD，又称用户子目录），给出该用户所有文件的FCB</li><li>树形目录：结构清晰方便管理保护，方便分了，提高检索速度，解决重名问题，查找逐层多次访盘影响速度</li><li>Acyclic-Graph Directories（无环图结构目录）：有共享的子目录和文件</li><li>文件别名实现：<br>a)    索引节点 硬链接：目录内容分为两部分：文件名和索引结点。前者包括文件名和索引结点编号，后者包括文件的其他内容（包括属主和访问权限）。通过多个文件名链接(link)到同一个索引结点，别名的数目记录在索引借点的链接计数中，减少到0则文件删除。<br>b)    符号链接(symbolic link, shortcut)：特殊类型的文件，其内容是到另一个目录或文件路径的链接。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。</li><li>Free-Space Management 空闲空间管理<br>a)    位图法：一串二进制位反映磁盘空间中分配使用情况, 每个物理块对应一位, 分配物理块为0，否则为1。 申请物理块时，可以在位示图中查找为1的位，返回对应物理块号； 归还时；将对应位置1。<br>b)    空闲块表 ：所有空闲块记录在一个表中，即空闲块表，有两项：该空闲区的第一个盘块号、该区的空闲盘块总数<br>c)    空闲块链表：所有空闲块链成一个链. 扩展：成组链接法<br>d)    成组链接法：将一个文件卷的所有空闲盘块按固定大小（如每组100块）分成若干组，并将每组的盘块数和该组所有盘块号记入前一组的最后一个备用块内，第一组的盘块数（可小于100）和该组所有的盘块号记入超级块的空闲盘块号栈中。</li><li>文件系统性能的改善：为提高对文件的访问速度，可从三个层次上着手：<br>a)    改进文件的目录结构以及检索目录的方法，来减少对文件的查找时间；<br>b)    选择好的文件存储结构，以提高对文件的访问速度；<br>c)    提高磁盘I/O速度，以提高对数据的传送速度。</li></ol><p></p><p id="IOSystem"></p><p></p><h1 id="IO-System"><a href="#IO-System" class="headerlink" title="IO System"></a><strong>IO System</strong></h1><ol><li>IO系统的目标：提高设备的利用率<br>a)    尽量提高CPU与I/O设备之间的并行工作程度<br>b)    主要技术：中断技术、DMA技术、通道技术、缓冲技术</li><li>I/O系统的组成：设备控制器 I/O通道 总线</li><li>I/O通道：通道是独立于CPU的专门负责数据I/O传输工作的处理机，对外部设备实现统一管理，代替CPU对I/O操作进行控制，从而使I/O操作可与CPU并行操作。 通道可以执行通道程序。把CPU从繁杂的I/O任务中解脱出来，提高CPU与设备，设备与设备之间的并行工作能力</li><li><p>I/O控制方式<br>a)    程序I/O方式(轮询Polling)：准备好了0没有1 串行工作<br>b)    中断驱动I/O：<br>i.    CPU向设备控制器发出一条I/O命令后，立即返回继续执行原来的任务。<br>ii.    设备控制器便控制I/O设备进行I/O。<br>iii.    当设备完成了一个字节数据的I/O时，设备控制器产生一个中断信号。<br>iv.    CPU检测到中断信号后，进行相应的处理工作。<br>c)    直接存储器访问（Direct Memory Access）DMA控制方式：DMA方式较之中断驱动方式，成百倍地减少了CPU对I/O的干预，进一步提高了CPU与I/O设备的并行操作程度。<br>d)    I/O通道控制方式：进一步减少CPU的干预，即把对一个数据块的I/O为单位的干预，减少到以对一组数据块的I/O及有关的控制和管理为单位的干预。</p></li><li><p>缓冲技术：为提高I/O速度和设备的利用率，几乎所有的I/O设备在与处理机（内存）交换数据时，都使用了缓冲区。<br>引入缓冲的主要原因有以下三点：<br>a)    缓和CPU与I/O设备间速度不匹配的矛盾<br>b)    减少对CPU的中断频率，放宽对中断响应时间的限制<br>c)    提高CPU和I/O设备之间的并行性 </p></li><li>OS提供以下几种缓冲形式：<br>a)    单缓冲<br>b)    双缓冲<br>c)    循环缓冲<br>d)    缓冲池：<br>i.    空（闲）缓冲区；<br>ii.    输入缓冲区:装满输入数据；<br>iii.    输出缓冲区:装满输出数据</li><li>I/O软件组织成以下4个层次：<br>a)    (1)用户空间的I/O软件：与用户程序连接在一起的库过程构成，它们运行在OS内核之外。系统调用，包括I/O系统调用，通常由库过程实现<br>b)    (2)与设备无关的I/O软件(设备独立软件)<br>i.    设备命名<br>ii.    设备保护<br>iii.    设备分配<br><img src="/img/OS/summary/22.png" alt=""><br>iv.    用户使用方法：申请分配  使用 释放<br>c)    (3)设备驱动程序：操作系统能够以统一的方式对待不同的I/O设备，因为具体的差别被称为设备驱动程序 的内核模块所封装<br>d)    (4)中断处理程序：<br>i.    在 I/O 时，设备控制器如果准备好服务会向CPU发出一中断请求。<br>ii.    这些中断表示输入数据已有，或输出已完成，或已检测到错误。<br>iii.    CPU响应后便转向中断处理程序</li></ol><p></p><p id="SecondaryStorage"></p><p></p><h1 id="Secondary-Storage"><a href="#Secondary-Storage" class="headerlink" title="Secondary Storage"></a><strong>Secondary Storage</strong></h1><ol start="8"><li><p>SPOOLing技术  什么是SPOOLing：<br>a)    利用多道程序中的一道程序来模拟脱机输入时的外围控制机的功能，把低速I/O设备上的数据传送到高速磁盘上；<br>b)    用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上<br>c)    这样，便在主机的直接控制下，实现脱机输入、输出功能。<br>d)    此时的外围操作与CPU对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为SPOOLing (Simultaneous Peripheral Operations On-Line)，或称假脱机操作。 </p></li><li><p>SPOOLing的组成：SPOOLing系统是对脱机输入、输出工作的模拟，它必须有高速随机外存的支持，这通常是采用磁盘。<br><img src="/img/OS/summary/23.png" alt=""></p></li><li>SPOOLing系统的特点<br>a)    提高了I/O速度<br>b)    将独占设备改造为共享设备<br>c)    实现了虚拟设备功能 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>11-structual testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/11-structual%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/11-structual%20testing/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><br></p><ul><li><h1 id="DD-path覆盖"><a href="#DD-path覆盖" class="headerlink" title="DD-path覆盖"></a><strong>DD-path覆盖</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的每个DD路径，则它们构成DD路径覆盖。<br><br></li></ul></li><li><h1 id="branch覆盖"><a href="#branch覆盖" class="headerlink" title="branch覆盖"></a><strong>branch覆盖</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的决策（predicate）的每个分支（输出），则它们构成分支覆盖。<br><br></li></ul></li><li><h1 id="path-coverage"><a href="#path-coverage" class="headerlink" title="path coverage"></a><strong>path coverage</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中从源节点到汇聚节点的每条路径，则它们构成路径覆盖。<br><br></li></ul></li><li><h1 id="node-coverage"><a href="#node-coverage" class="headerlink" title="node coverage"></a><strong>node coverage</strong></h1><ul><li>如果在程序上执行时，遍历程序图中的每个节点，则它们构成节点覆盖。<br><br></li></ul></li><li><h1 id="edge-coverage"><a href="#edge-coverage" class="headerlink" title="edge coverage"></a><strong>edge coverage</strong></h1><ul><li>遍历程序图中的每个边，则它们构成边缘覆盖。<br><br><br><strong>语句覆盖</strong><br>使所有的判断语句都能执行一次的条件案例，例如当判断语句事组合语句的时候，并且用or连接，只满足一个案例即可<br><strong>判定覆盖（分支覆盖）</strong><br>针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况<br><strong>条件覆盖</strong><br>针对判断语句里面案例的取值都要去一次，不考虑条件的取值<br><strong>判定/条件覆盖</strong><br>判定覆盖各条件覆盖交叉，针对于判定中的条件取值<br><strong>组合覆盖</strong><br>判定-条件覆盖的加强版 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>10-Stochastic or Random Test</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/10-Stochastic%20or%20Random%20Test/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/10-Stochastic%20or%20Random%20Test/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>What</li><li>Why</li><li>特点<a id="more"></a><br></li></ul></li><li><h1 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a><strong>随机测试</strong></h1><ul><li>黑盒测试</li><li>输入:Random，independent</li><li>输出:Compared against software specifications to verify that the test output is pass or fail</li><li>测试过程：自动化</li><li>覆盖范围：广泛但浅显<br><br></li></ul></li><li><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a><strong>Why</strong></h1><ul><li>随机测试可以让我们轻松的根据测试结果估算软件可靠性。</li><li>可以从随机测试中获得数据用于估计软件的可靠性(其他测试方法不能用这种方式来估算软件可靠性）</li><li>相比于其他更为周到的测试方法，可以节约精力和时间<br><br></li></ul></li><li><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul><li>无需任何特定测试</li><li>在无文档、无计划下的软件测试</li><li>可以发现测试用例覆盖不到的bug</li><li>随机测试几乎可以在任何时候进行</li><li>测试软件的鲁棒性</li><li>发现低优先级高严重性的bug<br><br></li></ul></li><li><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h1>与模糊测试的区别：<br>  模糊测试：随机数据<br>  随机测试：随机行为<br>与探索性测试的区别：<br>  随机测试：思维过程无序<br>  探索性测试：思维过程具有有序性、合理性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>9-Scenario testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/9-Scenario%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/9-Scenario%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="场景测试"><a href="#场景测试" class="headerlink" title="场景测试"></a><strong>场景测试</strong></h1><ul><li>在软件开发过程的测试阶段中，由于实际系统过分庞大和复杂，很难测试其全部功能，而只能测试其与执行的任务有类似性的主要功能<a id="more"></a><br></li><li>目标<ul><li>使用具有挑战性的案例来反映实际的使用</li></ul></li><li>测试者<ul><li>Anyone</li></ul></li><li>覆盖率<ul><li>场景所能覆盖的所有区域</li></ul></li><li>可能存在的问题<ul><li>有经验的用户在实际使用时的复杂交互</li></ul></li><li>活动<ul><li>采访相关人员，写场景剧本然后执行测试</li></ul></li><li>复杂度<ul><li>高</li></ul></li><li>被测试系统阶段<ul><li>后期 需要稳定 集成的功能<br><br></li></ul></li></ul></li><li><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h1><ul><li>可以帮助解决复杂、现实中的问题。解决一些因为复杂而难以建模分析的情况。</li><li>暴露随着时间的流逝而可能会出现的错误。</li><li>可以使测试情景与将来的工作情境尽可能相似，测出的结果具有很好的预测效果</li></ul></li><li><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a><strong>缺陷</strong></h1><ul><li>单个功能的错误会让这个测试变得效率底下。</li><li>必须思虑周详以达成好的覆盖。测试者需要较有经验。</li><li>分析过程较为人为化，客观性受到影响</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>8-User Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/8-User%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/8-User%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="用户测试"><a href="#用户测试" class="headerlink" title="用户测试"></a><strong>用户测试</strong></h1><ul><li>定义：以用户为为参与主体的测试</li><li>引入原因：用户作为软件最终使用的主体</li><li>测试目标：测试软件的总体情况及用户体验</li><li>测试者：用户</li><li>覆盖面：很难度量</li><li>测试启动时间：软件开发基本完成<a id="more"></a><br></li></ul></li><li><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h1><ul><li>暴露设计的问题</li><li>能找到高错误率的区域</li><li>测试过程能够被监控</li><li>能够通过内部实验室注意有争议的区域<br><br></li></ul></li><li><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h1><ul><li>覆盖面不能够保证</li><li>测试用例弱</li><li>结果好坏不一</li><li>必须区分营销测试与技术测试</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>7-Exploratory Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/7-Exploratory%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/7-Exploratory%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="探索性测试"><a href="#探索性测试" class="headerlink" title="探索性测试"></a><strong>探索性测试</strong></h1><ul><li>探索性测试（ET）可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索测试强调测试人员的主观能动性，避免繁杂的测试计划和测试用例设计的文档制作过程，强调在碰到问题时及时改变测试策略<a id="more"></a><br><br>探索性测试的最大特色是在对测试对象进行测试的同时学习测试对象并设计测试，在测试过程中运用获得的关于测试对象的信息设计新的更好的测试.<br>这相对于传统软件测试过程中严格的“先设计，后执行”来说，是具有很大区别的.<br><br>  </li></ul></li><li><h1 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a><strong>基本过程</strong></h1><ul><li>识别软件系统的目的；</li><li>识别软件系统提供的功能；</li><li>识别软件系统潜在的不稳定的区域；</li><li>在探索软件系统的过程中记录关于软件的消息和问题；</li><li>创建一个测试纲要，使用它来执行测试。</li></ul><p><br></p></li><li><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h1><ul><li>不需要太多的准备工作，能够很快的发现重要的错误。</li><li>测试人员可以根据先前的测试结果来调整之后的测试用例，这在某种意义上可以加快bug发现的过程。</li><li>对产品质量有个整体概念，可以作为整个项目里工作分级的一个基础。<br><br></li></ul></li><li><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h1><ul><li>测试用例很难全面覆盖。</li><li>容易出现重复测试，且测试难以跟踪。</li><li>需要测试人员具有较高水平。<br><br></li></ul></li><li><h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a><strong>适用范围</strong></h1><ul><li>需要对新功能或是新产品提供快速的反馈的测试</li><li>为测试用例的设计,前期进行尝试性测试</li><li>已经过了传统测试,但需要进一步测试</li><li>对已有测试用例的改进</li><li>要求在短时间内发现一些重要缺陷的测试</li><li>管理人员需要测试一下测试人员的工作成果</li><li>测试某一特定类型的缺陷</li><li>测试一些已知的缺陷</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>6-Regression testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/6-Regression%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/6-Regression%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="回归测试（Regression-testing）"><a href="#回归测试（Regression-testing）" class="headerlink" title="回归测试（Regression testing） "></a><strong>回归测试（Regression testing） </strong></h1><ul><li>指在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，软件产生新版本都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。<a id="more"></a><br></li></ul></li><li>回归测试通常被认为是“程序的重新确认”；<ul><li>“纠正型回归测试”指对程序修改后进行回归测试；</li><li>“增量型回归测试”指程序增加新特性后进行测试。<br><br></li></ul></li><li><h1 id="回归测试多余？"><a href="#回归测试多余？" class="headerlink" title="回归测试多余？"></a><strong>回归测试多余？</strong></h1><ul><li>开发人员也可以通过适当的证据证明新增的方法对原方法没有影响，这种情况下回归测试是多余的。<br><br></li></ul></li><li><h1 id="必须进行回归测试的情况"><a href="#必须进行回归测试的情况" class="headerlink" title="必须进行回归测试的情况"></a><strong>必须进行回归测试的情况</strong></h1><ul><li>当对软件的一个子系统进行修改，得到软件的一个新版本，此时回归测试是必需的；</li><li>当对软件的一个或多个构件进行了修改，整个软件也必须进行回归测试</li><li>在某些情况下，当底层硬件发生变化时，无论软件有无变更，也需要进行回归测试<br><br></li></ul></li><li><h1 id="回归测试过程"><a href="#回归测试过程" class="headerlink" title="回归测试过程"></a><strong>回归测试过程</strong></h1><ul><li>测试重确认/选择/最小化/优先级排序<ul><li><strong>测试重确认</strong>：检查p的测试用例，以确定哪些是对p’。重确认确保回归测试时只使用那些对p’有效的用例(p’为新版本)</li><li><strong>测试选择</strong>：对p有效的测试对p’可能是多余的因为它们的执行轨迹不经过p’中已修改过的代码。识别那些执行轨迹经过p’修改部分的测试过程就称为测试选择，优势也称为回归测试选择(RTS)问题</li><li><strong>测试最小化</strong>：根据某些准则丢弃那些多余的测试用例。例如t1和t2都测试了p的功能f，那么在测试最小化的时候，就可能丢弃t2而丢弃t1</li><li><strong>测试优先级排序</strong>：是基于某些准则对测试用例进行排序。当资源受限，通过测试优先级排序，就会发挥作用</li></ul></li><li>测试准备<ul><li>测试准备是指将被测程序置于预期的或者模拟的测试环境中，准备接收数据，并产生，需要的输出信息</li></ul></li><li>测试排序<ul><li>测试过程中有可能关心对软件的测试输入顺序。对具有内部状态且连续运行的软件来讲，测试排序非常重要。银行结算软件、web服务、引擎控制器等都是这类软件</li></ul></li><li>测试执行<br>- </li><li>输出比较</li><li>故障消除</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>5-Stress Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/5-Stress%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/5-Stress%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>压力测试简述</li><li>压力测试特点</li><li>压力测试步骤</li><li>压力测试实例<a id="more"></a><br></li></ul></li><li><h1 id="Stress-Testing"><a href="#Stress-Testing" class="headerlink" title="Stress Testing"></a><strong>Stress Testing</strong></h1><ul><li>是指不断给被测系统增加压力，直到被测系统被压垮，并在系统被压垮的情况下持续测试。</li><li>以确定系统能承受的最大压力以及系统是否具有良好的容错能力和可恢复能力。<br><br></li></ul></li><li><h1 id="压力测试的特点"><a href="#压力测试的特点" class="headerlink" title="压力测试的特点"></a><strong>压力测试的特点</strong></h1><ul><li>测试者：在软件压力测试方面具备专业知识和一定的操作技能的人</li><li>代码覆盖率：部分覆盖，难以界定是否覆盖完全</li><li>测试阶段：开发项目接近完成</li><li>粗颗粒度：压力测试极其粗糙</li><li>复杂性：根据软件自身的需求有所不同</li><li>优点<ul><li>能暴露系统可能出现的缺陷</li><li>能暴露系统的安全风险</li><li>可能对评估性能、可靠性或效率有帮助</li></ul></li><li>局限性<ul><li>缺陷可能在压力测试下并不明显</li><li>当不知道问题的大致区间时，压力测试就会比较慢</li><li>易出现“不知道因为什么导致了问题”和“有没有遗漏什么”的问题<br><br></li></ul></li></ul></li><li><h1 id="压力测试的步骤"><a href="#压力测试的步骤" class="headerlink" title="压力测试的步骤"></a><strong>压力测试的步骤</strong></h1><ol><li>Identify the Test Environment 确认测试环境</li><li>Identify Performance Acceptance Criteria 确认性能指标</li><li>Plan and Design Tests 计划并设计测试</li><li>Configure the Test Environment 配置测试环境</li><li>Implement the Test Design 实现设计好的测试</li><li>Execute the Test 执行测试</li><li>Analyze Results, Report, and Retest 分析、报告、重复测试</li></ol></li></ul><p><br></p><ul><li><h1 id="压力测试与其他测试的关系"><a href="#压力测试与其他测试的关系" class="headerlink" title="压力测试与其他测试的关系"></a><strong>压力测试与其他测试的关系</strong></h1>常见的测试有：负载测试、压力测试和性能测试。<br>三者测试目的不同，但其手段和方法在一定程度上比较相似，通常会使用相同的测试环境和测试工具，而且都会监控系统所占用资源的情况以及其它相应的性能指标。</li></ul><ol><li><strong>tester</strong>：三者都应该具有一定的专业水平</li><li><strong>coverage</strong>：三者均为部分覆盖，存在局限性，难以确定是否覆盖了所有可能的缺陷</li><li><strong>potential problem</strong>：压力测试是期望系统崩溃；负载测试是期望得到系统的响应时间和质量；性能测试时为了了解应用程序在常规参数下的行为方式</li><li><strong>activities</strong>：压力测试往往要增加比负载测试多的并发用户，一般要比系统设计的并发量大，而性能测试验证产品资源的使用情况，可用性及可靠性</li><li><strong>evaluation</strong>：压力测试是看服务器能否在崩溃后自我恢复，任何意外故障是否会损害系统安全性；负载测试是看系统的响应时间和质量是否符合设计要求及当前的基础设施是否足以运行应用程序；性能测试是看系统是否符合业务的性能需求，验证该应用程序能否正常运行</li><li><strong>focus</strong>：性能测试的关注点在于程序运行的响应时间和并发量，负载测试的关注点在于系统并发量的多少，而压力测试更关注在超过了系统极限值的限制范围后系统的影响。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4-Risk-based Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/4-Risk-based%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/4-Risk-based%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Targets, concept and benefits of RBT</li><li>Risk and Risk management</li><li>Risk-based testing approach</li><li>Risk-based testing in practice</li><li>Risk matrix and Risk reporting</li><li>Risk-based testing and test automation<a id="more"></a><br></li></ul></li><li><h1 id="Why-Risk-based-Testing"><a href="#Why-Risk-based-Testing" class="headerlink" title="Why Risk-based Testing?"></a><strong>Why Risk-based Testing?</strong></h1><ul><li>Software projects are very <strong>rarely on time,schedule or budget.</strong> Very often early project phases are delayed.</li><li>When eventually comes down to testing, the time to delivery is <strong>extremely short</strong> and there is <strong>no budget left</strong> due to the development overrun.</li><li>During development everybody is as a rule extremely busy resulting the test preparation activities not receiving the <strong>appropriate attention.</strong><br><br></li></ul></li><li><h1 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a><strong>RBT</strong></h1><ul><li>RBT(Risk-based Testing) is a test method deciding the test strategy by analyzing and accessing the risk of product.</li><li>Reduced resource consumption(i.e., more efficient testing)</li><li>Improved quality by spending more time on critical functions.<br><br></li></ul></li><li><h1 id="Risk-and-Risk-management"><a href="#Risk-and-Risk-management" class="headerlink" title="Risk and Risk management"></a><strong>Risk and Risk management</strong></h1><ul><li>Risk Identification</li><li>Risk Strategy</li><li>Risk Assessment</li><li>Risk Mitigation</li><li>Risk Reporting</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>3-Specification-based testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/3-Specification-based%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/3-Specification-based%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h1><ul><li>黑盒测试、功能测试、数据驱动测试</li><li>测试者不了解程序的内部情况，不需具备应用程序的代码、内部结构和编程语言的专门知识。只知道程序的输入、输出和系统的功能，这是从用户的角度针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。<a id="more"></a></li></ul></li><li>基本属性<ul><li>目标：核验需求文档里每个要求的一致性。</li><li>测试者：可以任何人。</li><li>覆盖内容：文档化的需求以及一些特性。</li><li>潜在问题：实现与规格不匹配的问题。</li><li>评估方法：实现是否与规格匹配。</li><li>复杂度：由规格说明书决定</li><li>苛刻度：有规格说明书决定<br><br></li></ul></li><li>如何在缺少规格说明书的情况下获取信息?有什么可行的替代方法？<ul><li>在缺少规格说明书或者是规格说明书不正确的时候可以使用使用如下资源<ul><li>软件更新备忘录</li><li>用户手册草稿</li><li>产品资料</li><li>已发布的样式指南和UI标准</li><li>已发布的标准</li><li>第三方产品兼容性测试套件</li><li>内部备忘录</li><li>营销展示、产品概念</li><li>Bug报告</li><li>逆向工程 ….<br><br></li></ul></li></ul></li><li><h1 id="规格说明"><a href="#规格说明" class="headerlink" title="规格说明"></a><strong>规格说明</strong></h1><ul><li>规格说明书要求做到精确和细化需求中描述的系统功能性需求和约束。</li><li>规格说明是为了技术人员编写的</li><li>规格说明书的形式可以是多种多样的。下面列出几个常见的规格说明书形式：<ul><li>需求文档 用例 模型 形式化方法 原型  …</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2-Equivalence analysis</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/2-Equivalence%20analysis/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/2-Equivalence%20analysis/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>等价类划分</li><li>等价类划分指南</li><li>等价类划分实例<a id="more"></a><br></li></ul></li><li><h1 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a><strong>等价类</strong></h1><ul><li>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的。<br><br></li></ul></li><li><h1 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a><strong>等价类划分</strong></h1><ul><li>等价类划分，指一种典型的、重要的<strong>黑盒测试方法</strong>，它将程序所有可能的输入数据划分为若干个等价类。然后从每个部分中选取具有代表性的数据当做测试用例。利用这一方法设计测试用例可以不考虑程序的内部结构，以需求规格说明书为依据，选择适当的典型子集，认真分析和推敲说明书的各项需求，特别是功能需求，尽可能多地发现错误。等价类划分法是一种系统性的确定要输入的测试条件的方法。<br><br></li></ul></li><li><h1 id="有效等价类划分"><a href="#有效等价类划分" class="headerlink" title="有效等价类划分"></a><strong>有效等价类划分</strong></h1><ul><li>有效等价类指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个，根据系统的输入域划分若干部分，然后从每个部分中选取少数有代表性数据当做数据测试的测试用例，等价类是输入域的集合。</li><li>以下是对有效等价类数据集的一些例子：<ul><li>终端用户输入的命令</li><li>与最终用户交互的系统提示</li><li>接受相关的用户文件的名称</li><li>提供初始化值和边界等</li><li>提供格式化输出数据的命令</li><li>在图形模式（比如鼠标点击时）提供的数据</li><li>失败时显示的回应消息<br><br></li></ul></li></ul></li><li><h1 id="无效等价类划分"><a href="#无效等价类划分" class="headerlink" title="无效等价类划分"></a><strong>无效等价类划分</strong></h1><ul><li>无效等价类和有效等价类相反，无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。利用无效等价类，可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。</li><li>以下是无效等价类数据集的一些例子：<ul><li>终端在一个不正确的地方提供适当的值</li><li>验证外部边界的值</li><li>验证与边界和外部边界值的数值数据<br><br></li></ul></li></ul></li><li><h1 id="等价类划分指南"><a href="#等价类划分指南" class="headerlink" title="等价类划分指南"></a><strong>等价类划分指南</strong></h1><ul><li>等价类划分的方法<ul><li><strong>输入条件制定了一个域</strong></li><li><strong>输入条件指定了一组值的集合</strong>: 为集合中的每个元素创建一个等价类，为一个无效输入也创建一个等价类</li><li><strong>输入条件指定了每一个单独的值</strong>：如果系统对每一个有效输入的处理都不同，那么为每一个有效输入创建一个等价类</li><li><strong>输入条件指定了有效值的数量</strong>：为正确的输入数量创建一个等价类，为无效输入创建两个等价类——一个数量为零，一个比N大</li><li><strong>输入条件指定了一个必须值</strong>：为该必须值创建一个等价类，为非必须值创建一个等价类</li><li><strong>分割等价类</strong>：如果系统以不同方式处理一个划分好的等价类中的元素，那么分割该等价类为更小的等价类</li></ul></li><li>从等价类中识别测试用例<ol><li>为每个等价类指定一个唯一的标识符</li><li>对于每个还未被测试用例覆盖到的有效输入等价类，生成新的测试用例，尽量多地覆盖还未覆盖到的等价类，按照这一步骤重复进行，直到所有的有效等价类都被覆盖为止</li><li>对于每个还未被测试用例覆盖到的无效输入等价类，生成新的测试用例，仅覆盖一个还未覆盖到的等价类，按照这一步骤重复进行，直到所有的无效等价类都被覆盖为止。<br><br></li></ol></li></ul></li><li><h1 id="等价类划分实例"><a href="#等价类划分实例" class="headerlink" title="等价类划分实例"></a><strong>等价类划分实例</strong></h1><h2 id="Ex-A"><a href="#Ex-A" class="headerlink" title="Ex A"></a><strong>Ex A</strong></h2>申请账号时，用户必须输入用户名、密码、确认密码，对每一项输入条件要求如下：用户命要求为6位以上，18位以下，使用英文字母、数字、“-”、“”,并且首字符必须为字母或数字；密码在6~16位之间，只能用英文字母、数字、“-”、“”,并且区分大小写。列出等价类表和测试用例。</li></ul><p><strong>等价类表：</strong><br><img src="/img/soa/ex1_1.jpg" alt=""><br><strong>等价类的测试用例：</strong><br><img src="/img/soa/ex1_2.jpg" alt=""><br><br></p><h2 id="Ex-B"><a href="#Ex-B" class="headerlink" title="Ex B"></a><strong>Ex B</strong></h2><p>一个程序读入3个整数，把这3个数值看作一个三角形的3条边的长度值。这个程序要打印出信息，说明这个三个数值不构成三角形、或是一般三角形、或是等腰的三角形、或是等边三角形。列出等价类表和测试用例。<br><strong>分析题目中给出和隐含的对输入条件的要求：</strong></p><ol><li>整数   2. 三个数   3. 非零数  4. 正数  5. 两边之和大于第三边   6.等腰   7. 等边<br>如果a、b、c满足条件1~4，则输出下列四种情况之一：<br>1）如果不满足条件5，则程序输出为“非三角形”<br>2）如果三条边相等即满足条件7，则程序输出为“等边三角形”<br>3）如果只有两条边相等，及满足条件6，则程序输出为“等腰三角形”<br>4）如果三条边都不相等，则程序输出为“一般三角形”<br><br><br><strong>等价类表</strong><br><img src="/img/soa/ex2_1.jpg" alt=""><br><br><br><strong>覆盖有效等价类的测试用例</strong><br><img src="/img/soa/ex2_2.jpg" alt=""><br><br><br><strong>覆盖无效类等价类的测试用例</strong><br><img src="/img/soa/ex2_3.jpg" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1-Function testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/1-Function%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/1-Function%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Function-testing"><a href="#Function-testing" class="headerlink" title="Function testing"></a><strong>Function testing</strong></h1><ul><li>也叫黑盒单元测试</li><li>针对每个功能单元进行的一种黑盒测试。<a id="more"></a><br></li></ul></li><li>测试人员<ul><li>可以是任何人：编码人员、测试人员等</li></ul></li><li>覆盖程度<ul><li>覆盖所有的功能以及用户可见的变量</li></ul></li><li>测试的目的<ul><li>为了使每个功能能够单独运作</li></ul></li><li>测试方法<ul><li>穷举法</li><li>边界值分析法</li><li>基于单/多缺陷假设设计测试样例</li><li>等价类划分法</li><li>典型数据法</li><li>…</li></ul></li><li>如何分析结果<ul><li>寻找同类功能做对比.同类功能：例如显卡的功能测试，找同类显卡，在相同的输入条件下比较输出结果。</li></ul></li><li>复杂程度<ul><li>对已实现的各个功能设计测试样例进行测试</li></ul></li><li>严格程度<ul><li>指测试方法对软件错误的容忍程度，即其发现软件错误的能力大小</li></ul></li><li>对系统完成度的要求<ul><li>每一个功能单元完成后便可以进行功能测试</li></ul></li><li>优点<ul><li>对每个测试项目进行全面分析</li><li>Easy to do as each function is implemented</li></ul></li><li>缺点<ul><li>Misses interactions</li><li>Misses exploration of the benefits offered by the program</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>6-Test &amp; Evaluate</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/6-Test%20&amp;%20Evaluate/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/6-Test%20&amp;%20Evaluate/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Defining test techniques</li><li>Individual techniques</li><li>Using techniques together<a id="more"></a><br></li></ul></li><li><h1 id="Dimensions-of-Test-Techniques"><a href="#Dimensions-of-Test-Techniques" class="headerlink" title="Dimensions of Test Techniques"></a><strong>Dimensions of Test Techniques</strong></h1><ul><li>Think of the testing you do in terms of five dimensions:<ul><li>Testers: who does the testing.</li><li>Coverage: what gets tested.</li><li>Potential problems: why you’re testing (what risk you’re testing for).</li><li>Activities: how you test.</li><li>Evaluation: how to tell whether the test passed or failed.<br><br></li></ul></li></ul></li></ul><p>Of the 200+ published Functional Testing techniques, there are ten basic themes.<br>They capture the techniques in actual practice.</p><ol><li>Function testing </li><li>Equivalence analysis </li><li>Specification-based testing </li><li>Risk-based testing </li><li>Stress testing </li><li>Regression testing </li><li>Exploratory testing </li><li>User testing </li><li>Scenario testing </li><li>Stochastic or Random testing<br>详情见 Individual techniques 目录<br><br></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>5-Define Evaluation Mission</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/5-Define%20Evaluation%20Mission/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/5-Define%20Evaluation%20Mission/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Define Evaluation Mission</li><li>Defining the mission of the test group</li><li>Defining the goal for test documentation<a id="more"></a><br></li></ul></li></ul><p><code>In this module, we begin with the workflow detail Define Evaluation MissionThe Mission focuses on the high-level objectives of the test team for the current iteration</code><br><br></p><ul><li><h1 id="Define-Evaluation-Mission"><a href="#Define-Evaluation-Mission" class="headerlink" title="Define Evaluation Mission"></a><strong>Define Evaluation Mission</strong></h1><ul><li>The purpose of this workflow detail is to:</li><li>确定迭代测试工作的适当重点。</li><li>与利益相关方就实现测试工作的相应目标达成协议</li><li>对于每次迭代，工作主要集中在：<ul><li>确定测试工作的目标和可交付成果</li><li>确定良好的资源利用战略</li><li>为测试工作定义适当的范围和边界</li><li>概述将使用的方法</li><li>确定如何监控和评估进展情况。<br><br></li></ul></li></ul></li><li><h1 id="Defining-the-Test-Approach"><a href="#Defining-the-Test-Approach" class="headerlink" title="Defining the Test Approach"></a><strong>Defining the Test Approach</strong></h1><ul><li>The test approach (testing strategy)specifies the techniques that will be used to accomplish the test mission.</li><li>The test approach also specifies how the techniques will be used.</li><li>A good test approach is:<ul><li>Diversified<ul><li>Include a variety of techniques. Each technique is tailored to expose <strong>certain types of problems</strong>, and is virtually blind to others. <strong>Combining</strong> them allows you to find problems that would be hard to find if you spent the same resource on a narrower collection of techniques.</li></ul></li><li>Risk-focused<ul><li>Tests give you the opportunity to find defects or attributes of the software that will disappoint, alienate, or harm a stakeholder. You can’t run all possible tests. To be efficient, you should think about the types of problems that are plausibly in this product or that would make a difference if they were in this product, and make sure that you test for them.</li></ul></li><li>Product-specific<ul><li>Generic test approaches don’t work. Your needs and resources will vary across products. The risks vary across products. Therefore the balance of investment in different techniques should vary across products.</li></ul></li><li>Practical<ul><li>here’s no point defining an approach that is beyond your project’s capabilities (including time, budget, equipment, and staff skills).</li></ul></li><li>Defensible<br><br></li></ul></li></ul></li><li><h1 id="Defining-the-goal-for-test-documentation"><a href="#Defining-the-goal-for-test-documentation" class="headerlink" title="Defining the goal for test documentation"></a><strong>Defining the goal for test documentation</strong></h1><ul><li><em>What Test Documentation Should You Use?</em><ul><li>Test planning standards and templates</li><li>Requirements considerations</li><li>Questions to elicit information about test documentation requirements for your project</li></ul></li><li>IEEE Standard 829 for Software Test Documentation<br><img src="/img/soa/standard829.png" alt=""></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4-The RUP Test Discipline</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/4-The%20RUP%20Test%20Discipline/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/4-The%20RUP%20Test%20Discipline/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>The terminology of RUP</li><li>The testing discipline in RUP</li><li>The testing workflow structure<a id="more"></a><br></li></ul></li><li><h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a><strong>WHAT</strong></h1><ul><li><strong>The Rational Unified Process (RUP)</strong> is a software engineering process framework that provides a <strong>disciplined yet flexible</strong> approach to <strong>assigning tasks and responsibilities</strong> within a software development organization.</li><li><strong>RUP’s goal</strong> is to support the production of high-quality software that meets the needs of its end users within a <strong>predictable schedule and budget.</strong><br><br></li></ul></li><li><h1 id="The-RUP-supports-many-software-engineering-practices"><a href="#The-RUP-supports-many-software-engineering-practices" class="headerlink" title="The RUP supports many software engineering practices"></a><strong>The RUP supports many software engineering practices</strong></h1><ul><li>The dynamic structure (phases and iterations) of the Rational Unified Process creates a basis for iterative development.</li><li>The Project Management discipline describes how to set up and execute a project using phases and iterations.</li><li>The Use-Case Model and Risk List of the Requirements discipline help determine what functionality you implement in each iteration.</li><li>The Workflow Details of the Requirements discipline show the activities and artifacts that make requirements management possible.</li><li>The iterative approach allows you to progressively identify components, decide which ones to develop, which ones to reuse, and which ones to buy.</li><li>The Unified Modeling Language (UML) used in the process represents the basis of Visual Modeling and has become the de facto modeling language standard.</li><li>The focus on software architecture allows you to articulate the structure: the components and the ways in which they integrate, the fundamental mechanisms and patterns by which they interact<br><img src="/img/soa/RUPProcessArch.png" alt=""><br><br></li></ul></li><li><h1 id="The-Rational-Unified-Process-has-four-phases"><a href="#The-Rational-Unified-Process-has-four-phases" class="headerlink" title="The Rational Unified Process has four phases:"></a><strong>The Rational Unified Process has four phases:</strong></h1><ul><li>Inception - Define the project scope, gain agreement on project objectives, baseline the product Vision</li><li>Elaboration - Address key technical risks, produce an evolutionary prototype, baseline the Architecture</li><li>Construction - Iteratively and incrementally develop an operationally complete product</li><li>Transition - Deliver the product into the live end-user environment</li><li>初始 - 定义项目范围，就项目目标达成一致，为产品愿景奠定基础</li><li>精化 - 解决关键技术风险，制作演化原型，建立基线</li><li>构建 - 迭代并逐步开发出操作完整的产品</li><li>过渡 - 将产品交付给实时最终用户环境<br><br></li></ul></li><li><h1 id="Roles-in-the-Test-Discipline"><a href="#Roles-in-the-Test-Discipline" class="headerlink" title="Roles in the Test Discipline"></a><strong>Roles in the Test Discipline</strong></h1><ul><li>Test Manager<ul><li>is tasked with the overall responsibility for the test effort’s success.</li></ul></li><li>Test Analyst<ul><li>is responsible for initially identifying and defining the required tests, and subsequently evaluating the results of the test effort.</li></ul></li><li>Test Designer<ul><li>is responsible for defining the test approach and ensuring its successful implementation.</li></ul></li><li>Tester<ul><li>is responsible for the core activities of the test effort, which involves conducting the necessary tests and logging the outcomes of that testing.<br><br><br><img src="/img/soa/workflow.png" alt="The RUP Test Discipline Workflow"><br><br></li></ul></li></ul></li><li><h1 id="Define-Evaluation-Mission"><a href="#Define-Evaluation-Mission" class="headerlink" title="Define Evaluation Mission"></a><strong>Define Evaluation Mission</strong></h1><ul><li>Identify the appropriate focus of the test effort for the iteration.</li><li>Gain agreement with stakeholders on the corresponding goals that will direct the test effort.<br><br></li></ul></li><li><h1 id="Test-and-Evaluate"><a href="#Test-and-Evaluate" class="headerlink" title="Test and Evaluate"></a><strong>Test and Evaluate</strong></h1><ul><li>Achieve appropriate breadth and depth of testing to enable a sufficient evaluation of the targeted test items.<br><br></li></ul></li><li><h1 id="Achieve-Acceptable-Mission"><a href="#Achieve-Acceptable-Mission" class="headerlink" title="Achieve Acceptable Mission"></a><strong>Achieve Acceptable Mission</strong></h1><ul><li>Deliver a useful evaluation result to the stakeholders of the test effort.</li><li>Actively prioritize the test work that remains to be conducted.<br><br></li></ul></li><li><h1 id="Verify-Test-Approach"><a href="#Verify-Test-Approach" class="headerlink" title="Verify Test Approach"></a><strong>Verify Test Approach</strong></h1><ul><li>Demonstrate the techniques outlined in the Test Approach will support the required testing.</li><li>Verify that the approach will work, produce accurate results and is appropriate for the available resources.<br><br></li></ul></li><li><h1 id="Validate-Build-Stability"><a href="#Validate-Build-Stability" class="headerlink" title="Validate Build Stability"></a><strong>Validate Build Stability</strong></h1><ul><li>Validate that the build is stable enough for detailed test and evaluation work to begin<br><br></li></ul></li><li><h1 id="Improve-Test-Assets"><a href="#Improve-Test-Assets" class="headerlink" title="Improve Test Assets"></a><strong>Improve Test Assets</strong></h1><ul><li>Maintain and improve the evolving test assets.</li><li>(e.g. Maintain test suites and test data; harvest test-ideas into catalogs; clarify change request details)<br><br></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>3-Introduction to Software Testing</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/3-Introduction%20to%20Software%20Testing/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/3-Introduction%20to%20Software%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Introduce foundation topics of software testing</li><li>Explain test ideas</li><li>Introduce test matrices<a id="more"></a><br></li></ul></li><li><h1 id="Definition-of-Software-Testing"><a href="#Definition-of-Software-Testing" class="headerlink" title="Definition of Software Testing"></a><strong>Definition of Software Testing</strong></h1><ul><li>Software testing is a process, or a series of processes, designed to make sure computer code does what it was designed to do and that it does not do anything unintended.</li><li>Software should be predictable and consistent, presenting no surprises to users.</li><li><strong>Testing is the process of executing a program with the intent of finding errors.</strong><br><br></li></ul></li><li><h1 id="Software-testing-objectives"><a href="#Software-testing-objectives" class="headerlink" title="Software testing objectives"></a><strong>Software testing objectives</strong></h1><ul><li>在测试软件中识别和揭示尽可能多的错误</li><li>在将已识别的错误和重新测试校正后，将测试的软件带到可接受的质量水平。</li><li>在预算和调度限制内有效地执行所需的测试。</li><li>编译软件错误记录以用于错误预防（通过纠正和预防措施）。<br><br></li></ul></li><li><h1 id="Test-model"><a href="#Test-model" class="headerlink" title="Test model"></a><strong>Test model</strong></h1><img src="/img/soa/vmodel.png" alt=""><br><img src="/img/soa/wmodel.png" alt=""><br><br></li><li><h1 id="Classification-of-software-testing"><a href="#Classification-of-software-testing" class="headerlink" title="Classification of software testing"></a><strong>Classification of software testing</strong></h1><img src="/img/soa/softtest.png" alt=""><br><br></li><li><h1 id="Vital-Program-Testing-Guidelines"><a href="#Vital-Program-Testing-Guidelines" class="headerlink" title="Vital Program Testing Guidelines"></a><strong>Vital Program Testing Guidelines</strong></h1><img src="/img/soa/testguidelines.png" alt=""><br><br></li><li><h1 id="Functional-Testing"><a href="#Functional-Testing" class="headerlink" title="Functional Testing"></a><strong>Functional Testing</strong></h1><ul><li>是黑盒测试</li><li>对性能以外的任何外部可见或可测量的软件属性感兴趣。<br><br></li></ul></li><li><h1 id="Test-Ideas"><a href="#Test-Ideas" class="headerlink" title="Test Ideas"></a><strong>Test Ideas</strong></h1><ul><li>A test idea is a brief statement that identifies a test that might be useful. </li><li>A test idea differs from a test case, in that the test idea contains no specification of thetest workings, only the essence of the idea behind the test.</li><li>Test ideas are generators for test cases: potential test cases are derived from a test ideas list.</li><li>A key question for the tester or test analyst is which ones are the ones worth trying.</li></ul></li><li><h1 id="Where-Do-Test-Ideas-Come-From"><a href="#Where-Do-Test-Ideas-Come-From" class="headerlink" title="Where Do Test Ideas Come From?"></a><strong>Where Do Test Ideas Come From?</strong></h1><ul><li>Models</li><li>Specifications</li><li>Customer complaints</li><li>Brainstorm sessions among colleagues</li><li>Bug lists</li><li>Representative exemplars</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2-Software Quality</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/2-Software%20Quality/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/2-Software%20Quality/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Introduce software quality</li><li>Provide stakeholder-centric visions of quality and defect</li><li>Identify software quality assurance<a id="more"></a><br></li></ul></li><li><h1 id="Define-quality"><a href="#Define-quality" class="headerlink" title="Define quality"></a><strong>Define quality</strong></h1><ul><li><strong>Fitness for use –Dr. Joseph M. Juran</strong></li><li>The totality of features and characteristics of a product that bear on its ability to satisfy a given need –American Society for Quality</li><li>Conformance with requirements –Philip Crosby</li><li>conforms to specifications</li><li><strong>Quality is value to some person.</strong>– Gerald M. Weinberg<br><br></li></ul></li><li><h1 id="key-dimensions-of-quality"><a href="#key-dimensions-of-quality" class="headerlink" title="key dimensions of quality"></a><strong>key dimensions of quality</strong></h1><ul><li>Customer Satisfiers<ul><li>the right features</li><li>adequate instruction</li></ul></li><li>Customer Dissatisfiers<ul><li>unreliable</li><li>hard to use</li><li>too slow</li><li>incompatible with the customer’s equipment<br><br></li></ul></li></ul></li><li><h1 id="Dimensions-of-Quality-FURPS"><a href="#Dimensions-of-Quality-FURPS" class="headerlink" title="Dimensions of Quality: FURPS"></a><strong>Dimensions of Quality: FURPS</strong></h1><ul><li>Functionality<ul><li>Test the accurate workings of each usage scenario</li></ul></li><li>Usability<ul><li>Test application from the perspective of convenience to end-user.</li></ul></li><li>Reliability<ul><li>Test the application behaves consistently and predictably.</li></ul></li><li>Performance<ul><li>Test online response under average and peak loading</li></ul></li><li>Supportability<ul><li>Test the ability to maintain and support application under production use<br><br></li></ul></li></ul></li><li><h1 id="A-Broader-Definition-of-Dimensions-of-Quality"><a href="#A-Broader-Definition-of-Dimensions-of-Quality" class="headerlink" title="A Broader Definition of Dimensions of Quality"></a><strong>A Broader Definition of Dimensions of Quality</strong></h1><ul><li>Accessibility Capability Compatibility Concurrency Conformance to standards Efficiency Installability and uninstallability Localizability Maintainability Performance Portability Reliability Scalability Security Supportability Testability Usability……<br><br></li></ul></li><li><h1 id="Definition-of-SQA"><a href="#Definition-of-SQA" class="headerlink" title="Definition of SQA"></a><strong>Definition of SQA</strong></h1><ul><li>Software quality assurance (SQA) is:A systematic, planned set of actions necessary to provide adequate confidence that the software development process or the maintenance process of a software system product conforms to established functional and technical requirements as well as with the managerial requirements of keeping the schedule and operating within the budgetary confines.</li><li>系统的，有计划的一系列行动，以充分确信软件开发过程或软件系统产品的维护过程符合既定的功能和技术要求，以及在预算范围内保持计划和操作的管理要求。<br><br>     </li></ul></li><li><h1 id="SQA-system-component-classes"><a href="#SQA-system-component-classes" class="headerlink" title="SQA system component classes"></a><strong>SQA system component classes</strong></h1><ol><li>Pre-project quality components</li><li>Project life cycle quality components</li><li>Infrastructure error preventive and improvement components</li><li>Software quality management components</li><li>Standardization, certification and SQA assessment components</li><li>Organizing for SQA – the human components</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1-Software Engineering Practices</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/1-Software%20Engineering%20Practices/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/1-Software%20Engineering%20Practices/</url>
      
        <content type="html"><![CDATA[<p><code>Some things Testers should know about them</code></p><ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Identify some common software development problems.</li><li>Identify six software engineering practices for addressing common software development problems</li></ul></li></ul><a id="more"></a><h2 id="常见的软件开发问题症状"><a href="#常见的软件开发问题症状" class="headerlink" title="常见的软件开发问题症状"></a>常见的软件开发问题症状</h2><ul><li>User or business needs not met</li><li>Requirements churn</li><li>Modules don’t integrate</li><li>Hard to maintain</li><li>Late discovery of flaws</li><li>Poor quality or poor user experience</li><li>Poor performance under load</li><li>No coordinated team effort</li><li>Build-and-release issues</li></ul><h2 id="六种软件工程实践"><a href="#六种软件工程实践" class="headerlink" title="六种软件工程实践"></a>六种软件工程实践</h2><p><strong>Develop Iteratively</strong><br><strong>Manage Requirements</strong><br><strong>Use Component Architectures</strong><br><strong>Model Visually (UML)</strong><br><strong>Continuously Verify Quality</strong><br><strong>Manage Change</strong></p><ol><li><p>Develop Iteratively </p><ul><li>瀑布模型特点</li><li>Delays confirmation of critical risk resolution</li><li>Measures progress by assessing work-products that are poor predictors of time-to-completion</li><li>Delays and aggregates integration and testing</li><li>Precludes early deployment</li><li>Frequently results in major unplanned project extensions</li></ul><ul><li>迭代模型特点<br><img src="/img/soa/iterative.png" alt=""></li><li>最早的迭代可以解决最大的风险.每次迭代都会生成可执行版本.</li><li>每次迭代都包括集成和测试。<br><strong>迭代有助于:</strong></li></ul><ul><li>在进行大量投资之前解决重大风险</li><li>实现早期客观反馈</li><li>使测试和集成持续进行</li><li>将项目重点放在可实现的短期目标里程碑上</li><li>可以部署完成的最终系统的部分实现<br><img src="/img/soa/riskprofiles.png" alt="Rick Profiles"></li></ul></li></ol><ol start="2"><li>Manage Requirements<br> <img src="/img/soa/map.png" alt=""><ul><li>为了帮助管理需求与从这些需求派生的测试之间的关系，您可以在这些元素之间建立可跟踪性关系.<br><strong>可追溯性有助于我们做很多事情，包括：</strong></li><li>评估项目对需求变更的影响</li><li>评估测试失败对需求的影响（如果测试失败，可能不满足要求）</li><li>验证应用程序是否仅执行预期的操作</li><li>验证实施是否满足系统的所有要求</li><li>管理项目范围</li><li>管理变更</li></ul></li></ol><ol start="3"><li>Component-Based Architecture<ul><li>弹性<ul><li>满足当前和未来的要求</li><li>提高可扩展性</li><li>允许重用</li><li>封装系统依赖性</li></ul></li><li>基于组件<ul><li>重用或自定义组件</li><li>从市售组件中选择</li><li>逐步发展现有软件</li></ul></li></ul></li></ol><ol start="4"><li>Model Visually (UML)<br>详情见软件分析与设计课程总结</li></ol><ol start="5"><li>Continuously Verify Quality<br>详情见软件分析与设计课程总结</li></ol><ol start="6"><li>Manage Change<ul><li>Changes to enable iterative development<ul><li>Secure workspaces for each worker</li><li>Parallel development possible</li></ul></li><li>Automated integration/build management</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vi常见命令</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Vi%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Vi%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/vi/vi.png" alt="常用命令"><br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux简介</title>
      <link href="/2018/12/07/Linux/Class%20Notes/linux%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/12/07/Linux/Class%20Notes/linux%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="man"><a href="#man" class="headerlink" title="man"></a>man</h1><p>man （/usr/share/man）<br><a id="more"></a><br>如果输入命令 man 后英语手册页没有自动显示，则您可以使用参数LANG=en_EN来显示英语版本的手册页。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; LANG=en_EN man man</span><br></pre></td></tr></table></figure></p><p>给出关于man的具体描述，包括以下几个部分其中每个手册页标题的左右侧是命令名和手册页所属的章节号。标题的中间是章节的名称。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME          命令的名称和简短描述</span><br><span class="line">SYNOPSIS      语法的描述</span><br><span class="line">DESCRIPTION   命令的详细描述</span><br><span class="line">OPTIONS       提供的所有可用选项的描述</span><br><span class="line">COMMANDS      在程序运行时可以分配给该程序的说明</span><br><span class="line">FILES         使用某种方法连接到命令的文件</span><br><span class="line">SEE ALSO      相关命令的提示</span><br><span class="line">DIAGNOSTICS   程序可能出现的错误消息</span><br><span class="line">EXAMPLE       调用命令的示例</span><br><span class="line">BUGS          命令的已知错误和问题</span><br></pre></td></tr></table></figure><p>手册页可以分为以下不同的小节</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 可执行程序和 shell 命令（用户命令）</span><br><span class="line">2 系统调用</span><br><span class="line">3 功能和库例程</span><br><span class="line">4 设备文件</span><br><span class="line">5 配置文件和文件格式</span><br><span class="line">6 游戏</span><br><span class="line">7 宏软件包和文件格式</span><br><span class="line">8 系统管理命令</span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;man 1 crontab</span><br><span class="line">&gt;man 5 crontab</span><br></pre></td></tr></table></figure></p><p>使用命令 whatis 显示某个命令或实用程序的所有可用手册页的简短描述<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;whatis crontab</span><br></pre></td></tr></table></figure></p><h1 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h1><p>/usr/share/info/<br>Info工具是一个基于菜单的超文本系统，由GNU项目开发并由Linux发布。info工具包括一些关于Linux shell、工具、GNU项目开发程序的说明文档。与man相比，info工具可显示更完整的最新的GNU工具信息<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;info ls</span><br></pre></td></tr></table></figure></p><h1 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h1><p>“–help”是一个工具选项<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ls --help</span><br></pre></td></tr></table></figure></p><h1 id="Howto文档"><a href="#Howto文档" class="headerlink" title="Howto文档"></a>Howto文档</h1><p>/usr/share/doc/howto<br>or <a href="http://www.tldp.org/index.html" target="_blank" rel="noopener">http://www.tldp.org/index.html</a></p><h1 id="在线文档"><a href="#在线文档" class="headerlink" title="在线文档"></a>在线文档</h1><p>一些在线信息<br><a href="http://www.tldp.org" target="_blank" rel="noopener">http://www.tldp.org</a><br><a href="http://www.linux.org" target="_blank" rel="noopener">http://www.linux.org</a><br><a href="http://www.redhat.com" target="_blank" rel="noopener">http://www.redhat.com</a><br><a href="http://www.suse.com" target="_blank" rel="noopener">http://www.suse.com</a><br><a href="http://www.xfree86.org" target="_blank" rel="noopener">http://www.xfree86.org</a><br><a href="http://www.linuxplanet.com" target="_blank" rel="noopener">http://www.linuxplanet.com</a><br><a href="http://www.cert.org" target="_blank" rel="noopener">http://www.cert.org</a><br><a href="http://www.securityfocus.com" target="_blank" rel="noopener">http://www.securityfocus.com</a><br><a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a><br><a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><p>在以下目录中提供了大多数已安装软件包包的帮助文件：<br>/usr/share/doc/packages/package-name</p><h2 id="ls-l-查看文件的属性"><a href="#ls-l-查看文件的属性" class="headerlink" title="ls -l 查看文件的属性"></a>ls -l 查看文件的属性</h2><p>普通文件          -rw-r–r–<br>目录文件          drwxr-xr-x<br>字符设备文件      crw-rw-rw-<br>块设备文件        brw-r—–<br>套接字文件        srwxrwxrwx<br>链接文件          lrwxrwxr—<br>FIFO文件          prwxr—r– </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux网络服务</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>NTP(network time protocol)</li><li>Linux打印服务<a id="more"></a><br></li></ul></li><li><h1 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a><strong>NTP</strong></h1><ul><li>ntp通过与时间服务器同步使本机时间与UTC(世界协调时间）同步</li><li>UTC也称为GMT（格林尼治时间）</li><li>本地时间</li><li>/etc/sysconfig/clock<ul><li>ZONE</li><li>UTC</li></ul></li><li>Linux 系统中有 2 个主要的时钟：</li><li>硬件时钟。这是一个独立于 CPU 中运行的所有控制程序而运行的时钟。也称为时间时钟、RTC、BIOS 时钟或 CMOS 时钟。</li><li>系统时间。这是 Linux 内核内部时钟的时间，并且由计时器中断驱动。</li><li>当 Linux 第一次启动时，系统时间与硬件时钟同步。之后， Linux 只使用系统时间。</li><li>date</li><li>xntp 通过提供以下服务解决同步问题：</li><li>xntp 定期根据收集到的更正数据更正本地计算机时钟。</li><li>xntp 会随时借助网络中的时间服务器更正本地时间。</li><li>xntp 支持对本地参考时钟（如无线电控制的时钟）进行管理。<br><br></li></ul></li><li><h1 id="Linux打印服务"><a href="#Linux打印服务" class="headerlink" title="Linux打印服务"></a><strong>Linux打印服务</strong></h1><ul><li>CUPS (Common Unix Printing System )<ul><li>是行式打印机守护程序Line Print Daemon (LPD)的后继，在redhat中仍使用部分LPD命令进行打印机调整与监视。</li></ul></li><li>LPD （行式打印机守护程序）<ul><li>在发送实际打印数据之前，将先发送一些与作业相关的数据，例如打印机队列。LPD 服务的端口号是 515</li></ul></li><li>IPP （因特网打印协议） <ul><li>是一个基于HTTP 协议的相对较新的（自 1999）协议。使用 IPP，所传送的与作业有关的数据比其他协议要多得多。CUPS 使用 IPP 进行内部数据传送。这是在 CUPS 服务器之间转发队列的首选协议。IPP 的端口号是 631</li></ul></li><li>SMB （服务讯息块）。CUPS 还支持在连接到 Windows 共享的打印机上进行打印，SMB 使用端口号 137、138 和 139</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>学用linux</title>
      <link href="/2018/12/07/Linux/Class%20Notes/%E5%AD%A6%E7%94%A8linux/"/>
      <url>/2018/12/07/Linux/Class%20Notes/%E5%AD%A6%E7%94%A8linux/</url>
      
        <content type="html"><![CDATA[<h1 id="文件查找-find"><a href="#文件查找-find" class="headerlink" title="文件查找 find"></a>文件查找 find</h1><p>find 在命令行上搜索文件<br><a id="more"></a><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;find path criterion action</span><br></pre></td></tr></table></figure></p><p><strong>path</strong>：要搜索的文件系统部分（指定的目录及其所有子目录）。如果什么也没指定，则将使用当前目录下的文件系统。<br><strong>criterion</strong>：文件应该具有的属性：<br>-name pattern 搜索名称中包含给定模式的文件。如果模式中包含元字符或通配符，则必须用引号将它括起。否则，它将由 shell 解释，而不是由 find 解释。<br>-type file_type 搜索文件类型。适用的文件类型如下：“d”（用于目录）、“f”（用于文件）或者“l”（用于符号链接）。<br>-ctime [+/-]days 搜索恰好在指定的几天前进行上一次修改的那些文件。<br><strong>action</strong>:影响以下条件或将搜索作为一个整体进行控制的选项，例如：<br> -print<br> -exec command  可使用选项 -exec 调用其他命令<br> <em>例子</em><br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;find ~ -name kk* -type f –exec grep first &#123;&#125; \; -print</span><br></pre></td></tr></table></figure></p><p> {} 这两个括号代表找到的并传递到命令 grep 的文件名的占位符。分号用于结束 -exec指令。由于它是特殊字符，所以在它前面放一个反斜杠，以此来标记它。</p><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p> locate 是 find -name 的替代命令（必须装有软件包 findutils-locate）。首次使用要用updatedb生成/更新数据库。</p><h1 id="查找命令所在目录whereis"><a href="#查找命令所在目录whereis" class="headerlink" title="查找命令所在目录whereis"></a>查找命令所在目录whereis</h1><p> 命令 whereis 将返回二进制（选项 -b）、手册页（选项 -m）和指定命令的源代码（选项 -s）。该命令的速度比 find 快，但不如 find 全面。<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;whereis -b ls</span><br><span class="line">&gt;whereis -m ls</span><br><span class="line">&gt;whereis -s ls</span><br></pre></td></tr></table></figure></p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p> which 将搜索在变量 PATH 中为指定命令列出的所有路径，并返回该命令的完整路径。命令 which 特别适用于以下情况：不同目录中存在某个命令的几个版本，并且您想知道在未指定路径的情况下输入时将执行哪个版本。<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;which find</span><br></pre></td></tr></table></figure></p><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>命令 type command 可用来查找在输入 command 时执行哪类命令，是 shell 内置命令还是外部命令。选项 -a 在文件系统中传递采用该名称的命令的所有实例。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;type type</span><br><span class="line">&gt;type grep</span><br></pre></td></tr></table></figure></p><h1 id="搜索文件内容-grep"><a href="#搜索文件内容-grep" class="headerlink" title="搜索文件内容 grep"></a>搜索文件内容 grep</h1><p>当需要查找包含特殊词、短语或项的所有文件，并且是扫描所有文件而不在编辑器中打开它们时<br><strong>&gt;grep search_pattern filename</strong><br>该命令将在文件名中进行搜索以寻找与 search_pattern 匹配的所有文本，并打印包含该模式的行。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 grep 的可用选项如下：</span><br><span class="line">    -i 忽略大小写。</span><br><span class="line">    -l 仅显示包含搜索字符串的文件的名称。</span><br><span class="line">    -r 递归地搜索整个目录树。</span><br><span class="line">    -v 给定不包含搜索字符串的所有行。</span><br><span class="line">    -n 显示行号。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;grep test  d* </span><br><span class="line">//显示所有以d开头的文件中包含test的行</span><br><span class="line">&gt;grep -n test aa bb cc</span><br><span class="line">//显示在aa，bb，cc文件中匹配test的行。</span><br></pre></td></tr></table></figure><h1 id="安装RPM包"><a href="#安装RPM包" class="headerlink" title="安装RPM包"></a>安装RPM包</h1><p>用rpm安装软件的命令格式如下：<br><strong> rpm  -i  [安装选项]  rpm 软件包名 </strong><br>安装选项有很多，常用的如下：<br>   -vh ：显示安装过程中的详细信息；<br>   –percent：显示安装进度的百分比；<br>   –test：不进行安装软件包，只进行安装测试并显示简单的报告；<br>   –force：忽略任何错误，强制安装软件包。</p><h1 id="更新、卸载RPM包"><a href="#更新、卸载RPM包" class="headerlink" title="更新、卸载RPM包"></a>更新、卸载RPM包</h1><p><strong> rpm  -u  rpm软件包名 </strong><br><strong> rpm  -e  rpm软件包名 </strong></p><p>查询已安装的包版本<br>rpm –qa |grep  软件包名</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux网络服务-Internet服务</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%20%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1-%20Internet%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%20%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1-%20Internet%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Xinetd</li><li>Ftp</li><li>Http</li><li>SSH<a id="more"></a><br></li></ul></li><li><h1 id="Xinetd-Extended-Internet-Daemon"><a href="#Xinetd-Extended-Internet-Daemon" class="headerlink" title="Xinetd (Extended Internet Daemon)"></a><strong>Xinetd (Extended Internet Daemon)</strong></h1><ul><li>守护进程Daemon</li><li>运行在后台的一种特殊程序，独立于控制终端执行某种任务或者等待处理某些发生的事件，如smbd，named等</li><li>Linux的大多数服务是用守护程序实现的，守护程序打开一个端口并且监听该端口，等待客户机的连接。一旦客户机提交了连接请求，守护程序就创建一个子进程来响应，而父进程继续监听更多的服务请求。因此每个守护程序可以处理多个客户服务的请求。</li><li>服务器上的许多服务都是通过超级守护程序包 inetd 或 xinetd 来管理和启动的。</li><li>超级守护程序充当一组服务发出连接请求时的中介者。它直接接受连接请求、启动所需的服务并将请求传递到新启动的服务器。如果客户机和服务器之间的连接终止，则由  xinetd 启动的服务器将从内存中删除。</li><li>通过 inetd 启动服务既有优点也有缺点。最大的优点就是节省资源（尤其是内存），因为服务器仅在需要时才启动。但是，缺点是在装载、启动和连接所需服务时将发生延迟。</li><li>守护程序的运行方式<ul><li>独立运行的守护程序</li><li>由init脚本管理</li><li>其脚本存放在/etc/rc.d/init.d/目录下</li></ul></li><li>由Xinetd运行的守护程序<ul><li>由xinetd管理启动</li><li>服务的配置文件存放在/etc/xinetd.d/目录下</li></ul></li><li>可用pstree查看当前进程树<br><br></li></ul></li><li><h1 id="Xinetd特点"><a href="#Xinetd特点" class="headerlink" title="Xinetd特点"></a><strong>Xinetd特点</strong></h1><ul><li>强大的访问控制功能：提供对用户的审查和权限控制、限制连接数目、设定特定的连接时间</li><li>强大的日志功能：可以为每一个服务设置日志等级：为每个服务设置日志文件；记录起止时间；记录非法访问请求</li><li>专项功能：可以将客户端的请求交到另外的主机去处理</li><li>与客户端的交互功能<br><br></li></ul></li><li><h1 id="配置Xinetd"><a href="#配置Xinetd" class="headerlink" title="配置Xinetd"></a><strong>配置Xinetd</strong></h1><ul><li><strong>配置文件 /etc/xinetd.conf</strong><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认配置参数</span><br><span class="line"> defaults    为所有的服务指定缺省值</span><br><span class="line"> &#123;</span><br><span class="line">     key operator parameter parameter. . .</span><br><span class="line">     instances ＝ 60</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>includedir /etc/xinetd.d  //指明配置文件目录<br>将提示 xinetd 解释目录/etc/xinetd.d/ 中的所有文件以配置服务</p><ul><li><p><strong>配置其网络服务</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  service service_name</span><br><span class="line">  &#123;</span><br><span class="line">    key operator parameter parameter. . .</span><br><span class="line">   &#125;</span><br><span class="line">运算符有 =、-= 和 +=</span><br><span class="line">  可在目录 /etc/xinetd.d/ 中为每个服务创建一个单独的配置文件</span><br></pre></td></tr></table></figure></li><li><p><strong>例子</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service telnet&#123;</span><br><span class="line">  socket_type = stream</span><br><span class="line">  wait = no</span><br><span class="line">  user = root</span><br><span class="line">  server = /usr/sbin/in.telnetd</span><br><span class="line">  disable = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux用户用户组和文件权限</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android案例-弹出菜单</title>
      <link href="/2018/11/04/Android/Android%E6%A1%88%E4%BE%8B-%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/"/>
      <url>/2018/11/04/Android/Android%E6%A1%88%E4%BE%8B-%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java hljs"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMenu</span><span class="hljs-params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 获取自定义的菜单布局文件</span></span><br><span class="line">        View popupWindow_view = getLayoutInflater().inflate(R.layout.menu, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>);</span><br><span class="line">        <span class="hljs-comment">// 创建PopupWindow实例,设置菜单宽度和高度为包裹其自身内容</span></span><br><span class="line">        popupWindow = <span class="hljs-keyword">new</span> PopupWindow(popupWindow_view, ActionBar.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                ActionBar.LayoutParams.WRAP_CONTENT, <span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-comment">//设置菜单显示在按钮的下面</span></span><br><span class="line">        popupWindow.showAsDropDown(findViewById(R.id.btn_menu),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-comment">// 点击其他地方消失</span></span><br></pre></td></tr></table></figure><p> menu.xml为弹出菜单</p> <a id="more"></a><a href="https://developer.android.com/reference/android/widget/PopupWindow" target="_blank" rel="noopener">文档</a><p>public class PopupWindow extends Object<br>java.lang.Object<br>   ↳    android.widget.PopupWindow</p><p>该类表示可用于显示任意视图的弹出窗口。弹出窗口是出现在当前活动顶部的浮动容器。<br>This class represents a popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity.</p><h2 id="Public-constructors"><a href="#Public-constructors" class="headerlink" title="Public constructors"></a>Public constructors</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow (View   contentView, </span><br><span class="line">                    int     width, </span><br><span class="line">                    int     height, </span><br><span class="line">                    boolean focusable)</span><br></pre></td></tr></table></figure><p> Create a new popup window which can display the contentView. The dimension of the window must be passed to this constructor.The popup does not provide any background. This should be handled by the content view. </p><p><strong>contentView</strong>:the popup’s content<br><strong>width</strong>      :the popup’s width<br><strong>height</strong>     :the popup’s height<br><strong>focusable</strong>  :true if the popup can be focused, false otherwise</p><h2 id="Public-methods"><a href="#Public-methods" class="headerlink" title="Public methods"></a>Public methods</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void showAsDropDown (View  anchor,</span><br><span class="line">                            int   xoff,</span><br><span class="line">                            int   yoff,</span><br><span class="line">                            int   gravity)</span><br></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p><strong>anchor</strong>:the view on which to pin the popup window<br><strong>xoff</strong>:A horizontal offset from the anchor in pixels<br><strong>yoff</strong>:A vertical offset from the anchor in pixels<br><strong>gravity</strong>: Alignment of the popup relative to the anchor</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml resource.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, ViewGroup root)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml node.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified XML node.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml resource.</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
  
</search>
