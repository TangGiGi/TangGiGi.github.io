<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机组期末总结</title>
      <link href="/2018/12/24/Computer%20Organization%20&amp;%20Architecture/summary/"/>
      <url>/2018/12/24/Computer%20Organization%20&amp;%20Architecture/summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Organization-amp-Architecture"><a href="#Organization-amp-Architecture" class="headerlink" title="Organization &amp; Architecture"></a>Organization &amp; Architecture</h1><ul><li><p>Computer architecture</p><ul><li>允许我们使用制造技术<em>有效地</em>实现信息处理应用程序的 <strong>抽象层的设计</strong></li><li>对程序员可见</li><li>直接影响程序的逻辑执行</li><li>概念结构和功能特征</li></ul></li><li><p>Computer Organization</p><ul><li>体系结构中指定的 <em>实现</em> 和 <em>互连</em> 的操作单元（or 组件）</li><li>系统设计者可见</li><li>架构的的一种实现<a id="more"></a><img src="\img\COA\期末总结\1.png" alt=""></li></ul></li></ul><h1 id="计算机顶级视图"><a href="#计算机顶级视图" class="headerlink" title="计算机顶级视图"></a>计算机顶级视图</h1><ul><li><p>von Neuman architecture 3个重要概念</p><ul><li>Data and instruction are stored in a single read-write memory</li><li>The contents of the memory are addressed by location</li><li>Execution occurs in a sequential fashion </li></ul></li><li><p>指令周期</p><ul><li>取指周期<ul><li>处理器取指 From Memory Located by PC</li><li>PC++</li><li>指令-&gt; Instruction Register</li><li>处理器对指令译码并执行所需的操作</li></ul></li><li>执行周期<ul><li>CPU与主存 进行数据交换</li><li>CPU与IO模块 进行数据交换</li><li><strong>数据处理</strong></li><li>控制(jump等)</li><li>或以上组合</li></ul></li></ul></li></ul><p></p><p id="p1"></p><ul><li><p>指令的流程</p><ul><li>指令地址计算</li><li>取指</li><li>指令译码</li><li>||:操作数地址计算</li><li>取操作数:||</li><li>数据操作</li><li>||:操作数地址计算</li><li>存操作数:||</li><li>检查中断</li><li>有则执行中断<br>||:反复的意思:||</li></ul></li><li><p>中断</p><ul><li>允许其他模块中断CPU执行顺序的机制</li><li>提高CPU的实用性</li><li>允许CPU处理紧急事件</li><li>包括 程序中断 Timer中断 IO中断 硬件失效中断</li></ul></li><li><p>Multiple Interrupts</p><ul><li>中断被中断了</li><li>怎么办呢<ul><li>不管新中断</li><li>定义优先级</li></ul></li></ul></li></ul><p>Interconnection structures:The collection of paths connecting of {主存,IO模块,CPU}</p><p>总线:communication paths connecting two or more components</p><ul><li><p>系统总线</p><ul><li>数据总线<ul><li>数据总线带宽=机器字长=寄存器长</li></ul></li><li>地址总线<ul><li>带宽决定有多少memory</li></ul></li><li>控制总线</li></ul></li><li><p>总线仲裁</p><ul><li>不止一个模块连着总线,但一次只能有一个模块控制着</li><li>集中式仲裁:有个控制器决定哪个模块占用总线</li><li>Daisy chain polling<ul><li><img src="\img\COA\期末总结\2.png" alt=""></li><li>优:可扩展性好</li><li>缺:电路故障敏感</li></ul></li><li>Counter timing polling<ul><li><img src="\img\COA\期末总结\3.png" alt=""></li><li>优:灵活优先 电路故障不敏感</li><li>缺:控制复杂</li></ul></li><li>Separate request<ul><li><img src="\img\COA\期末总结\4.png" alt=""></li><li>优:反应快 灵活优先</li><li>缺:控制复制 线太多</li></ul></li><li>分布式仲裁:没有控制器决定,每个模块都包含对总线的访问控制逻辑</li></ul></li><li><p>总线的通讯控制模块</p><ul><li>通讯控制:解决如何开始和结束传输,如何协调主从模块</li></ul></li></ul><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p>Why Cache?局部性原理.</p><p><img src="\img\COA\期末总结\5.png" alt="Cache Read Operation"></p><ul><li>直接映射<br><img src="\img\COA\期末总结\6.png" alt=""></li></ul><blockquote><p>i =  j mod m</p></blockquote><p>i是cache行<br>j是主存块号<br>m是cache总行<br><img src="\img\COA\期末总结\7.png" alt=""></p><ul><li>关联映射</li><li>组关联映射</li></ul><h1 id="Internal-Memory"><a href="#Internal-Memory" class="headerlink" title="Internal Memory"></a>Internal Memory</h1><ul><li>RAM<br>random-access memory</li><li>Dynamic RAM<ul><li>bits 存在电容器中</li><li>通电时也要刷新</li><li>结构简单 便宜 功耗低</li><li>慢</li><li><img src="\img\COA\期末总结\8.png" alt="Dynamic RAM Structure"></li><li>写</li><li>Bit line 给电压 高 1 低 0</li><li>电荷传给电容器</li><li>读</li><li>Address line 选中</li><li>电荷从电容器-&gt;bit line-&gt;放大器 比较 0 或 1</li><li>电容器必须回写</li></ul></li><li>Static RAM<ul><li><img src="\img\COA\期末总结\9.png" alt="Stating RAM Structure"></li><li>晶体管布置提供了稳定的逻辑状态</li><li>state 1</li><li>C1 high, C2 low</li><li>T1 T4 off, T2 T3 on</li><li>state 0</li><li>C2 high, C1 low</li><li>T2 T3 off, T1 T4 on</li><li>T5 T6是开关</li></ul></li><li>DRAM SRAM 两者对比<ul><li>都不稳定 需要充电才能存数据</li><li>DRAM:容易实现 小 更密集 便宜 需要刷新 容量更大</li><li>SRAM:快 当cache</li></ul></li><li>ROM<ul><li>永久存储</li><li>只读 不可写</li><li>只要有一位错了 整个芯片用不了了</li><li>应用:微程序 库子程序 BIOS</li></ul></li><li>PROM<ul><li>可编程的ROM</li><li>编写需要特殊设备</li><li>灵活 便捷</li></ul></li></ul><h1 id="External-Memory"><a href="#External-Memory" class="headerlink" title="External Memory"></a>External Memory</h1><p><img src="\img\COA\期末总结\10.png" alt="Disk Data Layout"><br><img src="\img\COA\期末总结\11.png" alt="Disk Layout Methods"></p><ul><li>如何找到扇区呢?<ul><li>通过格式化磁盘将额外数据（控制数据）放入扇区</li><li>标记轨道和扇区<br><img src="\img\COA\期末总结\12.png" alt="Organization of Disk System"><br><img src="\img\COA\期末总结\13.png" alt="Timing of a disk I/O"><br>等待IO设备和等待IO通道的时间是不确定的.</li></ul></li><li>寻道时间 seek time<ul><li>找到相关数据的轨道头</li><li>时间不确定(启动磁头臂的时间 加速和遍历轨道的时间)</li><li>估算公式: T= S + n * M</li><li>S 开始时间 n 遍历轨道 m 与磁盘驱动相关的常数</li></ul></li><li>旋转延迟 Rotational delay<ul><li>一般取平均延迟</li></ul></li><li>传输时间 Transfer time<ul><li>①需要传输的字节数 ② 旋转速度</li><li>T = b/(rN)</li><li>b 要传输的字节数 N 轨道上的字节数 r 旋转速度 rpm/60</li></ul></li><li><p>访问时间 access time</p><ul><li>上三者相加</li></ul></li><li><p>RAID</p><ul><li>Redundant Array of Independent Disks</li><li>通过OS将一组物理磁盘视为单个逻辑驱动器</li><li>跨物理驱动器分布的数据</li><li>可以使用冗余容量来存储奇偶校验信息</li></ul></li><li><p>RAID 0</p><ul><li>无冗余</li><li>数据条跨所有磁盘</li><li>提升速度:多个数据请求可能不在同一磁盘上.磁盘并行寻求.一组数据可能跨多个磁盘进行条带化</li><li>应用:高数据传输能力.高IO请求<br><img src="\img\COA\期末总结\14.png" alt=""><br><img src="\img\COA\期末总结\15.png" alt=""></li></ul></li><li><p>RAID 1</p><ul><li>数据条跨磁盘</li><li>每个磁盘条2个副本位于不同的磁盘上</li><li>读1 写2</li><li>恢复简单,容错性好.如果读取请求率高,则其性能是RAID0的两倍</li><li>贵</li><li>应用:存储系统软件或数据非常重要的文件<br><img src="\img\COA\期末总结\16.png" alt=""></li></ul></li><li><p>RAID 2</p><ul><li>未实现</li><li>所有磁盘是同步的,任何时候磁头位于所有磁盘的相同位置</li><li>非常小的磁盘条,单个字节或字</li><li>并行访问数据和奇偶校验</li><li>非常多冗余<br><img src="\img\COA\期末总结\17.png" alt=""></li></ul></li><li><p>RAID 3</p><ul><li>与RAID2 相似</li><li>只有一个冗余磁盘.</li><li>可以从幸存的数据和奇偶校验信息重建有关故障驱动器的数据</li><li>very high transfer rates</li><li>一次只能执行一个IO请求</li></ul></li></ul><p>例:5个磁盘阵列,X0~X3表示数据,X4表示奇偶校验.X4（i）= X3（i）⊕X2（i）⊕X1（i）⊕X0（i）如果X0损坏,则上述等式异或两侧X4（i）⊕X0（i）<br>X0（i）= X4（i）⊕X3（i）⊕X2（i）⊕X1（i）<br><img src="\img\COA\期末总结\18.png" alt=""></p><ul><li><p>RAID 4</p><ul><li>与RAID2 类似 但是磁盘条更大</li><li>每个磁盘独立运行</li><li>适用于高IO请求</li><li>Bit by bit parity calculated across stripes on each disk</li><li>奇偶校验存储在奇偶校验磁盘上</li><li><img src="\img\COA\期末总结\19.png" alt=""></li><li><img src="\img\COA\期末总结\20.png" alt=""></li><li>磁盘条上1次写请求则最少需要2次读2次写操作</li><li>奇偶校验磁盘成为瓶颈</li></ul></li><li><p>RAID 5</p><ul><li>与RAID4 类似</li><li>常用于网络服务器</li><li><img src="\img\COA\期末总结\21.png" alt=""></li></ul></li><li><p>RAID 6</p><ul><li>两种不同的奇偶校验计算,存储在不同磁盘上的单独条带中</li><li>极高的数据可用性,即使两个条带发生故障也可以恢复</li><li>写惩罚</li><li><img src="\img\COA\期末总结\22.png" alt=""></li></ul></li></ul><h1 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h1><ul><li>Why IO模块?<ul><li>种类繁多的外围设备<ul><li>提供不同数量的数据</li><li>以不同的速度</li><li>根据不同的时序</li><li>以不同的格式</li></ul></li><li>都慢于CPU和RAM</li><li>外围设备不直接连接到系统总线</li><li>需要IO模块计算机</li></ul></li></ul><p><img src="\img\COA\期末总结\23.png" alt="Generic Model of I/O Modular"><br><img src="\img\COA\期末总结\24.png" alt="External Device Block Diagram"></p><ul><li><p>磁盘驱动</p><ul><li>一种是与IO模块进行数据 控制 和状态信号交换</li><li>另一种是用于控制磁盘读写机制</li></ul></li><li><p>IO模块的功能</p><ul><li>控制和计时</li><li>CPU  ~ IO 通信</li><li>设备 ~ IO 通信</li><li>内存 ~ IO 通信</li><li>数据缓冲</li><li>错误检测</li></ul></li><li><p>IO steps</p><ul><li>CPU检查IO模块和设备状态</li><li>IO模块返回状态</li><li>如果准备好,CPU请求数据传输</li><li>IO模块从设备获取数据</li><li>IO模块将数据传输到CPU</li></ul></li><li><p>IO Communication</p><ul><li>命令解码：<ul><li>读取扇区 搜索轨道 扫描ID</li><li>可以读取或写入哪些块。</li></ul></li><li>数据交换<ul><li>外部数据 -&gt; IO模块buffer By 本地总线</li><li>IO模块buffer -&gt; CPU/内存 By 系统总线</li></ul></li><li>状态报告<ul><li>busy ready error etc.</li></ul></li><li>地址识别<ul><li>识别每个外围设备</li></ul></li></ul></li><li><p>数据缓冲 Data Buffering</p><ul><li>使外围设备适应CPU/主存的速度</li><li>CPU/DRAM <--> IO buffer</--></li><li>IO buffer <--> 外围设备</--></li></ul></li><li><p>错误检测 Error Detection</p><ul><li>IO模块通常负责错误检测并向CPU报告错误</li><li>硬件故障:卡纸 坏的磁盘轨道</li><li>传输错误:bit错误 数据丢失 …</li></ul></li></ul><p><img src="\img\COA\期末总结\25.png" alt="IO Module Structure"></p><ul><li><p>输入输出模式</p><ul><li>Programmed IO</li><li>中断驱动IO</li><li>直接内存访问（DMA）</li><li>IO通道</li><li>IO处理器</li></ul></li><li><p>Programmed IO和中断驱动IO的缺点</p><ul><li>Programmed IO需要占用所有CPU时间</li><li>中断驱动的IO仍需要主动CPU干预,但CPU使用率比Programmed IO更高（传输速率更低）</li><li>在这两种模式下,数据传输必须遍历CPU<ul><li>转移率有限</li><li>CPU被捆绑了</li></ul></li><li>传输大量数据时,DMA是一种更有效的技术</li></ul></li><li><p>DMA</p><ul><li>在CPU外部</li><li>总线上的附加模块（硬件）</li><li>DMA控制器从CPU接管IO.</li><li>无需CPU干预即可将数据块传输到内存或从内存传输</li><li>实际上,DMA也是一个IO模块</li><li>Act as a maser on the bus</li><li>Memory system acts like slave</li><li>管理字节-字转换</li><li>优先级：DMA &gt; CPU</li></ul></li><li><p>CPU和DMA之间的三种数据传输模式：</p><ul><li>块传输模式（垄断模式）<ul><li>整个数据块以一个连续的顺序传输</li><li>如果DMA传输数据,CPU将被禁用一段时间,直到DMA释放总线</li><li>用于将程序或数据文件加载到内存中</li></ul></li><li>Cycle stealing mode<ul><li>DMA仅在CPU不需要时才使用总线或强制CPU暂时暂停操作</li><li>DMA传输一个数据字,然后释放总线</li><li>DMA交错指令和数据传输</li></ul></li><li>透明模式（备用模式）<ul><li>DMA and CPU use bus by division time multiplexing</li><li>需要大部分时间,但效率最高</li></ul></li></ul></li></ul><p><img src="\img\COA\期末总结\26.png" alt="DMA Structure"></p><ul><li><p>DMA操作</p><ul><li>预处理：CPU告诉DMA控制器<ul><li>读/写</li><li>设备地址</li><li>数据存储块的起始地址</li><li>要转移的数据量</li><li>CPU继续进行其他工作</li></ul></li><li>数据传输：DMA控制器处理传输（逐字）</li><li>后处理：DMA控制器在完成后发送中断</li></ul></li><li><p>DMA Transfer Cycle Stealing</p><ul><li>DMA控制器接管总线一个周期</li><li>传输一个字的数据</li><li>不是中断<ul><li>因为CPU不切换上下文</li></ul></li><li>CPU在访问总线之前就suspended<ul><li>即在 取指 或 取操作数 或 数据写入 之前 (<a href="#p1">指令的流程</a>)</li></ul></li><li>减慢CPU速度但不会像CPU那样进行传输</li></ul></li></ul><p><img src="\img\COA\期末总结\27.png" alt=""></p><ul><li><p>DMA Configurations</p><ul><li>单总线,独立DMA控制器<ul><li>每次传输需要用到总线<strong>2次</strong>. IO-&gt;DMA DMA-memory</li><li>CPU suspended <strong>2次</strong></li><li><img src="\img\COA\期末总结\28.png" alt=""></li></ul></li><li>单总线,集成DMA控制器<ul><li>控制器支持&gt;1个设备</li><li>每次传输需要用到总线<strong>1次</strong> DMA-&gt;memory</li><li>CPU suspended <strong>1次</strong></li><li><img src="\img\COA\期末总结\29.png" alt=""></li></ul></li><li>单独的IO总线<ul><li>每次传输需要用到总线<strong>1次</strong> DMA-&gt;memory</li><li>CPU suspended <strong>1次</strong></li><li><img src="\img\COA\期末总结\30.png" alt=""></li></ul></li></ul></li><li><p>IO 通道</p><ul><li>IO通道是一个IO模块,具有自己的处理器,可以执行IO程序.IO程序位于主存中.实际上,IO通道代表了DMA概念的扩展.因此,IO通道具有执行IO指令和控制IO操作的能力.</li><li><strong>功能:</strong></li><li>从CPU接受命令(微指令)</li><li>从内存加载IO程序,并给设备发送命令</li><li>记录设备状态和中断</li><li>Buffer, control and transfer data, provide path for transferring </li><li><strong>流程:</strong></li><li>CPU发送IO命令 并等待 IO通道和设备ready -&gt; CPU开启通道 返回主程序 -&gt; 通道执行IO程序以在存储器和设备之间传输数据<br>-&gt;数据传输完成后,中断CPU</li></ul></li></ul><h1 id="Computer-Arithmetic"><a href="#Computer-Arithmetic" class="headerlink" title="Computer Arithmetic"></a>Computer Arithmetic</h1><p><img src="\img\COA\期末总结\31.png" alt="ALU Inputs and Outputs"></p><h1 id="Instruction-Sets-Characteristics-and-Functions"><a href="#Instruction-Sets-Characteristics-and-Functions" class="headerlink" title="Instruction Sets: Characteristics and Functions"></a>Instruction Sets: Characteristics and Functions</h1><h1 id="Instruction-Sets-Addressing-Modes-and-Formats"><a href="#Instruction-Sets-Addressing-Modes-and-Formats" class="headerlink" title="Instruction Sets: Addressing Modes and Formats"></a>Instruction Sets: Addressing Modes and Formats</h1><h1 id="CPU-Structure-and-Function"><a href="#CPU-Structure-and-Function" class="headerlink" title="CPU Structure and Function"></a>CPU Structure and Function</h1><h1 id="Reduced-Instruction-Set-Computers"><a href="#Reduced-Instruction-Set-Computers" class="headerlink" title="Reduced Instruction Set Computers"></a>Reduced Instruction Set Computers</h1><h1 id="InstructionLevel-Parallelism-and-Superscalar-Processors"><a href="#InstructionLevel-Parallelism-and-Superscalar-Processors" class="headerlink" title="InstructionLevel Parallelism and Superscalar Processors"></a>InstructionLevel Parallelism and Superscalar Processors</h1><h1 id="Control-Unit-Operation"><a href="#Control-Unit-Operation" class="headerlink" title="Control Unit Operation"></a>Control Unit Operation</h1>]]></content>
      
      
      <categories>
          
          <category> Computer Organization &amp; Architecture </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MMX课内实验</title>
      <link href="/2018/12/15/Computer%20Organization%20&amp;%20Architecture/MMX/"/>
      <url>/2018/12/15/Computer%20Organization%20&amp;%20Architecture/MMX/</url>
      
        <content type="html"><![CDATA[<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h1><p>使用普通和 MMX 技术实现淡入淡出效果，比较其时间花费。<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>1996 年，Intel 开始将 MMX 技术引入 Pentium 产品系列，MMX 十一组用于多媒体人物的优化指令，共有 57 条新指令。这些新指令以一种 SIMD(single-instruction-multiple-data,但指令多数据)方式来处理数据。于是，它能一次在多个数据元素上同时完成加、乘这样的运算。一般，每条指令执行只用一个时钟周期。对于何时的应用，与不适用 MMX 指令相比，这些快速地并行操作能产生 2-8 倍的加速效果。随着 x86 体系结构推出 64 位的处理器，Intel 也扩展了这些指令，使它们能处理双 quadword(128 位)操作数和浮点运算。在 MMX 指令中，引入了饱和(saturation)算术。在通常的无符号算术中，在运算出现上溢时(最高位向上进位)，则此额外位会被舍掉。这被称为环绕(wraparound)运算，因为从结果上看，舍掉进位使两个数加法之和小于被加的两个数。在饱和算术中，如果加法导致上溢，减法导致下溢，那么结果分别被设置成可表示的最大值和最小值。<br>下载地址:<a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a></p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a><strong>实验环境</strong></h1><p>实验所使用的软件为 Visual Studio 2017 和 SDL 2.0<br>SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X 等）的应用软件。目前SDL 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。SDL 使用 GNU 宽通用公共许可证为授权方式，意指动态链接（dynamic link 其库并不需要开放本身的源代码。</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a><strong>实验过程</strong></h1><ol><li>打开Visual Studio，创建一个新的空白C++工程。</li><li>右键项目名-&gt;属性菜单-&gt;C/C++-&gt;常规-&gt;附加包含目录-&gt;选择SDL/include 文件夹</li><li>属性菜单-&gt;C/C++-&gt;代码生成-&gt;运行库-&gt;改为”多线程 DLL (/MD)”</li><li>属性菜单-&gt;Linker-&gt;常规-&gt;附加库目录-&gt;选择SDL/lib/X86</li><li>属性菜单-&gt;Linker-&gt;输入-&gt;附加依赖项-&gt;填入<code>SDL2.lib; SDL2main.lib;</code></li><li>属性菜单-&gt;Linker-&gt;系统-&gt;子系统-&gt;改为未设置</li><li>如果出现<code>找不到SDL2.lib</code>的错误,可以尝试把<code>SDL2.lib</code>复制到项目的可执行文件的同一级目录下</li></ol><h1 id="SDL-准备工作"><a href="#SDL-准备工作" class="headerlink" title="SDL 准备工作"></a><strong>SDL 准备工作</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SCREEN_WIDTH = <span class="hljs-number">1920</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SCREEN_HEIGHT = <span class="hljs-number">1080</span>;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> len = SCREEN_WIDTH * SCREEN_HEIGHT * <span class="hljs-number">4</span>;</span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>  T = <span class="hljs-number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* tar, *pic1, *pic2;</span><br><span class="line">SDL_Window *gWindow = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_Surface *gScreenSurface = <span class="hljs-literal">nullptr</span>, *gpic1 = <span class="hljs-literal">nullptr</span>, *gpic2 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//开始测试之前的准备工作</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//初始化SDL视频子系统</span></span><br><span class="line"><span class="hljs-keyword">if</span> (SDL_Init(SDL_INIT_VIDEO) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Window could not be created! SDL_Error: %s\n"</span>, SDL_GetError());</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//创建窗口</span></span><br><span class="line">gWindow = SDL_CreateWindow(<span class="hljs-string">"SHOW BMP"</span>,<span class="hljs-comment">//窗口标题</span></span><br><span class="line">    SDL_WINDOWPOS_CENTERED,<span class="hljs-comment">//窗口位置设置</span></span><br><span class="line">    SDL_WINDOWPOS_CENTERED,</span><br><span class="line">    SCREEN_WIDTH,<span class="hljs-comment">//窗口的宽度</span></span><br><span class="line">    SCREEN_HEIGHT,<span class="hljs-comment">//窗口的高度</span></span><br><span class="line">    SDL_WINDOW_SHOWN<span class="hljs-comment">//显示窗口</span></span><br><span class="line">);</span><br><span class="line"><span class="hljs-keyword">if</span> (gWindow == <span class="hljs-literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Window could not be created! SDL_Error: %s\n"</span>, SDL_GetError());</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//将gWindow和gScreenSurface链接</span></span><br><span class="line">gScreenSurface = SDL_GetWindowSurface(gWindow);</span><br><span class="line"><span class="hljs-comment">//找到输出图像所在的位置</span></span><br><span class="line">tar = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gScreenSurface-&gt;pixels);</span><br><span class="line"><span class="hljs-comment">//获取图像文件的数据大小</span></span><br><span class="line">len = gScreenSurface-&gt;h * gScreenSurface-&gt;pitch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">SDL_FreeSurface(gpic1);<span class="hljs-comment">//释放空间</span></span><br><span class="line">SDL_FreeSurface(gpic2);</span><br><span class="line">gpic1 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">gpic2 = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_DestroyWindow(gWindow);<span class="hljs-comment">//销毁窗口</span></span><br><span class="line">gWindow = <span class="hljs-literal">nullptr</span>;</span><br><span class="line">SDL_Quit();<span class="hljs-comment">//退出SDL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a><strong>普通方法</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brute_force</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> time_st = SDL_GetTicks(), cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (SDL_GetTicks() - time_st &lt; T) &#123;</span><br><span class="line"><span class="hljs-keyword">double</span> shade = (<span class="hljs-keyword">double</span>)(SDL_GetTicks() - time_st) / T; <span class="hljs-comment">//获取当前渐变进度</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    tar[i] = pic1[i] + (pic2[i] - pic1[i]) * shade;</span><br><span class="line">&#125;</span><br><span class="line">++cnt;</span><br><span class="line">SDL_UpdateWindowSurface(gWindow); <span class="hljs-comment">//完成计算后刷新图像</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"FPS = %d\n"</span>, cnt * <span class="hljs-number">1000</span>/ T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MMX方法"><a href="#MMX方法" class="headerlink" title="MMX方法"></a><strong>MMX方法</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mmx</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> time_st = SDL_GetTicks();</span><br><span class="line"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (SDL_GetTicks() - time_st &lt; T) &#123;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> ff2 = (SDL_GetTicks() - time_st) * <span class="hljs-number">256</span> / T;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> ff1 = <span class="hljs-number">256</span> - ff2;</span><br><span class="line">    <span class="hljs-comment">//将4个16位整数拼在一起，当读取的时候会被当做一个64位整数进行处理</span></span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> f2[<span class="hljs-number">4</span>] = &#123; ff2,ff2,ff2,ff2 &#125;;</span><br><span class="line">    <span class="hljs-keyword">uint16_t</span> f1[<span class="hljs-number">4</span>] = &#123; ff1,ff1,ff1,ff1 &#125;;</span><br><span class="line">    <span class="hljs-keyword">uint32_t</span> p1, p2, *ptar;</span><br><span class="line">    <span class="hljs-comment">//4位的并行处理，因此循环次数位原先的四分之一</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">        p1 = ((<span class="hljs-keyword">uint32_t</span>*)pic1)[i];</span><br><span class="line">        p2 = ((<span class="hljs-keyword">uint32_t</span>*)pic2)[i];</span><br><span class="line">        ptar = &amp;(((<span class="hljs-keyword">uint32_t</span>*)tar)[i]);</span><br><span class="line">__asm &#123;</span><br><span class="line"><span class="hljs-comment">//将所需数据移入寄存器</span></span><br><span class="line">movd mm0, [p1]    <span class="hljs-comment">//load 4  pixel components from image A 把低 32位赋值给mm0</span></span><br><span class="line">movd mm1, [p2]  <span class="hljs-comment">//load 4  pixel components from image B</span></span><br><span class="line">mov edi, ptar</span><br><span class="line">pxor mm7, mm7  <span class="hljs-comment">//zero out mm7</span></span><br><span class="line"><span class="hljs-comment">//load fade value replicated 4 times</span></span><br><span class="line">movq mm3, [f1]  <span class="hljs-comment">//f1的64位赋值给mm3</span></span><br><span class="line">movq mm4, [f2]  </span><br><span class="line"><span class="hljs-comment">//将mm0和mm1解开，构成 00XX 00XX 00XX 00XX形式</span></span><br><span class="line">punpcklbw mm0, mm7</span><br><span class="line">punpcklbw mm1, mm7</span><br><span class="line"></span><br><span class="line">pmullw mm1, mm4</span><br><span class="line">pmullw mm0, mm3</span><br><span class="line"><span class="hljs-comment">//将结果相加后右移8位，再从拆开后的形式转回</span></span><br><span class="line">paddw mm0, mm1</span><br><span class="line">psrlw mm0, <span class="hljs-number">8</span><span class="hljs-comment">//XXYY XXYY XXYY XXYY =&gt; 00XX 00XX 00XX 00XX</span></span><br><span class="line">packuswb mm0, mm7 <span class="hljs-comment">//00XX 00XX 00XX 00XX =&gt; XX XX XX XX</span></span><br><span class="line"><span class="hljs-comment">//将结果传回目标位置</span></span><br><span class="line">movd[edi], mm0</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">    SDL_UpdateWindowSurface(gWindow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"FPS = %d\n"</span>, cnt * <span class="hljs-number">1000</span> / T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a><strong>主函数</strong></h1><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"SDL.h"</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-comment">//未设置时需要这一行</span></span><br><span class="line"><span class="hljs-comment">//系统改为 window子系统时需要注释掉</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">before();</span><br><span class="line"><span class="hljs-comment">//加载图片并获取地址</span></span><br><span class="line">gpic1 = SDL_ConvertSurface(SDL_LoadBMP(<span class="hljs-string">"C:\\Users\\xiaoxin\\Desktop\\5.bmp"</span>), gScreenSurface-&gt;format, <span class="hljs-number">0</span>);</span><br><span class="line">gpic2 = SDL_ConvertSurface(SDL_LoadBMP(<span class="hljs-string">"C:\\Users\\xiaoxin\\Desktop\\6.bmp"</span>), gScreenSurface-&gt;format, <span class="hljs-number">0</span>);</span><br><span class="line">pic1 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gpic1-&gt;pixels);</span><br><span class="line">pic2 = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)(gpic2-&gt;pixels);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//surface的快速复制</span></span><br><span class="line">SDL_BlitSurface(gpic1, <span class="hljs-literal">nullptr</span>, gScreenSurface, <span class="hljs-literal">nullptr</span>);</span><br><span class="line">SDL_UpdateWindowSurface(gWindow);<span class="hljs-comment">//更新显示</span></span><br><span class="line">SDL_Delay(<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">SDL_BlitSurface(gpic2, <span class="hljs-literal">nullptr</span>, gScreenSurface, <span class="hljs-literal">nullptr</span>);</span><br><span class="line">SDL_UpdateWindowSurface(gWindow);<span class="hljs-comment">//更新显示</span></span><br><span class="line">SDL_Delay(<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">brute_force();</span><br><span class="line">mmx();</span><br><span class="line">SDL_Delay(<span class="hljs-number">15000</span>);</span><br><span class="line"></span><br><span class="line">after();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a><strong>运行结果</strong></h1><ol><li>图片1<br><img src="\img\COA\MMX课内实验\1.png" alt=""></li><li>渐变<br><img src="\img\COA\MMX课内实验\2.png" alt=""></li><li>渐变<br><img src="\img\COA\MMX课内实验\3.png" alt=""></li><li>图片2<br><img src="\img\COA\MMX课内实验\4.png" alt=""></li><li>FPS 比较<br><img src="\img\COA\MMX课内实验\FPS.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Organization &amp; Architecture </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>11-structual testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/11-structual%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/11-structual%20testing/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><br></p><ul><li><h1 id="DD-path覆盖"><a href="#DD-path覆盖" class="headerlink" title="DD-path覆盖"></a><strong>DD-path覆盖</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的每个DD路径，则它们构成DD路径覆盖。<br><br></li></ul></li><li><h1 id="branch覆盖"><a href="#branch覆盖" class="headerlink" title="branch覆盖"></a><strong>branch覆盖</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的决策（predicate）的每个分支（输出），则它们构成分支覆盖。<br><br></li></ul></li><li><h1 id="path-coverage"><a href="#path-coverage" class="headerlink" title="path coverage"></a><strong>path coverage</strong></h1><ul><li>给定程序的一组测试用例，如果在程序上执行时，遍历程序图中从源节点到汇聚节点的每条路径，则它们构成路径覆盖。<br><br></li></ul></li><li><h1 id="node-coverage"><a href="#node-coverage" class="headerlink" title="node coverage"></a><strong>node coverage</strong></h1><ul><li>如果在程序上执行时，遍历程序图中的每个节点，则它们构成节点覆盖。<br><br></li></ul></li><li><h1 id="edge-coverage"><a href="#edge-coverage" class="headerlink" title="edge coverage"></a><strong>edge coverage</strong></h1><ul><li>遍历程序图中的每个边，则它们构成边缘覆盖。<br><br><br><strong>语句覆盖</strong><br>使所有的判断语句都能执行一次的条件案例，例如当判断语句事组合语句的时候，并且用or连接，只满足一个案例即可<br><strong>判定覆盖（分支覆盖）</strong><br>针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况<br><strong>条件覆盖</strong><br>针对判断语句里面案例的取值都要去一次，不考虑条件的取值<br><strong>判定/条件覆盖</strong><br>判定覆盖各条件覆盖交叉，针对于判定中的条件取值<br><strong>组合覆盖</strong><br>判定-条件覆盖的加强版 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>10-Stochastic or Random Test</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/10-Stochastic%20or%20Random%20Test/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/10-Stochastic%20or%20Random%20Test/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>What</li><li>Why</li><li>特点<a id="more"></a><br></li></ul></li><li><h1 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a><strong>随机测试</strong></h1><ul><li>黑盒测试</li><li>输入:Random，independent</li><li>输出:Compared against software specifications to verify that the test output is pass or fail</li><li>测试过程：自动化</li><li>覆盖范围：广泛但浅显<br><br></li></ul></li><li><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a><strong>Why</strong></h1><ul><li>随机测试可以让我们轻松的根据测试结果估算软件可靠性。</li><li>可以从随机测试中获得数据用于估计软件的可靠性(其他测试方法不能用这种方式来估算软件可靠性）</li><li>相比于其他更为周到的测试方法，可以节约精力和时间<br><br></li></ul></li><li><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h1><ul><li>无需任何特定测试</li><li>在无文档、无计划下的软件测试</li><li>可以发现测试用例覆盖不到的bug</li><li>随机测试几乎可以在任何时候进行</li><li>测试软件的鲁棒性</li><li>发现低优先级高严重性的bug<br><br></li></ul></li><li><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h1>与模糊测试的区别：<br>  模糊测试：随机数据<br>  随机测试：随机行为<br>与探索性测试的区别：<br>  随机测试：思维过程无序<br>  探索性测试：思维过程具有有序性、合理性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>9-Scenario testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/9-Scenario%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/9-Scenario%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="场景测试"><a href="#场景测试" class="headerlink" title="场景测试"></a><strong>场景测试</strong></h1><ul><li>在软件开发过程的测试阶段中，由于实际系统过分庞大和复杂，很难测试其全部功能，而只能测试其与执行的任务有类似性的主要功能<a id="more"></a><br></li><li>目标<ul><li>使用具有挑战性的案例来反映实际的使用</li></ul></li><li>测试者<ul><li>Anyone</li></ul></li><li>覆盖率<ul><li>场景所能覆盖的所有区域</li></ul></li><li>可能存在的问题<ul><li>有经验的用户在实际使用时的复杂交互</li></ul></li><li>活动<ul><li>采访相关人员，写场景剧本然后执行测试</li></ul></li><li>复杂度<ul><li>高</li></ul></li><li>被测试系统阶段<ul><li>后期 需要稳定 集成的功能<br><br></li></ul></li></ul></li><li><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h1><ul><li>可以帮助解决复杂、现实中的问题。解决一些因为复杂而难以建模分析的情况。</li><li>暴露随着时间的流逝而可能会出现的错误。</li><li>可以使测试情景与将来的工作情境尽可能相似，测出的结果具有很好的预测效果</li></ul></li><li><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a><strong>缺陷</strong></h1><ul><li>单个功能的错误会让这个测试变得效率底下。</li><li>必须思虑周详以达成好的覆盖。测试者需要较有经验。</li><li>分析过程较为人为化，客观性受到影响</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>8-User Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/8-User%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/8-User%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="用户测试"><a href="#用户测试" class="headerlink" title="用户测试"></a><strong>用户测试</strong></h1><ul><li>定义：以用户为为参与主体的测试</li><li>引入原因：用户作为软件最终使用的主体</li><li>测试目标：测试软件的总体情况及用户体验</li><li>测试者：用户</li><li>覆盖面：很难度量</li><li>测试启动时间：软件开发基本完成<a id="more"></a><br></li></ul></li><li><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h1><ul><li>暴露设计的问题</li><li>能找到高错误率的区域</li><li>测试过程能够被监控</li><li>能够通过内部实验室注意有争议的区域<br><br></li></ul></li><li><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h1><ul><li>覆盖面不能够保证</li><li>测试用例弱</li><li>结果好坏不一</li><li>必须区分营销测试与技术测试</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>7-Exploratory Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/7-Exploratory%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/7-Exploratory%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="探索性测试"><a href="#探索性测试" class="headerlink" title="探索性测试"></a><strong>探索性测试</strong></h1><ul><li>探索性测试（ET）可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索测试强调测试人员的主观能动性，避免繁杂的测试计划和测试用例设计的文档制作过程，强调在碰到问题时及时改变测试策略<a id="more"></a><br><br>探索性测试的最大特色是在对测试对象进行测试的同时学习测试对象并设计测试，在测试过程中运用获得的关于测试对象的信息设计新的更好的测试.<br>这相对于传统软件测试过程中严格的“先设计，后执行”来说，是具有很大区别的.<br><br>  </li></ul></li><li><h1 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a><strong>基本过程</strong></h1><ul><li>识别软件系统的目的；</li><li>识别软件系统提供的功能；</li><li>识别软件系统潜在的不稳定的区域；</li><li>在探索软件系统的过程中记录关于软件的消息和问题；</li><li>创建一个测试纲要，使用它来执行测试。</li></ul><p><br></p></li><li><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h1><ul><li>不需要太多的准备工作，能够很快的发现重要的错误。</li><li>测试人员可以根据先前的测试结果来调整之后的测试用例，这在某种意义上可以加快bug发现的过程。</li><li>对产品质量有个整体概念，可以作为整个项目里工作分级的一个基础。<br><br></li></ul></li><li><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h1><ul><li>测试用例很难全面覆盖。</li><li>容易出现重复测试，且测试难以跟踪。</li><li>需要测试人员具有较高水平。<br><br></li></ul></li><li><h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a><strong>适用范围</strong></h1><ul><li>需要对新功能或是新产品提供快速的反馈的测试</li><li>为测试用例的设计,前期进行尝试性测试</li><li>已经过了传统测试,但需要进一步测试</li><li>对已有测试用例的改进</li><li>要求在短时间内发现一些重要缺陷的测试</li><li>管理人员需要测试一下测试人员的工作成果</li><li>测试某一特定类型的缺陷</li><li>测试一些已知的缺陷</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>6-Regression testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/6-Regression%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/6-Regression%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="回归测试（Regression-testing）"><a href="#回归测试（Regression-testing）" class="headerlink" title="回归测试（Regression testing） "></a><strong>回归测试（Regression testing） </strong></h1><ul><li>指在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，软件产生新版本都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。<a id="more"></a><br></li></ul></li><li>回归测试通常被认为是“程序的重新确认”；<ul><li>“纠正型回归测试”指对程序修改后进行回归测试；</li><li>“增量型回归测试”指程序增加新特性后进行测试。<br><br></li></ul></li><li><h1 id="回归测试多余？"><a href="#回归测试多余？" class="headerlink" title="回归测试多余？"></a><strong>回归测试多余？</strong></h1><ul><li>开发人员也可以通过适当的证据证明新增的方法对原方法没有影响，这种情况下回归测试是多余的。<br><br></li></ul></li><li><h1 id="必须进行回归测试的情况"><a href="#必须进行回归测试的情况" class="headerlink" title="必须进行回归测试的情况"></a><strong>必须进行回归测试的情况</strong></h1><ul><li>当对软件的一个子系统进行修改，得到软件的一个新版本，此时回归测试是必需的；</li><li>当对软件的一个或多个构件进行了修改，整个软件也必须进行回归测试</li><li>在某些情况下，当底层硬件发生变化时，无论软件有无变更，也需要进行回归测试<br><br></li></ul></li><li><h1 id="回归测试过程"><a href="#回归测试过程" class="headerlink" title="回归测试过程"></a><strong>回归测试过程</strong></h1><ul><li>测试重确认/选择/最小化/优先级排序<ul><li><strong>测试重确认</strong>：检查p的测试用例，以确定哪些是对p’。重确认确保回归测试时只使用那些对p’有效的用例(p’为新版本)</li><li><strong>测试选择</strong>：对p有效的测试对p’可能是多余的因为它们的执行轨迹不经过p’中已修改过的代码。识别那些执行轨迹经过p’修改部分的测试过程就称为测试选择，优势也称为回归测试选择(RTS)问题</li><li><strong>测试最小化</strong>：根据某些准则丢弃那些多余的测试用例。例如t1和t2都测试了p的功能f，那么在测试最小化的时候，就可能丢弃t2而丢弃t1</li><li><strong>测试优先级排序</strong>：是基于某些准则对测试用例进行排序。当资源受限，通过测试优先级排序，就会发挥作用</li></ul></li><li>测试准备<ul><li>测试准备是指将被测程序置于预期的或者模拟的测试环境中，准备接收数据，并产生，需要的输出信息</li></ul></li><li>测试排序<ul><li>测试过程中有可能关心对软件的测试输入顺序。对具有内部状态且连续运行的软件来讲，测试排序非常重要。银行结算软件、web服务、引擎控制器等都是这类软件</li></ul></li><li>测试执行<br>- </li><li>输出比较</li><li>故障消除</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>5-Stress Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/5-Stress%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/5-Stress%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>压力测试简述</li><li>压力测试特点</li><li>压力测试步骤</li><li>压力测试实例<a id="more"></a><br></li></ul></li><li><h1 id="Stress-Testing"><a href="#Stress-Testing" class="headerlink" title="Stress Testing"></a><strong>Stress Testing</strong></h1><ul><li>是指不断给被测系统增加压力，直到被测系统被压垮，并在系统被压垮的情况下持续测试。</li><li>以确定系统能承受的最大压力以及系统是否具有良好的容错能力和可恢复能力。<br><br></li></ul></li><li><h1 id="压力测试的特点"><a href="#压力测试的特点" class="headerlink" title="压力测试的特点"></a><strong>压力测试的特点</strong></h1><ul><li>测试者：在软件压力测试方面具备专业知识和一定的操作技能的人</li><li>代码覆盖率：部分覆盖，难以界定是否覆盖完全</li><li>测试阶段：开发项目接近完成</li><li>粗颗粒度：压力测试极其粗糙</li><li>复杂性：根据软件自身的需求有所不同</li><li>优点<ul><li>能暴露系统可能出现的缺陷</li><li>能暴露系统的安全风险</li><li>可能对评估性能、可靠性或效率有帮助</li></ul></li><li>局限性<ul><li>缺陷可能在压力测试下并不明显</li><li>当不知道问题的大致区间时，压力测试就会比较慢</li><li>易出现“不知道因为什么导致了问题”和“有没有遗漏什么”的问题<br><br></li></ul></li></ul></li><li><h1 id="压力测试的步骤"><a href="#压力测试的步骤" class="headerlink" title="压力测试的步骤"></a><strong>压力测试的步骤</strong></h1><ol><li>Identify the Test Environment 确认测试环境</li><li>Identify Performance Acceptance Criteria 确认性能指标</li><li>Plan and Design Tests 计划并设计测试</li><li>Configure the Test Environment 配置测试环境</li><li>Implement the Test Design 实现设计好的测试</li><li>Execute the Test 执行测试</li><li>Analyze Results, Report, and Retest 分析、报告、重复测试</li></ol></li></ul><p><br></p><ul><li><h1 id="压力测试与其他测试的关系"><a href="#压力测试与其他测试的关系" class="headerlink" title="压力测试与其他测试的关系"></a><strong>压力测试与其他测试的关系</strong></h1>常见的测试有：负载测试、压力测试和性能测试。<br>三者测试目的不同，但其手段和方法在一定程度上比较相似，通常会使用相同的测试环境和测试工具，而且都会监控系统所占用资源的情况以及其它相应的性能指标。</li></ul><ol><li><strong>tester</strong>：三者都应该具有一定的专业水平</li><li><strong>coverage</strong>：三者均为部分覆盖，存在局限性，难以确定是否覆盖了所有可能的缺陷</li><li><strong>potential problem</strong>：压力测试是期望系统崩溃；负载测试是期望得到系统的响应时间和质量；性能测试时为了了解应用程序在常规参数下的行为方式</li><li><strong>activities</strong>：压力测试往往要增加比负载测试多的并发用户，一般要比系统设计的并发量大，而性能测试验证产品资源的使用情况，可用性及可靠性</li><li><strong>evaluation</strong>：压力测试是看服务器能否在崩溃后自我恢复，任何意外故障是否会损害系统安全性；负载测试是看系统的响应时间和质量是否符合设计要求及当前的基础设施是否足以运行应用程序；性能测试是看系统是否符合业务的性能需求，验证该应用程序能否正常运行</li><li><strong>focus</strong>：性能测试的关注点在于程序运行的响应时间和并发量，负载测试的关注点在于系统并发量的多少，而压力测试更关注在超过了系统极限值的限制范围后系统的影响。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4-Risk-based Testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/4-Risk-based%20Testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/4-Risk-based%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Targets, concept and benefits of RBT</li><li>Risk and Risk management</li><li>Risk-based testing approach</li><li>Risk-based testing in practice</li><li>Risk matrix and Risk reporting</li><li>Risk-based testing and test automation<a id="more"></a><br></li></ul></li><li><h1 id="Why-Risk-based-Testing"><a href="#Why-Risk-based-Testing" class="headerlink" title="Why Risk-based Testing?"></a><strong>Why Risk-based Testing?</strong></h1><ul><li>Software projects are very <strong>rarely on time,schedule or budget.</strong> Very often early project phases are delayed.</li><li>When eventually comes down to testing, the time to delivery is <strong>extremely short</strong> and there is <strong>no budget left</strong> due to the development overrun.</li><li>During development everybody is as a rule extremely busy resulting the test preparation activities not receiving the <strong>appropriate attention.</strong><br><br></li></ul></li><li><h1 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a><strong>RBT</strong></h1><ul><li>RBT(Risk-based Testing) is a test method deciding the test strategy by analyzing and accessing the risk of product.</li><li>Reduced resource consumption(i.e., more efficient testing)</li><li>Improved quality by spending more time on critical functions.<br><br></li></ul></li><li><h1 id="Risk-and-Risk-management"><a href="#Risk-and-Risk-management" class="headerlink" title="Risk and Risk management"></a><strong>Risk and Risk management</strong></h1><ul><li>Risk Identification</li><li>Risk Strategy</li><li>Risk Assessment</li><li>Risk Mitigation</li><li>Risk Reporting</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>3-Specification-based testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/3-Specification-based%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/3-Specification-based%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h1><ul><li>黑盒测试、功能测试、数据驱动测试</li><li>测试者不了解程序的内部情况，不需具备应用程序的代码、内部结构和编程语言的专门知识。只知道程序的输入、输出和系统的功能，这是从用户的角度针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。<a id="more"></a></li></ul></li><li>基本属性<ul><li>目标：核验需求文档里每个要求的一致性。</li><li>测试者：可以任何人。</li><li>覆盖内容：文档化的需求以及一些特性。</li><li>潜在问题：实现与规格不匹配的问题。</li><li>评估方法：实现是否与规格匹配。</li><li>复杂度：由规格说明书决定</li><li>苛刻度：有规格说明书决定<br><br></li></ul></li><li>如何在缺少规格说明书的情况下获取信息?有什么可行的替代方法？<ul><li>在缺少规格说明书或者是规格说明书不正确的时候可以使用使用如下资源<ul><li>软件更新备忘录</li><li>用户手册草稿</li><li>产品资料</li><li>已发布的样式指南和UI标准</li><li>已发布的标准</li><li>第三方产品兼容性测试套件</li><li>内部备忘录</li><li>营销展示、产品概念</li><li>Bug报告</li><li>逆向工程 ….<br><br></li></ul></li></ul></li><li><h1 id="规格说明"><a href="#规格说明" class="headerlink" title="规格说明"></a><strong>规格说明</strong></h1><ul><li>规格说明书要求做到精确和细化需求中描述的系统功能性需求和约束。</li><li>规格说明是为了技术人员编写的</li><li>规格说明书的形式可以是多种多样的。下面列出几个常见的规格说明书形式：<ul><li>需求文档 用例 模型 形式化方法 原型  …</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2-Equivalence analysis</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/2-Equivalence%20analysis/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/2-Equivalence%20analysis/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>等价类划分</li><li>等价类划分指南</li><li>等价类划分实例<a id="more"></a><br></li></ul></li><li><h1 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a><strong>等价类</strong></h1><ul><li>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的。<br><br></li></ul></li><li><h1 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a><strong>等价类划分</strong></h1><ul><li>等价类划分，指一种典型的、重要的<strong>黑盒测试方法</strong>，它将程序所有可能的输入数据划分为若干个等价类。然后从每个部分中选取具有代表性的数据当做测试用例。利用这一方法设计测试用例可以不考虑程序的内部结构，以需求规格说明书为依据，选择适当的典型子集，认真分析和推敲说明书的各项需求，特别是功能需求，尽可能多地发现错误。等价类划分法是一种系统性的确定要输入的测试条件的方法。<br><br></li></ul></li><li><h1 id="有效等价类划分"><a href="#有效等价类划分" class="headerlink" title="有效等价类划分"></a><strong>有效等价类划分</strong></h1><ul><li>有效等价类指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个，根据系统的输入域划分若干部分，然后从每个部分中选取少数有代表性数据当做数据测试的测试用例，等价类是输入域的集合。</li><li>以下是对有效等价类数据集的一些例子：<ul><li>终端用户输入的命令</li><li>与最终用户交互的系统提示</li><li>接受相关的用户文件的名称</li><li>提供初始化值和边界等</li><li>提供格式化输出数据的命令</li><li>在图形模式（比如鼠标点击时）提供的数据</li><li>失败时显示的回应消息<br><br></li></ul></li></ul></li><li><h1 id="无效等价类划分"><a href="#无效等价类划分" class="headerlink" title="无效等价类划分"></a><strong>无效等价类划分</strong></h1><ul><li>无效等价类和有效等价类相反，无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。利用无效等价类，可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。</li><li>以下是无效等价类数据集的一些例子：<ul><li>终端在一个不正确的地方提供适当的值</li><li>验证外部边界的值</li><li>验证与边界和外部边界值的数值数据<br><br></li></ul></li></ul></li><li><h1 id="等价类划分指南"><a href="#等价类划分指南" class="headerlink" title="等价类划分指南"></a><strong>等价类划分指南</strong></h1><ul><li>等价类划分的方法<ul><li><strong>输入条件制定了一个域</strong></li><li><strong>输入条件指定了一组值的集合</strong>: 为集合中的每个元素创建一个等价类，为一个无效输入也创建一个等价类</li><li><strong>输入条件指定了每一个单独的值</strong>：如果系统对每一个有效输入的处理都不同，那么为每一个有效输入创建一个等价类</li><li><strong>输入条件指定了有效值的数量</strong>：为正确的输入数量创建一个等价类，为无效输入创建两个等价类——一个数量为零，一个比N大</li><li><strong>输入条件指定了一个必须值</strong>：为该必须值创建一个等价类，为非必须值创建一个等价类</li><li><strong>分割等价类</strong>：如果系统以不同方式处理一个划分好的等价类中的元素，那么分割该等价类为更小的等价类</li></ul></li><li>从等价类中识别测试用例<ol><li>为每个等价类指定一个唯一的标识符</li><li>对于每个还未被测试用例覆盖到的有效输入等价类，生成新的测试用例，尽量多地覆盖还未覆盖到的等价类，按照这一步骤重复进行，直到所有的有效等价类都被覆盖为止</li><li>对于每个还未被测试用例覆盖到的无效输入等价类，生成新的测试用例，仅覆盖一个还未覆盖到的等价类，按照这一步骤重复进行，直到所有的无效等价类都被覆盖为止。<br><br></li></ol></li></ul></li><li><h1 id="等价类划分实例"><a href="#等价类划分实例" class="headerlink" title="等价类划分实例"></a><strong>等价类划分实例</strong></h1><h2 id="Ex-A"><a href="#Ex-A" class="headerlink" title="Ex A"></a><strong>Ex A</strong></h2>申请账号时，用户必须输入用户名、密码、确认密码，对每一项输入条件要求如下：用户命要求为6位以上，18位以下，使用英文字母、数字、“-”、“”,并且首字符必须为字母或数字；密码在6~16位之间，只能用英文字母、数字、“-”、“”,并且区分大小写。列出等价类表和测试用例。</li></ul><p><strong>等价类表：</strong><br><img src="/img/soa/ex1_1.jpg" alt=""><br><strong>等价类的测试用例：</strong><br><img src="/img/soa/ex1_2.jpg" alt=""><br><br></p><h2 id="Ex-B"><a href="#Ex-B" class="headerlink" title="Ex B"></a><strong>Ex B</strong></h2><p>一个程序读入3个整数，把这3个数值看作一个三角形的3条边的长度值。这个程序要打印出信息，说明这个三个数值不构成三角形、或是一般三角形、或是等腰的三角形、或是等边三角形。列出等价类表和测试用例。<br><strong>分析题目中给出和隐含的对输入条件的要求：</strong></p><ol><li>整数   2. 三个数   3. 非零数  4. 正数  5. 两边之和大于第三边   6.等腰   7. 等边<br>如果a、b、c满足条件1~4，则输出下列四种情况之一：<br>1）如果不满足条件5，则程序输出为“非三角形”<br>2）如果三条边相等即满足条件7，则程序输出为“等边三角形”<br>3）如果只有两条边相等，及满足条件6，则程序输出为“等腰三角形”<br>4）如果三条边都不相等，则程序输出为“一般三角形”<br><br><br><strong>等价类表</strong><br><img src="/img/soa/ex2_1.jpg" alt=""><br><br><br><strong>覆盖有效等价类的测试用例</strong><br><img src="/img/soa/ex2_2.jpg" alt=""><br><br><br><strong>覆盖无效类等价类的测试用例</strong><br><img src="/img/soa/ex2_3.jpg" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1-Function testing</title>
      <link href="/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/1-Function%20testing/"/>
      <url>/2018/12/10/Software%20Quality%20Assurance/Individual%20techniques/1-Function%20testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Function-testing"><a href="#Function-testing" class="headerlink" title="Function testing"></a><strong>Function testing</strong></h1><ul><li>也叫黑盒单元测试</li><li>针对每个功能单元进行的一种黑盒测试。<a id="more"></a><br></li></ul></li><li>测试人员<ul><li>可以是任何人：编码人员、测试人员等</li></ul></li><li>覆盖程度<ul><li>覆盖所有的功能以及用户可见的变量</li></ul></li><li>测试的目的<ul><li>为了使每个功能能够单独运作</li></ul></li><li>测试方法<ul><li>穷举法</li><li>边界值分析法</li><li>基于单/多缺陷假设设计测试样例</li><li>等价类划分法</li><li>典型数据法</li><li>…</li></ul></li><li>如何分析结果<ul><li>寻找同类功能做对比.同类功能：例如显卡的功能测试，找同类显卡，在相同的输入条件下比较输出结果。</li></ul></li><li>复杂程度<ul><li>对已实现的各个功能设计测试样例进行测试</li></ul></li><li>严格程度<ul><li>指测试方法对软件错误的容忍程度，即其发现软件错误的能力大小</li></ul></li><li>对系统完成度的要求<ul><li>每一个功能单元完成后便可以进行功能测试</li></ul></li><li>优点<ul><li>对每个测试项目进行全面分析</li><li>Easy to do as each function is implemented</li></ul></li><li>缺点<ul><li>Misses interactions</li><li>Misses exploration of the benefits offered by the program</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Individual techniques </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>6-Test &amp; Evaluate</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/6-Test%20&amp;%20Evaluate/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/6-Test%20&amp;%20Evaluate/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Defining test techniques</li><li>Individual techniques</li><li>Using techniques together<a id="more"></a><br></li></ul></li><li><h1 id="Dimensions-of-Test-Techniques"><a href="#Dimensions-of-Test-Techniques" class="headerlink" title="Dimensions of Test Techniques"></a><strong>Dimensions of Test Techniques</strong></h1><ul><li>Think of the testing you do in terms of five dimensions:<ul><li>Testers: who does the testing.</li><li>Coverage: what gets tested.</li><li>Potential problems: why you’re testing (what risk you’re testing for).</li><li>Activities: how you test.</li><li>Evaluation: how to tell whether the test passed or failed.<br><br></li></ul></li></ul></li></ul><p>Of the 200+ published Functional Testing techniques, there are ten basic themes.<br>They capture the techniques in actual practice.</p><ol><li>Function testing </li><li>Equivalence analysis </li><li>Specification-based testing </li><li>Risk-based testing </li><li>Stress testing </li><li>Regression testing </li><li>Exploratory testing </li><li>User testing </li><li>Scenario testing </li><li>Stochastic or Random testing<br>详情见 Individual techniques 目录<br><br></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>5-Define Evaluation Mission</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/5-Define%20Evaluation%20Mission/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/5-Define%20Evaluation%20Mission/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Define Evaluation Mission</li><li>Defining the mission of the test group</li><li>Defining the goal for test documentation<a id="more"></a><br></li></ul></li></ul><p><code>In this module, we begin with the workflow detail Define Evaluation MissionThe Mission focuses on the high-level objectives of the test team for the current iteration</code><br><br></p><ul><li><h1 id="Define-Evaluation-Mission"><a href="#Define-Evaluation-Mission" class="headerlink" title="Define Evaluation Mission"></a><strong>Define Evaluation Mission</strong></h1><ul><li>The purpose of this workflow detail is to:</li><li>确定迭代测试工作的适当重点。</li><li>与利益相关方就实现测试工作的相应目标达成协议</li><li>对于每次迭代，工作主要集中在：<ul><li>确定测试工作的目标和可交付成果</li><li>确定良好的资源利用战略</li><li>为测试工作定义适当的范围和边界</li><li>概述将使用的方法</li><li>确定如何监控和评估进展情况。<br><br></li></ul></li></ul></li><li><h1 id="Defining-the-Test-Approach"><a href="#Defining-the-Test-Approach" class="headerlink" title="Defining the Test Approach"></a><strong>Defining the Test Approach</strong></h1><ul><li>The test approach (testing strategy)specifies the techniques that will be used to accomplish the test mission.</li><li>The test approach also specifies how the techniques will be used.</li><li>A good test approach is:<ul><li>Diversified<ul><li>Include a variety of techniques. Each technique is tailored to expose <strong>certain types of problems</strong>, and is virtually blind to others. <strong>Combining</strong> them allows you to find problems that would be hard to find if you spent the same resource on a narrower collection of techniques.</li></ul></li><li>Risk-focused<ul><li>Tests give you the opportunity to find defects or attributes of the software that will disappoint, alienate, or harm a stakeholder. You can’t run all possible tests. To be efficient, you should think about the types of problems that are plausibly in this product or that would make a difference if they were in this product, and make sure that you test for them.</li></ul></li><li>Product-specific<ul><li>Generic test approaches don’t work. Your needs and resources will vary across products. The risks vary across products. Therefore the balance of investment in different techniques should vary across products.</li></ul></li><li>Practical<ul><li>here’s no point defining an approach that is beyond your project’s capabilities (including time, budget, equipment, and staff skills).</li></ul></li><li>Defensible<br><br></li></ul></li></ul></li><li><h1 id="Defining-the-goal-for-test-documentation"><a href="#Defining-the-goal-for-test-documentation" class="headerlink" title="Defining the goal for test documentation"></a><strong>Defining the goal for test documentation</strong></h1><ul><li><em>What Test Documentation Should You Use?</em><ul><li>Test planning standards and templates</li><li>Requirements considerations</li><li>Questions to elicit information about test documentation requirements for your project</li></ul></li><li>IEEE Standard 829 for Software Test Documentation<br><img src="/img/soa/standard829.png" alt=""></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4-The RUP Test Discipline</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/4-The%20RUP%20Test%20Discipline/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/4-The%20RUP%20Test%20Discipline/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>The terminology of RUP</li><li>The testing discipline in RUP</li><li>The testing workflow structure<a id="more"></a><br></li></ul></li><li><h1 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a><strong>WHAT</strong></h1><ul><li><strong>The Rational Unified Process (RUP)</strong> is a software engineering process framework that provides a <strong>disciplined yet flexible</strong> approach to <strong>assigning tasks and responsibilities</strong> within a software development organization.</li><li><strong>RUP’s goal</strong> is to support the production of high-quality software that meets the needs of its end users within a <strong>predictable schedule and budget.</strong><br><br></li></ul></li><li><h1 id="The-RUP-supports-many-software-engineering-practices"><a href="#The-RUP-supports-many-software-engineering-practices" class="headerlink" title="The RUP supports many software engineering practices"></a><strong>The RUP supports many software engineering practices</strong></h1><ul><li>The dynamic structure (phases and iterations) of the Rational Unified Process creates a basis for iterative development.</li><li>The Project Management discipline describes how to set up and execute a project using phases and iterations.</li><li>The Use-Case Model and Risk List of the Requirements discipline help determine what functionality you implement in each iteration.</li><li>The Workflow Details of the Requirements discipline show the activities and artifacts that make requirements management possible.</li><li>The iterative approach allows you to progressively identify components, decide which ones to develop, which ones to reuse, and which ones to buy.</li><li>The Unified Modeling Language (UML) used in the process represents the basis of Visual Modeling and has become the de facto modeling language standard.</li><li>The focus on software architecture allows you to articulate the structure: the components and the ways in which they integrate, the fundamental mechanisms and patterns by which they interact<br><img src="/img/soa/RUPProcessArch.png" alt=""><br><br></li></ul></li><li><h1 id="The-Rational-Unified-Process-has-four-phases"><a href="#The-Rational-Unified-Process-has-four-phases" class="headerlink" title="The Rational Unified Process has four phases:"></a><strong>The Rational Unified Process has four phases:</strong></h1><ul><li>Inception - Define the project scope, gain agreement on project objectives, baseline the product Vision</li><li>Elaboration - Address key technical risks, produce an evolutionary prototype, baseline the Architecture</li><li>Construction - Iteratively and incrementally develop an operationally complete product</li><li>Transition - Deliver the product into the live end-user environment</li><li>初始 - 定义项目范围，就项目目标达成一致，为产品愿景奠定基础</li><li>精化 - 解决关键技术风险，制作演化原型，建立基线</li><li>构建 - 迭代并逐步开发出操作完整的产品</li><li>过渡 - 将产品交付给实时最终用户环境<br><br></li></ul></li><li><h1 id="Roles-in-the-Test-Discipline"><a href="#Roles-in-the-Test-Discipline" class="headerlink" title="Roles in the Test Discipline"></a><strong>Roles in the Test Discipline</strong></h1><ul><li>Test Manager<ul><li>is tasked with the overall responsibility for the test effort’s success.</li></ul></li><li>Test Analyst<ul><li>is responsible for initially identifying and defining the required tests, and subsequently evaluating the results of the test effort.</li></ul></li><li>Test Designer<ul><li>is responsible for defining the test approach and ensuring its successful implementation.</li></ul></li><li>Tester<ul><li>is responsible for the core activities of the test effort, which involves conducting the necessary tests and logging the outcomes of that testing.<br><br><br><img src="/img/soa/workflow.png" alt="The RUP Test Discipline Workflow"><br><br></li></ul></li></ul></li><li><h1 id="Define-Evaluation-Mission"><a href="#Define-Evaluation-Mission" class="headerlink" title="Define Evaluation Mission"></a><strong>Define Evaluation Mission</strong></h1><ul><li>Identify the appropriate focus of the test effort for the iteration.</li><li>Gain agreement with stakeholders on the corresponding goals that will direct the test effort.<br><br></li></ul></li><li><h1 id="Test-and-Evaluate"><a href="#Test-and-Evaluate" class="headerlink" title="Test and Evaluate"></a><strong>Test and Evaluate</strong></h1><ul><li>Achieve appropriate breadth and depth of testing to enable a sufficient evaluation of the targeted test items.<br><br></li></ul></li><li><h1 id="Achieve-Acceptable-Mission"><a href="#Achieve-Acceptable-Mission" class="headerlink" title="Achieve Acceptable Mission"></a><strong>Achieve Acceptable Mission</strong></h1><ul><li>Deliver a useful evaluation result to the stakeholders of the test effort.</li><li>Actively prioritize the test work that remains to be conducted.<br><br></li></ul></li><li><h1 id="Verify-Test-Approach"><a href="#Verify-Test-Approach" class="headerlink" title="Verify Test Approach"></a><strong>Verify Test Approach</strong></h1><ul><li>Demonstrate the techniques outlined in the Test Approach will support the required testing.</li><li>Verify that the approach will work, produce accurate results and is appropriate for the available resources.<br><br></li></ul></li><li><h1 id="Validate-Build-Stability"><a href="#Validate-Build-Stability" class="headerlink" title="Validate Build Stability"></a><strong>Validate Build Stability</strong></h1><ul><li>Validate that the build is stable enough for detailed test and evaluation work to begin<br><br></li></ul></li><li><h1 id="Improve-Test-Assets"><a href="#Improve-Test-Assets" class="headerlink" title="Improve Test Assets"></a><strong>Improve Test Assets</strong></h1><ul><li>Maintain and improve the evolving test assets.</li><li>(e.g. Maintain test suites and test data; harvest test-ideas into catalogs; clarify change request details)<br><br></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>3-Introduction to Software Testing</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/3-Introduction%20to%20Software%20Testing/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/3-Introduction%20to%20Software%20Testing/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Introduce foundation topics of software testing</li><li>Explain test ideas</li><li>Introduce test matrices<a id="more"></a><br></li></ul></li><li><h1 id="Definition-of-Software-Testing"><a href="#Definition-of-Software-Testing" class="headerlink" title="Definition of Software Testing"></a><strong>Definition of Software Testing</strong></h1><ul><li>Software testing is a process, or a series of processes, designed to make sure computer code does what it was designed to do and that it does not do anything unintended.</li><li>Software should be predictable and consistent, presenting no surprises to users.</li><li><strong>Testing is the process of executing a program with the intent of finding errors.</strong><br><br></li></ul></li><li><h1 id="Software-testing-objectives"><a href="#Software-testing-objectives" class="headerlink" title="Software testing objectives"></a><strong>Software testing objectives</strong></h1><ul><li>在测试软件中识别和揭示尽可能多的错误</li><li>在将已识别的错误和重新测试校正后，将测试的软件带到可接受的质量水平。</li><li>在预算和调度限制内有效地执行所需的测试。</li><li>编译软件错误记录以用于错误预防（通过纠正和预防措施）。<br><br></li></ul></li><li><h1 id="Test-model"><a href="#Test-model" class="headerlink" title="Test model"></a><strong>Test model</strong></h1><img src="/img/soa/vmodel.png" alt=""><br><img src="/img/soa/wmodel.png" alt=""><br><br></li><li><h1 id="Classification-of-software-testing"><a href="#Classification-of-software-testing" class="headerlink" title="Classification of software testing"></a><strong>Classification of software testing</strong></h1><img src="/img/soa/softtest.png" alt=""><br><br></li><li><h1 id="Vital-Program-Testing-Guidelines"><a href="#Vital-Program-Testing-Guidelines" class="headerlink" title="Vital Program Testing Guidelines"></a><strong>Vital Program Testing Guidelines</strong></h1><img src="/img/soa/testguidelines.png" alt=""><br><br></li><li><h1 id="Functional-Testing"><a href="#Functional-Testing" class="headerlink" title="Functional Testing"></a><strong>Functional Testing</strong></h1><ul><li>是黑盒测试</li><li>对性能以外的任何外部可见或可测量的软件属性感兴趣。<br><br></li></ul></li><li><h1 id="Test-Ideas"><a href="#Test-Ideas" class="headerlink" title="Test Ideas"></a><strong>Test Ideas</strong></h1><ul><li>A test idea is a brief statement that identifies a test that might be useful. </li><li>A test idea differs from a test case, in that the test idea contains no specification of thetest workings, only the essence of the idea behind the test.</li><li>Test ideas are generators for test cases: potential test cases are derived from a test ideas list.</li><li>A key question for the tester or test analyst is which ones are the ones worth trying.</li></ul></li><li><h1 id="Where-Do-Test-Ideas-Come-From"><a href="#Where-Do-Test-Ideas-Come-From" class="headerlink" title="Where Do Test Ideas Come From?"></a><strong>Where Do Test Ideas Come From?</strong></h1><ul><li>Models</li><li>Specifications</li><li>Customer complaints</li><li>Brainstorm sessions among colleagues</li><li>Bug lists</li><li>Representative exemplars</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2-Software Quality</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/2-Software%20Quality/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/2-Software%20Quality/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Introduce software quality</li><li>Provide stakeholder-centric visions of quality and defect</li><li>Identify software quality assurance<a id="more"></a><br></li></ul></li><li><h1 id="Define-quality"><a href="#Define-quality" class="headerlink" title="Define quality"></a><strong>Define quality</strong></h1><ul><li><strong>Fitness for use –Dr. Joseph M. Juran</strong></li><li>The totality of features and characteristics of a product that bear on its ability to satisfy a given need –American Society for Quality</li><li>Conformance with requirements –Philip Crosby</li><li>conforms to specifications</li><li><strong>Quality is value to some person.</strong>– Gerald M. Weinberg<br><br></li></ul></li><li><h1 id="key-dimensions-of-quality"><a href="#key-dimensions-of-quality" class="headerlink" title="key dimensions of quality"></a><strong>key dimensions of quality</strong></h1><ul><li>Customer Satisfiers<ul><li>the right features</li><li>adequate instruction</li></ul></li><li>Customer Dissatisfiers<ul><li>unreliable</li><li>hard to use</li><li>too slow</li><li>incompatible with the customer’s equipment<br><br></li></ul></li></ul></li><li><h1 id="Dimensions-of-Quality-FURPS"><a href="#Dimensions-of-Quality-FURPS" class="headerlink" title="Dimensions of Quality: FURPS"></a><strong>Dimensions of Quality: FURPS</strong></h1><ul><li>Functionality<ul><li>Test the accurate workings of each usage scenario</li></ul></li><li>Usability<ul><li>Test application from the perspective of convenience to end-user.</li></ul></li><li>Reliability<ul><li>Test the application behaves consistently and predictably.</li></ul></li><li>Performance<ul><li>Test online response under average and peak loading</li></ul></li><li>Supportability<ul><li>Test the ability to maintain and support application under production use<br><br></li></ul></li></ul></li><li><h1 id="A-Broader-Definition-of-Dimensions-of-Quality"><a href="#A-Broader-Definition-of-Dimensions-of-Quality" class="headerlink" title="A Broader Definition of Dimensions of Quality"></a><strong>A Broader Definition of Dimensions of Quality</strong></h1><ul><li>Accessibility Capability Compatibility Concurrency Conformance to standards Efficiency Installability and uninstallability Localizability Maintainability Performance Portability Reliability Scalability Security Supportability Testability Usability……<br><br></li></ul></li><li><h1 id="Definition-of-SQA"><a href="#Definition-of-SQA" class="headerlink" title="Definition of SQA"></a><strong>Definition of SQA</strong></h1><ul><li>Software quality assurance (SQA) is:A systematic, planned set of actions necessary to provide adequate confidence that the software development process or the maintenance process of a software system product conforms to established functional and technical requirements as well as with the managerial requirements of keeping the schedule and operating within the budgetary confines.</li><li>系统的，有计划的一系列行动，以充分确信软件开发过程或软件系统产品的维护过程符合既定的功能和技术要求，以及在预算范围内保持计划和操作的管理要求。<br><br>     </li></ul></li><li><h1 id="SQA-system-component-classes"><a href="#SQA-system-component-classes" class="headerlink" title="SQA system component classes"></a><strong>SQA system component classes</strong></h1><ol><li>Pre-project quality components</li><li>Project life cycle quality components</li><li>Infrastructure error preventive and improvement components</li><li>Software quality management components</li><li>Standardization, certification and SQA assessment components</li><li>Organizing for SQA – the human components</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1-Software Engineering Practices</title>
      <link href="/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/1-Software%20Engineering%20Practices/"/>
      <url>/2018/12/08/Software%20Quality%20Assurance/Class%20Notes/1-Software%20Engineering%20Practices/</url>
      
        <content type="html"><![CDATA[<p><code>Some things Testers should know about them</code></p><ul><li><h1 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a><strong>Objectives</strong></h1><ul><li>Identify some common software development problems.</li><li>Identify six software engineering practices for addressing common software development problems</li></ul></li></ul><a id="more"></a><h2 id="常见的软件开发问题症状"><a href="#常见的软件开发问题症状" class="headerlink" title="常见的软件开发问题症状"></a>常见的软件开发问题症状</h2><ul><li>User or business needs not met</li><li>Requirements churn</li><li>Modules don’t integrate</li><li>Hard to maintain</li><li>Late discovery of flaws</li><li>Poor quality or poor user experience</li><li>Poor performance under load</li><li>No coordinated team effort</li><li>Build-and-release issues</li></ul><h2 id="六种软件工程实践"><a href="#六种软件工程实践" class="headerlink" title="六种软件工程实践"></a>六种软件工程实践</h2><p><strong>Develop Iteratively</strong><br><strong>Manage Requirements</strong><br><strong>Use Component Architectures</strong><br><strong>Model Visually (UML)</strong><br><strong>Continuously Verify Quality</strong><br><strong>Manage Change</strong></p><ol><li><p>Develop Iteratively </p><ul><li>瀑布模型特点</li><li>Delays confirmation of critical risk resolution</li><li>Measures progress by assessing work-products that are poor predictors of time-to-completion</li><li>Delays and aggregates integration and testing</li><li>Precludes early deployment</li><li>Frequently results in major unplanned project extensions</li></ul><ul><li>迭代模型特点<br><img src="/img/soa/iterative.png" alt=""></li><li>最早的迭代可以解决最大的风险.每次迭代都会生成可执行版本.</li><li>每次迭代都包括集成和测试。<br><strong>迭代有助于:</strong></li></ul><ul><li>在进行大量投资之前解决重大风险</li><li>实现早期客观反馈</li><li>使测试和集成持续进行</li><li>将项目重点放在可实现的短期目标里程碑上</li><li>可以部署完成的最终系统的部分实现<br><img src="/img/soa/riskprofiles.png" alt="Rick Profiles"></li></ul></li></ol><ol start="2"><li>Manage Requirements<br> <img src="/img/soa/map.png" alt=""><ul><li>为了帮助管理需求与从这些需求派生的测试之间的关系，您可以在这些元素之间建立可跟踪性关系.<br><strong>可追溯性有助于我们做很多事情，包括：</strong></li><li>评估项目对需求变更的影响</li><li>评估测试失败对需求的影响（如果测试失败，可能不满足要求）</li><li>验证应用程序是否仅执行预期的操作</li><li>验证实施是否满足系统的所有要求</li><li>管理项目范围</li><li>管理变更</li></ul></li></ol><ol start="3"><li>Component-Based Architecture<ul><li>弹性<ul><li>满足当前和未来的要求</li><li>提高可扩展性</li><li>允许重用</li><li>封装系统依赖性</li></ul></li><li>基于组件<ul><li>重用或自定义组件</li><li>从市售组件中选择</li><li>逐步发展现有软件</li></ul></li></ul></li></ol><ol start="4"><li>Model Visually (UML)<br>详情见软件分析与设计课程总结</li></ol><ol start="5"><li>Continuously Verify Quality<br>详情见软件分析与设计课程总结</li></ol><ol start="6"><li>Manage Change<ul><li>Changes to enable iterative development<ul><li>Secure workspaces for each worker</li><li>Parallel development possible</li></ul></li><li>Automated integration/build management</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Software Quality Assurance </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux简介</title>
      <link href="/2018/12/07/Linux/Class%20Notes/linux%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/12/07/Linux/Class%20Notes/linux%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="man"><a href="#man" class="headerlink" title="man"></a>man</h1><p>man （/usr/share/man）<br><a id="more"></a><br>如果输入命令 man 后英语手册页没有自动显示，则您可以使用参数LANG=en_EN来显示英语版本的手册页。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; LANG=en_EN man man</span><br></pre></td></tr></table></figure></p><p>给出关于man的具体描述，包括以下几个部分其中每个手册页标题的左右侧是命令名和手册页所属的章节号。标题的中间是章节的名称。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME          命令的名称和简短描述</span><br><span class="line">SYNOPSIS      语法的描述</span><br><span class="line">DESCRIPTION   命令的详细描述</span><br><span class="line">OPTIONS       提供的所有可用选项的描述</span><br><span class="line">COMMANDS      在程序运行时可以分配给该程序的说明</span><br><span class="line">FILES         使用某种方法连接到命令的文件</span><br><span class="line">SEE ALSO      相关命令的提示</span><br><span class="line">DIAGNOSTICS   程序可能出现的错误消息</span><br><span class="line">EXAMPLE       调用命令的示例</span><br><span class="line">BUGS          命令的已知错误和问题</span><br></pre></td></tr></table></figure><p>手册页可以分为以下不同的小节</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 可执行程序和 shell 命令（用户命令）</span><br><span class="line">2 系统调用</span><br><span class="line">3 功能和库例程</span><br><span class="line">4 设备文件</span><br><span class="line">5 配置文件和文件格式</span><br><span class="line">6 游戏</span><br><span class="line">7 宏软件包和文件格式</span><br><span class="line">8 系统管理命令</span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;man 1 crontab</span><br><span class="line">&gt;man 5 crontab</span><br></pre></td></tr></table></figure></p><p>使用命令 whatis 显示某个命令或实用程序的所有可用手册页的简短描述<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;whatis crontab</span><br></pre></td></tr></table></figure></p><h1 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h1><p>/usr/share/info/<br>Info工具是一个基于菜单的超文本系统，由GNU项目开发并由Linux发布。info工具包括一些关于Linux shell、工具、GNU项目开发程序的说明文档。与man相比，info工具可显示更完整的最新的GNU工具信息<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;info ls</span><br></pre></td></tr></table></figure></p><h1 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h1><p>“–help”是一个工具选项<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ls --help</span><br></pre></td></tr></table></figure></p><h1 id="Howto文档"><a href="#Howto文档" class="headerlink" title="Howto文档"></a>Howto文档</h1><p>/usr/share/doc/howto<br>or <a href="http://www.tldp.org/index.html" target="_blank" rel="noopener">http://www.tldp.org/index.html</a></p><h1 id="在线文档"><a href="#在线文档" class="headerlink" title="在线文档"></a>在线文档</h1><p>一些在线信息<br><a href="http://www.tldp.org" target="_blank" rel="noopener">http://www.tldp.org</a><br><a href="http://www.linux.org" target="_blank" rel="noopener">http://www.linux.org</a><br><a href="http://www.redhat.com" target="_blank" rel="noopener">http://www.redhat.com</a><br><a href="http://www.suse.com" target="_blank" rel="noopener">http://www.suse.com</a><br><a href="http://www.xfree86.org" target="_blank" rel="noopener">http://www.xfree86.org</a><br><a href="http://www.linuxplanet.com" target="_blank" rel="noopener">http://www.linuxplanet.com</a><br><a href="http://www.cert.org" target="_blank" rel="noopener">http://www.cert.org</a><br><a href="http://www.securityfocus.com" target="_blank" rel="noopener">http://www.securityfocus.com</a><br><a href="http://www.kernel.org" target="_blank" rel="noopener">http://www.kernel.org</a><br><a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><p>在以下目录中提供了大多数已安装软件包包的帮助文件：<br>/usr/share/doc/packages/package-name</p><h2 id="ls-l-查看文件的属性"><a href="#ls-l-查看文件的属性" class="headerlink" title="ls -l 查看文件的属性"></a>ls -l 查看文件的属性</h2><p>普通文件          -rw-r–r–<br>目录文件          drwxr-xr-x<br>字符设备文件      crw-rw-rw-<br>块设备文件        brw-r—–<br>套接字文件        srwxrwxrwx<br>链接文件          lrwxrwxr—<br>FIFO文件          prwxr—r– </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>学用linux</title>
      <link href="/2018/12/07/Linux/Class%20Notes/%E5%AD%A6%E7%94%A8linux/"/>
      <url>/2018/12/07/Linux/Class%20Notes/%E5%AD%A6%E7%94%A8linux/</url>
      
        <content type="html"><![CDATA[<h1 id="文件查找-find"><a href="#文件查找-find" class="headerlink" title="文件查找 find"></a>文件查找 find</h1><p>find 在命令行上搜索文件<br><a id="more"></a><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;find path criterion action</span><br></pre></td></tr></table></figure></p><p><strong>path</strong>：要搜索的文件系统部分（指定的目录及其所有子目录）。如果什么也没指定，则将使用当前目录下的文件系统。<br><strong>criterion</strong>：文件应该具有的属性：<br>-name pattern 搜索名称中包含给定模式的文件。如果模式中包含元字符或通配符，则必须用引号将它括起。否则，它将由 shell 解释，而不是由 find 解释。<br>-type file_type 搜索文件类型。适用的文件类型如下：“d”（用于目录）、“f”（用于文件）或者“l”（用于符号链接）。<br>-ctime [+/-]days 搜索恰好在指定的几天前进行上一次修改的那些文件。<br><strong>action</strong>:影响以下条件或将搜索作为一个整体进行控制的选项，例如：<br> -print<br> -exec command  可使用选项 -exec 调用其他命令<br> <em>例子</em><br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;find ~ -name kk* -type f –exec grep first &#123;&#125; \; -print</span><br></pre></td></tr></table></figure></p><p> {} 这两个括号代表找到的并传递到命令 grep 的文件名的占位符。分号用于结束 -exec指令。由于它是特殊字符，所以在它前面放一个反斜杠，以此来标记它。</p><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p> locate 是 find -name 的替代命令（必须装有软件包 findutils-locate）。首次使用要用updatedb生成/更新数据库。</p><h1 id="查找命令所在目录whereis"><a href="#查找命令所在目录whereis" class="headerlink" title="查找命令所在目录whereis"></a>查找命令所在目录whereis</h1><p> 命令 whereis 将返回二进制（选项 -b）、手册页（选项 -m）和指定命令的源代码（选项 -s）。该命令的速度比 find 快，但不如 find 全面。<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;whereis -b ls</span><br><span class="line">&gt;whereis -m ls</span><br><span class="line">&gt;whereis -s ls</span><br></pre></td></tr></table></figure></p><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p> which 将搜索在变量 PATH 中为指定命令列出的所有路径，并返回该命令的完整路径。命令 which 特别适用于以下情况：不同目录中存在某个命令的几个版本，并且您想知道在未指定路径的情况下输入时将执行哪个版本。<br> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;which find</span><br></pre></td></tr></table></figure></p><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>命令 type command 可用来查找在输入 command 时执行哪类命令，是 shell 内置命令还是外部命令。选项 -a 在文件系统中传递采用该名称的命令的所有实例。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;type type</span><br><span class="line">&gt;type grep</span><br></pre></td></tr></table></figure></p><h1 id="搜索文件内容-grep"><a href="#搜索文件内容-grep" class="headerlink" title="搜索文件内容 grep"></a>搜索文件内容 grep</h1><p>当需要查找包含特殊词、短语或项的所有文件，并且是扫描所有文件而不在编辑器中打开它们时<br><strong>&gt;grep search_pattern filename</strong><br>该命令将在文件名中进行搜索以寻找与 search_pattern 匹配的所有文本，并打印包含该模式的行。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 grep 的可用选项如下：</span><br><span class="line">    -i 忽略大小写。</span><br><span class="line">    -l 仅显示包含搜索字符串的文件的名称。</span><br><span class="line">    -r 递归地搜索整个目录树。</span><br><span class="line">    -v 给定不包含搜索字符串的所有行。</span><br><span class="line">    -n 显示行号。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;grep test  d* </span><br><span class="line">//显示所有以d开头的文件中包含test的行</span><br><span class="line">&gt;grep -n test aa bb cc</span><br><span class="line">//显示在aa，bb，cc文件中匹配test的行。</span><br></pre></td></tr></table></figure><h1 id="安装RPM包"><a href="#安装RPM包" class="headerlink" title="安装RPM包"></a>安装RPM包</h1><p>用rpm安装软件的命令格式如下：<br><strong> rpm  -i  [安装选项]  rpm 软件包名 </strong><br>安装选项有很多，常用的如下：<br>   -vh ：显示安装过程中的详细信息；<br>   –percent：显示安装进度的百分比；<br>   –test：不进行安装软件包，只进行安装测试并显示简单的报告；<br>   –force：忽略任何错误，强制安装软件包。</p><h1 id="更新、卸载RPM包"><a href="#更新、卸载RPM包" class="headerlink" title="更新、卸载RPM包"></a>更新、卸载RPM包</h1><p><strong> rpm  -u  rpm软件包名 </strong><br><strong> rpm  -e  rpm软件包名 </strong></p><p>查询已安装的包版本<br>rpm –qa |grep  软件包名</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux用户用户组和文件权限</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E5%92%8C%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux网络服务</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>NTP(network time protocol)</li><li>Linux打印服务<a id="more"></a><br></li></ul></li><li><h1 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a><strong>NTP</strong></h1><ul><li>ntp通过与时间服务器同步使本机时间与UTC(世界协调时间）同步</li><li>UTC也称为GMT（格林尼治时间）</li><li>本地时间</li><li>/etc/sysconfig/clock<ul><li>ZONE</li><li>UTC</li></ul></li><li>Linux 系统中有 2 个主要的时钟：</li><li>硬件时钟。这是一个独立于 CPU 中运行的所有控制程序而运行的时钟。也称为时间时钟、RTC、BIOS 时钟或 CMOS 时钟。</li><li>系统时间。这是 Linux 内核内部时钟的时间，并且由计时器中断驱动。</li><li>当 Linux 第一次启动时，系统时间与硬件时钟同步。之后， Linux 只使用系统时间。</li><li>date</li><li>xntp 通过提供以下服务解决同步问题：</li><li>xntp 定期根据收集到的更正数据更正本地计算机时钟。</li><li>xntp 会随时借助网络中的时间服务器更正本地时间。</li><li>xntp 支持对本地参考时钟（如无线电控制的时钟）进行管理。<br><br></li></ul></li><li><h1 id="Linux打印服务"><a href="#Linux打印服务" class="headerlink" title="Linux打印服务"></a><strong>Linux打印服务</strong></h1><ul><li>CUPS (Common Unix Printing System )<ul><li>是行式打印机守护程序Line Print Daemon (LPD)的后继，在redhat中仍使用部分LPD命令进行打印机调整与监视。</li></ul></li><li>LPD （行式打印机守护程序）<ul><li>在发送实际打印数据之前，将先发送一些与作业相关的数据，例如打印机队列。LPD 服务的端口号是 515</li></ul></li><li>IPP （因特网打印协议） <ul><li>是一个基于HTTP 协议的相对较新的（自 1999）协议。使用 IPP，所传送的与作业有关的数据比其他协议要多得多。CUPS 使用 IPP 进行内部数据传送。这是在 CUPS 服务器之间转发队列的首选协议。IPP 的端口号是 631</li></ul></li><li>SMB （服务讯息块）。CUPS 还支持在连接到 Windows 共享的打印机上进行打印，SMB 使用端口号 137、138 和 139</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux网络服务-Internet服务</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Linux%20%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1-%20Internet%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Linux%20%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1-%20Internet%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a><strong>Content</strong></h1><ul><li>Xinetd</li><li>Ftp</li><li>Http</li><li>SSH<a id="more"></a><br></li></ul></li><li><h1 id="Xinetd-Extended-Internet-Daemon"><a href="#Xinetd-Extended-Internet-Daemon" class="headerlink" title="Xinetd (Extended Internet Daemon)"></a><strong>Xinetd (Extended Internet Daemon)</strong></h1><ul><li>守护进程Daemon</li><li>运行在后台的一种特殊程序，独立于控制终端执行某种任务或者等待处理某些发生的事件，如smbd，named等</li><li>Linux的大多数服务是用守护程序实现的，守护程序打开一个端口并且监听该端口，等待客户机的连接。一旦客户机提交了连接请求，守护程序就创建一个子进程来响应，而父进程继续监听更多的服务请求。因此每个守护程序可以处理多个客户服务的请求。</li><li>服务器上的许多服务都是通过超级守护程序包 inetd 或 xinetd 来管理和启动的。</li><li>超级守护程序充当一组服务发出连接请求时的中介者。它直接接受连接请求、启动所需的服务并将请求传递到新启动的服务器。如果客户机和服务器之间的连接终止，则由  xinetd 启动的服务器将从内存中删除。</li><li>通过 inetd 启动服务既有优点也有缺点。最大的优点就是节省资源（尤其是内存），因为服务器仅在需要时才启动。但是，缺点是在装载、启动和连接所需服务时将发生延迟。</li><li>守护程序的运行方式<ul><li>独立运行的守护程序</li><li>由init脚本管理</li><li>其脚本存放在/etc/rc.d/init.d/目录下</li></ul></li><li>由Xinetd运行的守护程序<ul><li>由xinetd管理启动</li><li>服务的配置文件存放在/etc/xinetd.d/目录下</li></ul></li><li>可用pstree查看当前进程树<br><br></li></ul></li><li><h1 id="Xinetd特点"><a href="#Xinetd特点" class="headerlink" title="Xinetd特点"></a><strong>Xinetd特点</strong></h1><ul><li>强大的访问控制功能：提供对用户的审查和权限控制、限制连接数目、设定特定的连接时间</li><li>强大的日志功能：可以为每一个服务设置日志等级：为每个服务设置日志文件；记录起止时间；记录非法访问请求</li><li>专项功能：可以将客户端的请求交到另外的主机去处理</li><li>与客户端的交互功能<br><br></li></ul></li><li><h1 id="配置Xinetd"><a href="#配置Xinetd" class="headerlink" title="配置Xinetd"></a><strong>配置Xinetd</strong></h1><ul><li><strong>配置文件 /etc/xinetd.conf</strong><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认配置参数</span><br><span class="line"> defaults    为所有的服务指定缺省值</span><br><span class="line"> &#123;</span><br><span class="line">     key operator parameter parameter. . .</span><br><span class="line">     instances ＝ 60</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>includedir /etc/xinetd.d  //指明配置文件目录<br>将提示 xinetd 解释目录/etc/xinetd.d/ 中的所有文件以配置服务</p><ul><li><p><strong>配置其网络服务</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  service service_name</span><br><span class="line">  &#123;</span><br><span class="line">    key operator parameter parameter. . .</span><br><span class="line">   &#125;</span><br><span class="line">运算符有 =、-= 和 +=</span><br><span class="line">  可在目录 /etc/xinetd.d/ 中为每个服务创建一个单独的配置文件</span><br></pre></td></tr></table></figure></li><li><p><strong>例子</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service telnet&#123;</span><br><span class="line">  socket_type = stream</span><br><span class="line">  wait = no</span><br><span class="line">  user = root</span><br><span class="line">  server = /usr/sbin/in.telnetd</span><br><span class="line">  disable = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vi常见命令</title>
      <link href="/2018/12/07/Linux/Class%20Notes/Vi%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/07/Linux/Class%20Notes/Vi%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/vi/vi.png" alt="常用命令"><br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Class Notes </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android案例-弹出菜单</title>
      <link href="/2018/11/04/Android/Android%E6%A1%88%E4%BE%8B-%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/"/>
      <url>/2018/11/04/Android/Android%E6%A1%88%E4%BE%8B-%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java hljs"><figcaption><span>MainActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMenu</span><span class="hljs-params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 获取自定义的菜单布局文件</span></span><br><span class="line">        View popupWindow_view = getLayoutInflater().inflate(R.layout.menu, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>);</span><br><span class="line">        <span class="hljs-comment">// 创建PopupWindow实例,设置菜单宽度和高度为包裹其自身内容</span></span><br><span class="line">        popupWindow = <span class="hljs-keyword">new</span> PopupWindow(popupWindow_view, ActionBar.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                ActionBar.LayoutParams.WRAP_CONTENT, <span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-comment">//设置菜单显示在按钮的下面</span></span><br><span class="line">        popupWindow.showAsDropDown(findViewById(R.id.btn_menu),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-comment">// 点击其他地方消失</span></span><br></pre></td></tr></table></figure><p> menu.xml为弹出菜单</p> <a id="more"></a><a href="https://developer.android.com/reference/android/widget/PopupWindow" target="_blank" rel="noopener">文档</a><p>public class PopupWindow extends Object<br>java.lang.Object<br>   ↳    android.widget.PopupWindow</p><p>该类表示可用于显示任意视图的弹出窗口。弹出窗口是出现在当前活动顶部的浮动容器。<br>This class represents a popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity.</p><h2 id="Public-constructors"><a href="#Public-constructors" class="headerlink" title="Public constructors"></a>Public constructors</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow (View   contentView, </span><br><span class="line">                    int     width, </span><br><span class="line">                    int     height, </span><br><span class="line">                    boolean focusable)</span><br></pre></td></tr></table></figure><p> Create a new popup window which can display the contentView. The dimension of the window must be passed to this constructor.The popup does not provide any background. This should be handled by the content view. </p><p><strong>contentView</strong>:the popup’s content<br><strong>width</strong>      :the popup’s width<br><strong>height</strong>     :the popup’s height<br><strong>focusable</strong>  :true if the popup can be focused, false otherwise</p><h2 id="Public-methods"><a href="#Public-methods" class="headerlink" title="Public methods"></a>Public methods</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void showAsDropDown (View  anchor,</span><br><span class="line">                            int   xoff,</span><br><span class="line">                            int   yoff,</span><br><span class="line">                            int   gravity)</span><br></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p><strong>anchor</strong>:the view on which to pin the popup window<br><strong>xoff</strong>:A horizontal offset from the anchor in pixels<br><strong>yoff</strong>:A vertical offset from the anchor in pixels<br><strong>gravity</strong>: Alignment of the popup relative to the anchor</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml resource.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, ViewGroup root)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml node.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified XML node.</span></span></span><br><span class="line"><span class="hljs-function">View<span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource, ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">//Inflate a new view hierarchy from the specified xml resource.</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>课堂笔记</title>
      <link href="/2018/04/01/Computer%20Network/classnote/"/>
      <url>/2018/04/01/Computer%20Network/classnote/</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a><strong>Chapter 1</strong></h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>modem 调制解调器</li><li>network of networks 网间网</li><li>protocols={format,order,actions}</li><li>msg 报文</li><li>HFC hybrid fiber coax</li><li>FTTH Fiber to the Home 光纤入户</li><li>throughput :rate (bits/time unit) at which bits transferred between sender/receiver</li></ul><h2 id="Dial-up-Modem"><a href="#Dial-up-Modem" class="headerlink" title="Dial-up Modem"></a>Dial-up Modem</h2><p><img src="/img/CN/C1-1.png" alt=""></p><ul><li>使用现有的电话基础设施</li><li>家与central office 直连</li><li>无法同时上网 打电话呢 无法一直在线</li></ul><h2 id="Asymmetric-Digital-Subscriber-Line-ADSL"><a href="#Asymmetric-Digital-Subscriber-Line-ADSL" class="headerlink" title="Asymmetric Digital Subscriber Line (ADSL)"></a>Asymmetric Digital Subscriber Line (ADSL)</h2><p><img src="/img/CN/C1-2.png" alt="不对称的数字用户线ADSL"></p><ul><li>使用现有的电话基础设施</li><li>使用专用的物理线路到电话central office</li></ul><h2 id="Circuit-Switching"><a href="#Circuit-Switching" class="headerlink" title="Circuit Switching"></a>Circuit Switching</h2><h2 id="Packet-Switching"><a href="#Packet-Switching" class="headerlink" title="Packet Switching"></a>Packet Switching</h2><h2 id="Internet-protocol-stack"><a href="#Internet-protocol-stack" class="headerlink" title="Internet protocol stack"></a>Internet protocol stack</h2><ul><li><strong>application</strong>: supporting network applications<ul><li>FTP, SMTP, HTTP</li></ul></li><li><strong>transport</strong>: process-process data transfer<ul><li>TCP, UDP</li></ul></li><li><strong>network</strong>: routing of datagrams from source to destination<ul><li>IP, routing protocols</li></ul></li><li><strong>link</strong>: data transfer between neighboring  network elements<ul><li>PPP, Ethernet</li></ul></li><li><strong>physical</strong>: bits “on the wire”</li></ul><hr><h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a><strong>Chapter 2</strong></h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>Process</strong>:program running within a host</li><li><strong>Sockets</strong>:process send/receives msg to/from its socket</li><li><strong>FTP</strong>:the file transfer protocol</li></ul><h2 id="Non-Persistent-HTTP"><a href="#Non-Persistent-HTTP" class="headerlink" title="Non-Persistent HTTP"></a>Non-Persistent HTTP</h2><ul><li><strong>Response time</strong>=2RTT+ transmit time</li></ul><h2 id="Persistent-HTTP"><a href="#Persistent-HTTP" class="headerlink" title="Persistent  HTTP"></a>Persistent  HTTP</h2><ul><li><strong>Response time</strong> 第一个对象2RTT 之后的都是1RTT</li></ul><h2 id="HTTP-request-message"><a href="#HTTP-request-message" class="headerlink" title="HTTP request message"></a>HTTP request message</h2><ul><li>request line<ul><li>GET</li><li>POST</li><li>HEAD 请求头信息 PUT 放 DELETED 删除</li></ul></li><li>header lines</li><li>Carriage return, linefeed indicatesend of message</li></ul><h2 id="HTTP-response-message"><a href="#HTTP-response-message" class="headerlink" title="HTTP response message"></a>HTTP response message</h2><ul><li>status line</li><li>header line</li><li>(data)*</li></ul><h2 id="Web-Caches"><a href="#Web-Caches" class="headerlink" title="Web Caches"></a>Web Caches</h2><ul><li>Proxy Cache<ul><li>Goal:satisfy client request without involving origin server</li></ul></li><li>Client Cache<ul><li>Goal: don’t send object if cache has up-to-date cached version</li></ul></li><li>Distributed Caches<ul><li>Many caches are cooperative</li><li>Difficult to operate</li></ul></li><li>Server Caches:cluster<ul><li>High parallelism reliability</li><li>load balance needed</li><li>object location algorithm needed</li><li>广泛采用</li></ul></li></ul><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><ul><li>FTP客户端连接FTP服务器端口21,TCP是传输协议</li><li>客户端被授权控制连接</li><li>客户端通过控制连接发送命令来浏览远程目录。</li><li>当服务器接收到文件传输命令时，服务器打开第二个TCP连接(用于文件)到客户端</li><li>传输一个文件后，服务器关闭数据连接。</li></ul><h2 id="Electronic-Mail"><a href="#Electronic-Mail" class="headerlink" title="Electronic Mail"></a>Electronic Mail</h2><ul><li>3 magor components<ul><li>user agents</li><li>mail servers</li><li>SMTP(simple mail transfer protocol)</li></ul></li></ul><hr><h1 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a><strong>Chapter 3</strong></h1><hr><h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a><strong>Chapter 4</strong></h1><hr><h1 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a><strong>Chapter 5</strong></h1><hr><h1 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a><strong>Chapter 6</strong></h1>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Bootstap笔记2</title>
      <link href="/2018/02/21/%E5%AE%9E%E8%AE%AD/%E7%AC%94%E8%AE%B01/"/>
      <url>/2018/02/21/%E5%AE%9E%E8%AE%AD/%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>#模态框</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">"modal"</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#模态框id"</span>&gt;</span>触发<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--模态框主体--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modal fade"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"模态框id"</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"dialog"</span>  <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--tabindex的作用就是控制tab切换的顺序按照它的值来切换--&gt;</span></span><br><span class="line"><span class="hljs-comment">&lt;!--tabindex="-1"常用在弹框中，防止切换混乱--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Bootstap笔记1</title>
      <link href="/2018/02/18/%E5%AE%9E%E8%AE%AD/DayOne/"/>
      <url>/2018/02/18/%E5%AE%9E%E8%AE%AD/DayOne/</url>
      
        <content type="html"><![CDATA[<h1 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 Container"></a>容器 Container</h1><p>默认情况下容器是不可嵌套的<br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="Bootstrap-网格系统（Grid-System）的工作原理"><a href="#Bootstrap-网格系统（Grid-System）的工作原理" class="headerlink" title="Bootstrap 网格系统（Grid System）的工作原理"></a>Bootstrap 网格系统（Grid System）的工作原理</h1><p>网格系统通过一系列包含内容的行和列来创建页面布局<br>行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。</p><h1 id="基本的网格结构"><a href="#基本的网格结构" class="headerlink" title="基本的网格结构"></a>基本的网格结构</h1><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span><br><span class="line">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-*-*"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-*-*"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      </span><br><span class="line">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>....</span><br></pre></td></tr></table></figure><p>#偏移列<br>为了在大屏幕显示器上使用偏移，请使用 .col-md-offset-<em> 类。这些类会把一个列的左外边距（margin）增加 </em> 列，其中 * 范围是从 1 到 11。</p><p>#列排序<br>Bootstrap 网格系统另一个完美的特性，就是您可以很容易地以一种顺序编写列，然后以另一种顺序显示列。</p><p>您可以很轻易地改变带有 .col-md-push-<em> 和 .col-md-pull-</em> 类的内置网格列的顺序，其中 * 范围是从 1 到 11。</p><p>#表格<br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>为表格添加基础样式。</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>表格标题行的容器元素（<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>），用来标识表格列。</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>表格主体中的表格行的容器元素（<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>）。</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>一组出现在单行上的表格单元格的容器元素（<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> 或 <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>）。</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>默认的表格单元格。</span><br></pre></td></tr></table></figure></p><p>#表单<br>垂直或基本表单<br>基本的表单结构是 Bootstrap 自带的，个别的表单控件自动接收一些全局样式。下面列出了创建基本表单的步骤：</p><ul><li>向父 <form> 元素添加 role=”form”。</form></li><li>把标签和控件放在一个带有 class .form-group 的 <div> 中。这是获取最佳间距所必需的。</div></li><li>向所有的文本元素 <input>、<textarea> 和 </textarea><select> 添加 class =”form-control” 。</select></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实训 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
  
</search>
