{"pages":[],"posts":[{"title":"Android案例-弹出菜单","text":"MainActivity.java123456789public void OnMenu(View view){ // 获取自定义的菜单布局文件 View popupWindow_view = getLayoutInflater().inflate(R.layout.menu, null,false); // 创建PopupWindow实例,设置菜单宽度和高度为包裹其自身内容 popupWindow = new PopupWindow(popupWindow_view, ActionBar.LayoutParams.WRAP_CONTENT, ActionBar.LayoutParams.WRAP_CONTENT, true); //设置菜单显示在按钮的下面 popupWindow.showAsDropDown(findViewById(R.id.btn_menu),0,0); // 点击其他地方消失 menu.xml为弹出菜单 文档 public class PopupWindow extends Objectjava.lang.Object ↳ android.widget.PopupWindow 该类表示可用于显示任意视图的弹出窗口。弹出窗口是出现在当前活动顶部的浮动容器。This class represents a popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. Public constructors1234public PopupWindow (View contentView, int width, int height, boolean focusable) Create a new popup window which can display the contentView. The dimension of the window must be passed to this constructor.The popup does not provide any background. This should be handled by the content view. contentView:the popup’s contentwidth :the popup’s widthheight :the popup’s heightfocusable :true if the popup can be focused, false otherwise Public methods1234public void showAsDropDown (View anchor, int xoff, int yoff, int gravity) Parametersanchor:the view on which to pin the popup windowxoff:A horizontal offset from the anchor in pixelsyoff:A vertical offset from the anchor in pixelsgravity: Alignment of the popup relative to the anchor 12345678View inflate(int resource, ViewGroup root)//Inflate a new view hierarchy from the specified xml resource.View inflate(XmlPullParser parser, ViewGroup root)//Inflate a new view hierarchy from the specified xml node.View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)//Inflate a new view hierarchy from the specified XML node.View inflate(int resource, ViewGroup root, boolean attachToRoot)//Inflate a new view hierarchy from the specified xml resource.","link":"/Android/Android案例-弹出菜单/"},{"title":"个人易错点","text":"#判断是否为None12345if(flag is None): doSomething()if(not(flag is None)): doSomething()","link":"/Python/个人易错点/"},{"title":"文件逐行读入","text":"123456with open('url.txt','r') as f: linestr=[] line = f.readline().strip() while line: linestr.append(line) line = f.readline().strip()","link":"/Python/文件逐行读入/"},{"title":"代码实现-词法分析","text":"","link":"/编译原理/代码实现-词法分析/"},{"title":"循环中跳过异常","text":"123456for html in linestr : try: dosomething() except Exception as e: print(\"erro msg\") continue","link":"/Python/循环中跳过异常/"},{"title":"正规表达式与有限自动机","text":"预备知识字母表是一个非空有穷集合，通常用 ∑ 表示。字母表中的 ∑ 元素称为该字母表的 字符 character字符具有 整体性 monolith 和 可辨认性 distinguishable 字母表的运算 乘积 ∑1∑2 ＝{ab|a ∈ ∑1, b ∈ ∑2 } 幂 ∑0={ε}, ∑n= ∑n-1∑, n≥ 1。 ∑的正闭包(positive closure) ∑+=∑∪ ∑2∪ ∑3∪ ∑4∪… ∑的克林闭包(Kleene closure) ∑*= ∑0∪ ∑∪ ∑2∪ ∑3∪… = ∑0 ∪ ∑+= {ε} ∪ ∑+ 句子 对于任何x∈∑*，x即∑上的一个句子(sentence) 确定有限自动机 DFA 一个确定有限自动机(DFA)M是一个五元式:M ＝ (S,∑,δ,s0 ,F) ，其中 S是一个有限集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每个元素称为一个输入字符。 δ是一个从S×∑至S的单值部分映射。 δ(s,a)=s´意味着：当现行状态为s、输入字符为a时，将转换到下一状态s´。我们称s´为s的一个后继状态。 s0∈S是唯一的初态。 F属于S是一个终态集（可空）。 非确定有限自动机 NFA 一个非确定有限自动机（NFA） M是一个五元式：M ＝ (S,∑,δ,S0 ,F) ，其中： S是一个有限集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每个元素称为一个输入字符。 δ是一个从S×∑*至S的子集的映射，即δ:S×∑* → 2s S0属于S是一个非空初态集 F属于S是一个终态集（可空） NFA确定化DFA是NFA的特例，可以采用子集法将NFA确定化 ε_CLOSURE(I)的定义 假定I是NFA M的状态集的一个子集， 我们定义ε_CLOSURE(I)为： 若s∈I，则s∈ ε_CLOSURE(I) 若s∈I，那么从s出发经过任意条ε弧而能到达的任何状态s’都属于ε_CLOSURE(I) 状态集ε_CLOSURE(I)称为I的ε_闭包。 Ia定义 假定 I 是NFA M的状态集的子集，a ∈ ∑ ,定义 Ia=ε_CLOSURE(J) 其中，J是那些可从I中的某一状态结点出发经过一条a弧而到达的状态结点的全体。 子集算法 表的初始化构造 ∑={ a1,a2,…,ak }。先构造一张表，该表每一行含有k+1列。置该表的首行首列为ε_CLOSURE(X) 处理表的一行 如果某一行的第一列的状态子集已经确定，例如记为I,那么，求出这一行的第二个和第三个子集Ia和Ib看它们是否已 在表的第一列出现，将未出现的填入到后面空行的第一列。 重复处理 重复上述过程，直至所有第二列和第三列的子集均已在第一列上出现了为止。 DFA的化简一个确定有限自动机M的化简是指：寻找一个状态数比M少的DFA M’，使得L(M)=L(M’)。一个DFA M的状态最少化过程旨在将M的状态集分割成一些不相交的子集，使得任何不同的两个子集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的。最后，在每个子集中选出一个代表，同时消去其它等价状态。","link":"/编译原理/正规表达式与有限自动机/"},{"title":"cookie登录网页","text":"12345678910111213141516171819202122232425262728293031323334353637import urllib.requestimport http.cookiejardef login_web(): data={ \"name\": 用户名, \"passwd\": 密码, } data=urllib.parse.urlencode(data).encode('utf-8') url=\"网址\" cookie=http.cookiejar.MozillaCookieJar('cookie.txt') # 构建一个handler 处理器，利用HTTPCookieProcessor handler=urllib.request.HTTPCookieProcessor(cookie) # 利用handler处理器通过build_opener构建opner请求网络 opener=urllib.request.build_opener(handler) # 使用opener请求网络 request=urllib.request.Request(url,data,headers) response=opener.open(request) #保存cookies值 cookie.save(ignore_expires=True,ignore_discard=True) for item in cookie: print(\"Name :\"+item.name) print(\"Value :\"+item.value)def request_otherdex(url): url=url # 加载cookie cookie=http.cookiejar.MozillaCookieJar('cookie.txt') cookie.load('cookie.txt',ignore_discard=True,ignore_expires=True) # 利用urllib库的HTTPCookieProcessor构建处理器handler，此时的handler中已经包含了cookies值 handler=urllib.request.HTTPCookieProcessor(cookie) # 构建一个用于发起请求的opener opener=urllib.request.build_opener(handler) # 使用opener 发起网络请求 request=urllib.request.Request(url,headers=headers) response=opener.open(request) print(response.read())","link":"/Python/cookie登录网页/"},{"title":"Bootstap笔记2","text":"#模态框 12345&lt;button data-toggle=\"modal\" data-target=\"#模态框id\"&gt;触发&lt;/button&gt;&lt;!--模态框主体--&gt;&lt;div class=\"modal fade\" id=\"模态框id\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\"&gt;&lt;!--tabindex的作用就是控制tab切换的顺序按照它的值来切换--&gt;&lt;!--tabindex=\"-1\"常用在弹框中，防止切换混乱--&gt;","link":"/实训/笔记1/"},{"title":"Bootstap笔记1","text":"容器 Container默认情况下容器是不可嵌套的123&lt;div class=\"container\"&gt;...&lt;/div&gt; Bootstrap 网格系统（Grid System）的工作原理网格系统通过一系列包含内容的行和列来创建页面布局行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。 基本的网格结构12345678&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-*-*\"&gt;&lt;/div&gt; &lt;div class=\"col-*-*\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;.... #偏移列为了在大屏幕显示器上使用偏移，请使用 .col-md-offset- 类。这些类会把一个列的左外边距（margin）增加 列，其中 * 范围是从 1 到 11。 #列排序Bootstrap 网格系统另一个完美的特性，就是您可以很容易地以一种顺序编写列，然后以另一种顺序显示列。 您可以很轻易地改变带有 .col-md-push- 和 .col-md-pull- 类的内置网格列的顺序，其中 * 范围是从 1 到 11。 #表格12345&lt;table&gt; 为表格添加基础样式。&lt;thead&gt; 表格标题行的容器元素（&lt;tr&gt;），用来标识表格列。&lt;tbody&gt; 表格主体中的表格行的容器元素（&lt;tr&gt;）。&lt;tr&gt; 一组出现在单行上的表格单元格的容器元素（&lt;td&gt; 或 &lt;th&gt;）。&lt;td&gt; 默认的表格单元格。 #表单垂直或基本表单基本的表单结构是 Bootstrap 自带的，个别的表单控件自动接收一些全局样式。下面列出了创建基本表单的步骤： 向父 元素添加 role=”form”。 把标签和控件放在一个带有 class .form-group 的 中。这是获取最佳间距所必需的。 向所有的文本元素 、 和 添加 class =”form-control” 。","link":"/实训/笔记2/"},{"title":"MMX课内实验","text":"实验内容使用普通和 MMX 技术实现淡入淡出效果，比较其时间花费。 简介1996 年，Intel 开始将 MMX 技术引入 Pentium 产品系列，MMX 十一组用于多媒体人物的优化指令，共有 57 条新指令。这些新指令以一种 SIMD(single-instruction-multiple-data,但指令多数据)方式来处理数据。于是，它能一次在多个数据元素上同时完成加、乘这样的运算。一般，每条指令执行只用一个时钟周期。对于何时的应用，与不适用 MMX 指令相比，这些快速地并行操作能产生 2-8 倍的加速效果。随着 x86 体系结构推出 64 位的处理器，Intel 也扩展了这些指令，使它们能处理双 quadword(128 位)操作数和浮点运算。在 MMX 指令中，引入了饱和(saturation)算术。在通常的无符号算术中，在运算出现上溢时(最高位向上进位)，则此额外位会被舍掉。这被称为环绕(wraparound)运算，因为从结果上看，舍掉进位使两个数加法之和小于被加的两个数。在饱和算术中，如果加法导致上溢，减法导致下溢，那么结果分别被设置成可表示的最大值和最小值。下载地址:https://www.libsdl.org/download-2.0.php 实验环境实验所使用的软件为 Visual Studio 2017 和 SDL 2.0SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用 C 语言写成。SDL 提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台（Linux、Windows、Mac OS X 等）的应用软件。目前SDL 多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。SDL 使用 GNU 宽通用公共许可证为授权方式，意指动态链接（dynamic link 其库并不需要开放本身的源代码。 实验过程 打开Visual Studio，创建一个新的空白C++工程。 右键项目名-&gt;属性菜单-&gt;C/C++-&gt;常规-&gt;附加包含目录-&gt;选择SDL/include 文件夹 属性菜单-&gt;C/C++-&gt;代码生成-&gt;运行库-&gt;改为”多线程 DLL (/MD)” 属性菜单-&gt;Linker-&gt;常规-&gt;附加库目录-&gt;选择SDL/lib/X86 属性菜单-&gt;Linker-&gt;输入-&gt;附加依赖项-&gt;填入SDL2.lib; SDL2main.lib; 属性菜单-&gt;Linker-&gt;系统-&gt;子系统-&gt;改为未设置 如果出现找不到SDL2.lib的错误,可以尝试把SDL2.lib复制到项目的可执行文件的同一级目录下 SDL 准备工作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int SCREEN_WIDTH = 1920;const int SCREEN_HEIGHT = 1080;unsigned int len = SCREEN_WIDTH * SCREEN_HEIGHT * 4;unsigned int T = 2000;unsigned char* tar, *pic1, *pic2;SDL_Window *gWindow = nullptr;SDL_Surface *gScreenSurface = nullptr, *gpic1 = nullptr, *gpic2 = nullptr;//开始测试之前的准备工作void before() {//初始化SDL视频子系统if (SDL_Init(SDL_INIT_VIDEO) &lt; 0){ printf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError()); while (1);}//创建窗口gWindow = SDL_CreateWindow(\"SHOW BMP\",//窗口标题 SDL_WINDOWPOS_CENTERED,//窗口位置设置 SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH,//窗口的宽度 SCREEN_HEIGHT,//窗口的高度 SDL_WINDOW_SHOWN//显示窗口);if (gWindow == nullptr){ printf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError()); while (1);}//将gWindow和gScreenSurface链接gScreenSurface = SDL_GetWindowSurface(gWindow);//找到输出图像所在的位置tar = (unsigned char*)(gScreenSurface-&gt;pixels);//获取图像文件的数据大小len = gScreenSurface-&gt;h * gScreenSurface-&gt;pitch;}void after() {SDL_FreeSurface(gpic1);//释放空间SDL_FreeSurface(gpic2);gpic1 = nullptr;gpic2 = nullptr;SDL_DestroyWindow(gWindow);//销毁窗口gWindow = nullptr;SDL_Quit();//退出SDL} 普通方法123456789101112void brute_force() {int time_st = SDL_GetTicks(), cnt = 0;while (SDL_GetTicks() - time_st &lt; T) {double shade = (double)(SDL_GetTicks() - time_st) / T; //获取当前渐变进度for (unsigned int i = 0; i &lt; len; i++) { tar[i] = pic1[i] + (pic2[i] - pic1[i]) * shade;}++cnt;SDL_UpdateWindowSurface(gWindow); //完成计算后刷新图像}printf(\"FPS = %d\\n\", cnt * 1000/ T);} MMX方法1234567891011121314151617181920212223242526272829303132333435363738394041424344void mmx() {int time_st = SDL_GetTicks();int cnt = 0;while (SDL_GetTicks() - time_st &lt; T) { uint16_t ff2 = (SDL_GetTicks() - time_st) * 256 / T; uint16_t ff1 = 256 - ff2; //将4个16位整数拼在一起，当读取的时候会被当做一个64位整数进行处理 uint16_t f2[4] = { ff2,ff2,ff2,ff2 }; uint16_t f1[4] = { ff1,ff1,ff1,ff1 }; uint32_t p1, p2, *ptar; //4位的并行处理，因此循环次数位原先的四分之一 for (unsigned int i = 0; i &lt; len / 4; i++) { p1 = ((uint32_t*)pic1)[i]; p2 = ((uint32_t*)pic2)[i]; ptar = &amp;(((uint32_t*)tar)[i]); __asm {//将所需数据移入寄存器movd mm0, [p1] //load 4 pixel components from image A 把低 32位赋值给mm0movd mm1, [p2] //load 4 pixel components from image Bmov edi, ptar pxor mm7, mm7 //zero out mm7//load fade value replicated 4 timesmovq mm3, [f1] //f1的64位赋值给mm3movq mm4, [f2] //将mm0和mm1解开，构成 00XX 00XX 00XX 00XX形式punpcklbw mm0, mm7punpcklbw mm1, mm7pmullw mm1, mm4pmullw mm0, mm3//将结果相加后右移8位，再从拆开后的形式转回paddw mm0, mm1psrlw mm0, 8 //XXYY XXYY XXYY XXYY =&gt; 00XX 00XX 00XX 00XXpackuswb mm0, mm7 //00XX 00XX 00XX 00XX =&gt; XX XX XX XX//将结果传回目标位置movd[edi], mm0 } } cnt++; SDL_UpdateWindowSurface(gWindow);}printf(\"FPS = %d\\n\", cnt * 1000 / T);} 主函数1234567891011121314151617181920212223242526272829303132#include \"SDL.h\"#include &lt;iostream&gt;#include &lt;cstdio&gt;//未设置时需要这一行//系统改为 window子系统时需要注释掉#undef mainint main(int argc, char** argv) { before(); //加载图片并获取地址 gpic1 = SDL_ConvertSurface(SDL_LoadBMP(\"C:\\\\Users\\\\xiaoxin\\\\Desktop\\\\5.bmp\"), gScreenSurface-&gt;format, 0); gpic2 = SDL_ConvertSurface(SDL_LoadBMP(\"C:\\\\Users\\\\xiaoxin\\\\Desktop\\\\6.bmp\"), gScreenSurface-&gt;format, 0); pic1 = (unsigned char*)(gpic1-&gt;pixels); pic2 = (unsigned char*)(gpic2-&gt;pixels); //surface的快速复制 SDL_BlitSurface(gpic1, nullptr, gScreenSurface, nullptr); SDL_UpdateWindowSurface(gWindow);//更新显示 SDL_Delay(1000); SDL_BlitSurface(gpic2, nullptr, gScreenSurface, nullptr); SDL_UpdateWindowSurface(gWindow);//更新显示 SDL_Delay(1000); brute_force(); mmx(); SDL_Delay(15000); after(); return 0;} 运行结果 图片1 渐变 渐变 图片2 FPS 比较","link":"/计算机组成原理/MMX/"},{"title":"机组期末总结","text":"Organization &amp; Architecture Computer architecture 允许我们使用制造技术有效地实现信息处理应用程序的 抽象层的设计 对程序员可见 直接影响程序的逻辑执行 概念结构和功能特征 Computer Organization 体系结构中指定的 实现 和 互连 的操作单元（or 组件） 系统设计者可见 架构的的一种实现 计算机顶级视图 von Neuman architecture 3个重要概念 Data and instruction are stored in a single read-write memory The contents of the memory are addressed by location Execution occurs in a sequential fashion 指令周期 取指周期 处理器取指 From Memory Located by PC PC++ 指令-&gt; Instruction Register 处理器对指令译码并执行所需的操作 执行周期 CPU与主存 进行数据交换 CPU与IO模块 进行数据交换 数据处理 控制(jump等) 或以上组合 指令的流程 指令地址计算 取指 指令译码 ||:操作数地址计算 取操作数:|| 数据操作 ||:操作数地址计算 存操作数:|| 检查中断 有则执行中断||:反复的意思:|| 中断 允许其他模块中断CPU执行顺序的机制 提高CPU的实用性 允许CPU处理紧急事件 包括 程序中断 Timer中断 IO中断 硬件失效中断 Multiple Interrupts 中断被中断了 怎么办呢 不管新中断 定义优先级 Interconnection structures:The collection of paths connecting of {主存,IO模块,CPU} 总线:communication paths connecting two or more components 系统总线 数据总线 数据总线带宽=机器字长=寄存器长 地址总线 带宽决定有多少memory 控制总线 总线仲裁 不止一个模块连着总线,但一次只能有一个模块控制着 集中式仲裁:有个控制器决定哪个模块占用总线 Daisy chain polling 优:可扩展性好 缺:电路故障敏感 Counter timing polling 优:灵活优先 电路故障不敏感 缺:控制复杂 Separate request 优:反应快 灵活优先 缺:控制复制 线太多 分布式仲裁:没有控制器决定,每个模块都包含对总线的访问控制逻辑 总线的通讯控制模块 通讯控制:解决如何开始和结束传输,如何协调主从模块 CacheWhy Cache?局部性原理. 直接映射 i = j mod m i是cache行j是主存块号m是cache总行 关联映射 组关联映射 Internal Memory RAMrandom-access memory Dynamic RAM bits 存在电容器中 通电时也要刷新 结构简单 便宜 功耗低 慢 写 Bit line 给电压 高 1 低 0 电荷传给电容器 读 Address line 选中 电荷从电容器-&gt;bit line-&gt;放大器 比较 0 或 1 电容器必须回写 Static RAM 晶体管布置提供了稳定的逻辑状态 state 1 C1 high, C2 low T1 T4 off, T2 T3 on state 0 C2 high, C1 low T2 T3 off, T1 T4 on T5 T6是开关 DRAM SRAM 两者对比 都不稳定 需要充电才能存数据 DRAM:容易实现 小 更密集 便宜 需要刷新 容量更大 SRAM:快 当cache ROM 永久存储 只读 不可写 只要有一位错了 整个芯片用不了了 应用:微程序 库子程序 BIOS PROM 可编程的ROM 编写需要特殊设备 灵活 便捷 External Memory 如何找到扇区呢? 通过格式化磁盘将额外数据（控制数据）放入扇区 标记轨道和扇区等待IO设备和等待IO通道的时间是不确定的. 寻道时间 seek time 找到相关数据的轨道头 时间不确定(启动磁头臂的时间 加速和遍历轨道的时间) 估算公式: T= S + n * M S 开始时间 n 遍历轨道 m 与磁盘驱动相关的常数 旋转延迟 Rotational delay 一般取平均延迟 传输时间 Transfer time ①需要传输的字节数 ② 旋转速度 T = b/(rN) b 要传输的字节数 N 轨道上的字节数 r 旋转速度 rpm/60 访问时间 access time 上三者相加 RAID Redundant Array of Independent Disks 通过OS将一组物理磁盘视为单个逻辑驱动器 跨物理驱动器分布的数据 可以使用冗余容量来存储奇偶校验信息 RAID 0 无冗余 数据条跨所有磁盘 提升速度:多个数据请求可能不在同一磁盘上.磁盘并行寻求.一组数据可能跨多个磁盘进行条带化 应用:高数据传输能力.高IO请求 RAID 1 数据条跨磁盘 每个磁盘条2个副本位于不同的磁盘上 读1 写2 恢复简单,容错性好.如果读取请求率高,则其性能是RAID0的两倍 贵 应用:存储系统软件或数据非常重要的文件 RAID 2 未实现 所有磁盘是同步的,任何时候磁头位于所有磁盘的相同位置 非常小的磁盘条,单个字节或字 并行访问数据和奇偶校验 非常多冗余 RAID 3 与RAID2 相似 只有一个冗余磁盘. 可以从幸存的数据和奇偶校验信息重建有关故障驱动器的数据 very high transfer rates 一次只能执行一个IO请求 例:5个磁盘阵列,X0~X3表示数据,X4表示奇偶校验.X4（i）= X3（i）⊕X2（i）⊕X1（i）⊕X0（i）如果X0损坏,则上述等式异或两侧X4（i）⊕X0（i）X0（i）= X4（i）⊕X3（i）⊕X2（i）⊕X1（i） RAID 4 与RAID2 类似 但是磁盘条更大 每个磁盘独立运行 适用于高IO请求 Bit by bit parity calculated across stripes on each disk 奇偶校验存储在奇偶校验磁盘上 磁盘条上1次写请求则最少需要2次读2次写操作 奇偶校验磁盘成为瓶颈 RAID 5 与RAID4 类似 常用于网络服务器 RAID 6 两种不同的奇偶校验计算,存储在不同磁盘上的单独条带中 极高的数据可用性,即使两个条带发生故障也可以恢复 写惩罚 Input/Output Why IO模块? 种类繁多的外围设备 提供不同数量的数据 以不同的速度 根据不同的时序 以不同的格式 都慢于CPU和RAM 外围设备不直接连接到系统总线 需要IO模块计算机 磁盘驱动 一种是与IO模块进行数据 控制 和状态信号交换 另一种是用于控制磁盘读写机制 IO模块的功能 控制和计时 CPU ~ IO 通信 设备 ~ IO 通信 内存 ~ IO 通信 数据缓冲 错误检测 IO steps CPU检查IO模块和设备状态 IO模块返回状态 如果准备好,CPU请求数据传输 IO模块从设备获取数据 IO模块将数据传输到CPU IO Communication 命令解码： 读取扇区 搜索轨道 扫描ID 可以读取或写入哪些块。 数据交换 外部数据 -&gt; IO模块buffer By 本地总线 IO模块buffer -&gt; CPU/内存 By 系统总线 状态报告 busy ready error etc. 地址识别 识别每个外围设备 数据缓冲 Data Buffering 使外围设备适应CPU/主存的速度 CPU/DRAM IO buffer IO buffer 外围设备 错误检测 Error Detection IO模块通常负责错误检测并向CPU报告错误 硬件故障:卡纸 坏的磁盘轨道 传输错误:bit错误 数据丢失 … 输入输出模式 Programmed IO 中断驱动IO 直接内存访问（DMA） IO通道 IO处理器 Programmed IO和中断驱动IO的缺点 Programmed IO需要占用所有CPU时间 中断驱动的IO仍需要主动CPU干预,但CPU使用率比Programmed IO更高（传输速率更低） 在这两种模式下,数据传输必须遍历CPU 转移率有限 CPU被捆绑了 传输大量数据时,DMA是一种更有效的技术 DMA 在CPU外部 总线上的附加模块（硬件） DMA控制器从CPU接管IO. 无需CPU干预即可将数据块传输到内存或从内存传输 实际上,DMA也是一个IO模块 Act as a maser on the bus Memory system acts like slave 管理字节-字转换 优先级：DMA &gt; CPU CPU和DMA之间的三种数据传输模式： 块传输模式（垄断模式） 整个数据块以一个连续的顺序传输 如果DMA传输数据,CPU将被禁用一段时间,直到DMA释放总线 用于将程序或数据文件加载到内存中 Cycle stealing mode DMA仅在CPU不需要时才使用总线或强制CPU暂时暂停操作 DMA传输一个数据字,然后释放总线 DMA交错指令和数据传输 透明模式（备用模式） DMA and CPU use bus by division time multiplexing 需要大部分时间,但效率最高 DMA操作 预处理：CPU告诉DMA控制器 读/写 设备地址 数据存储块的起始地址 要转移的数据量 CPU继续进行其他工作 数据传输：DMA控制器处理传输（逐字） 后处理：DMA控制器在完成后发送中断 DMA Transfer Cycle Stealing DMA控制器接管总线一个周期 传输一个字的数据 不是中断 因为CPU不切换上下文 CPU在访问总线之前就suspended 即在 取指 或 取操作数 或 数据写入 之前 (指令的流程) 减慢CPU速度但不会像CPU那样进行传输 DMA Configurations 单总线,独立DMA控制器 每次传输需要用到总线2次. IO-&gt;DMA DMA-memory CPU suspended 2次 单总线,集成DMA控制器 控制器支持&gt;1个设备 每次传输需要用到总线1次 DMA-&gt;memory CPU suspended 1次 单独的IO总线 每次传输需要用到总线1次 DMA-&gt;memory CPU suspended 1次 IO 通道 IO通道是一个IO模块,具有自己的处理器,可以执行IO程序.IO程序位于主存中.实际上,IO通道代表了DMA概念的扩展.因此,IO通道具有执行IO指令和控制IO操作的能力. 功能: 从CPU接受命令(微指令) 从内存加载IO程序,并给设备发送命令 记录设备状态和中断 Buffer, control and transfer data, provide path for transferring 流程: CPU发送IO命令 并等待 IO通道和设备ready -&gt; CPU开启通道 返回主程序 -&gt; 通道执行IO程序以在存储器和设备之间传输数据-&gt;数据传输完成后,中断CPU Computer Arithmetic Instruction Sets: Characteristics and FunctionsInstruction Sets: Addressing Modes and FormatsCPU Structure and FunctionReduced Instruction Set ComputersInstructionLevel Parallelism and Superscalar ProcessorsControl Unit Operation","link":"/计算机组成原理/summary/"},{"title":"Linux用户用户组和文件权限","text":"","link":"/Linux/课堂笔记/Linux用户用户组和文件权限/"},{"title":"Vi常见命令","text":"","link":"/Linux/课堂笔记/Vi常见命令/"},{"title":"Linux网络服务-Internet服务","text":"Content Xinetd Ftp Http SSH Xinetd (Extended Internet Daemon) 守护进程Daemon 运行在后台的一种特殊程序，独立于控制终端执行某种任务或者等待处理某些发生的事件，如smbd，named等 Linux的大多数服务是用守护程序实现的，守护程序打开一个端口并且监听该端口，等待客户机的连接。一旦客户机提交了连接请求，守护程序就创建一个子进程来响应，而父进程继续监听更多的服务请求。因此每个守护程序可以处理多个客户服务的请求。 服务器上的许多服务都是通过超级守护程序包 inetd 或 xinetd 来管理和启动的。 超级守护程序充当一组服务发出连接请求时的中介者。它直接接受连接请求、启动所需的服务并将请求传递到新启动的服务器。如果客户机和服务器之间的连接终止，则由 xinetd 启动的服务器将从内存中删除。 通过 inetd 启动服务既有优点也有缺点。最大的优点就是节省资源（尤其是内存），因为服务器仅在需要时才启动。但是，缺点是在装载、启动和连接所需服务时将发生延迟。 守护程序的运行方式 独立运行的守护程序 由init脚本管理 其脚本存放在/etc/rc.d/init.d/目录下 由Xinetd运行的守护程序 由xinetd管理启动 服务的配置文件存放在/etc/xinetd.d/目录下 可用pstree查看当前进程树 Xinetd特点 强大的访问控制功能：提供对用户的审查和权限控制、限制连接数目、设定特定的连接时间 强大的日志功能：可以为每一个服务设置日志等级：为每个服务设置日志文件；记录起止时间；记录非法访问请求 专项功能：可以将客户端的请求交到另外的主机去处理 与客户端的交互功能 配置Xinetd 配置文件 /etc/xinetd.conf123456默认配置参数 defaults 为所有的服务指定缺省值 { key operator parameter parameter. . . instances ＝ 60 } includedir /etc/xinetd.d //指明配置文件目录将提示 xinetd 解释目录/etc/xinetd.d/ 中的所有文件以配置服务 配置其网络服务 123456 service service_name { key operator parameter parameter. . . }运算符有 =、-= 和 += 可在目录 /etc/xinetd.d/ 中为每个服务创建一个单独的配置文件 例子 1234567service telnet{ socket_type = stream wait = no user = root server = /usr/sbin/in.telnetd disable = no}","link":"/Linux/课堂笔记/Linux 网络服务- Internet服务/"},{"title":"Linux网络服务","text":"Content NTP(network time protocol) Linux打印服务 NTP ntp通过与时间服务器同步使本机时间与UTC(世界协调时间）同步 UTC也称为GMT（格林尼治时间） 本地时间 /etc/sysconfig/clock ZONE UTC Linux 系统中有 2 个主要的时钟： 硬件时钟。这是一个独立于 CPU 中运行的所有控制程序而运行的时钟。也称为时间时钟、RTC、BIOS 时钟或 CMOS 时钟。 系统时间。这是 Linux 内核内部时钟的时间，并且由计时器中断驱动。 当 Linux 第一次启动时，系统时间与硬件时钟同步。之后， Linux 只使用系统时间。 date xntp 通过提供以下服务解决同步问题： xntp 定期根据收集到的更正数据更正本地计算机时钟。 xntp 会随时借助网络中的时间服务器更正本地时间。 xntp 支持对本地参考时钟（如无线电控制的时钟）进行管理。 Linux打印服务 CUPS (Common Unix Printing System ) 是行式打印机守护程序Line Print Daemon (LPD)的后继，在redhat中仍使用部分LPD命令进行打印机调整与监视。 LPD （行式打印机守护程序） 在发送实际打印数据之前，将先发送一些与作业相关的数据，例如打印机队列。LPD 服务的端口号是 515 IPP （因特网打印协议） 是一个基于HTTP 协议的相对较新的（自 1999）协议。使用 IPP，所传送的与作业有关的数据比其他协议要多得多。CUPS 使用 IPP 进行内部数据传送。这是在 CUPS 服务器之间转发队列的首选协议。IPP 的端口号是 631 SMB （服务讯息块）。CUPS 还支持在连接到 Windows 共享的打印机上进行打印，SMB 使用端口号 137、138 和 139","link":"/Linux/课堂笔记/Linux网络服务/"},{"title":"Linux简介","text":"manman （/usr/share/man）如果输入命令 man 后英语手册页没有自动显示，则您可以使用参数LANG=en_EN来显示英语版本的手册页。1&gt; LANG=en_EN man man 给出关于man的具体描述，包括以下几个部分其中每个手册页标题的左右侧是命令名和手册页所属的章节号。标题的中间是章节的名称。 12345678910NAME 命令的名称和简短描述SYNOPSIS 语法的描述DESCRIPTION 命令的详细描述OPTIONS 提供的所有可用选项的描述COMMANDS 在程序运行时可以分配给该程序的说明FILES 使用某种方法连接到命令的文件SEE ALSO 相关命令的提示DIAGNOSTICS 程序可能出现的错误消息EXAMPLE 调用命令的示例BUGS 命令的已知错误和问题 手册页可以分为以下不同的小节 123456781 可执行程序和 shell 命令（用户命令）2 系统调用3 功能和库例程4 设备文件5 配置文件和文件格式6 游戏7 宏软件包和文件格式8 系统管理命令 例如12&gt;man 1 crontab&gt;man 5 crontab 使用命令 whatis 显示某个命令或实用程序的所有可用手册页的简短描述1&gt;whatis crontab Info/usr/share/info/Info工具是一个基于菜单的超文本系统，由GNU项目开发并由Linux发布。info工具包括一些关于Linux shell、工具、GNU项目开发程序的说明文档。与man相比，info工具可显示更完整的最新的GNU工具信息1&gt;info ls –help“–help”是一个工具选项1&gt;ls --help Howto文档/usr/share/doc/howtoor http://www.tldp.org/index.html 在线文档一些在线信息http://www.tldp.orghttp://www.linux.orghttp://www.redhat.comhttp://www.suse.comhttp://www.xfree86.orghttp://www.linuxplanet.comhttp://www.cert.orghttp://www.securityfocus.comhttp://www.kernel.orghttp://man.linuxde.net/ 在以下目录中提供了大多数已安装软件包包的帮助文件：/usr/share/doc/packages/package-name ls -l 查看文件的属性普通文件 -rw-r–r–目录文件 drwxr-xr-x字符设备文件 crw-rw-rw-块设备文件 brw-r—–套接字文件 srwxrwxrwx链接文件 lrwxrwxr—FIFO文件 prwxr—r–","link":"/Linux/课堂笔记/linux简介/"},{"title":"1-Function testing","text":"Function testing 也叫黑盒单元测试 针对每个功能单元进行的一种黑盒测试。 测试人员 可以是任何人：编码人员、测试人员等 覆盖程度 覆盖所有的功能以及用户可见的变量 测试的目的 为了使每个功能能够单独运作 测试方法 穷举法 边界值分析法 基于单/多缺陷假设设计测试样例 等价类划分法 典型数据法 … 如何分析结果 寻找同类功能做对比.同类功能：例如显卡的功能测试，找同类显卡，在相同的输入条件下比较输出结果。 复杂程度 对已实现的各个功能设计测试样例进行测试 严格程度 指测试方法对软件错误的容忍程度，即其发现软件错误的能力大小 对系统完成度的要求 每一个功能单元完成后便可以进行功能测试 优点 对每个测试项目进行全面分析 Easy to do as each function is implemented 缺点 Misses interactions Misses exploration of the benefits offered by the program","link":"/软件质量保证/Individual techniques/1-Function testing/"},{"title":"学用linux","text":"文件查找 findfind 在命令行上搜索文件1&gt;find path criterion action path：要搜索的文件系统部分（指定的目录及其所有子目录）。如果什么也没指定，则将使用当前目录下的文件系统。criterion：文件应该具有的属性：-name pattern 搜索名称中包含给定模式的文件。如果模式中包含元字符或通配符，则必须用引号将它括起。否则，它将由 shell 解释，而不是由 find 解释。-type file_type 搜索文件类型。适用的文件类型如下：“d”（用于目录）、“f”（用于文件）或者“l”（用于符号链接）。-ctime [+/-]days 搜索恰好在指定的几天前进行上一次修改的那些文件。action:影响以下条件或将搜索作为一个整体进行控制的选项，例如： -print -exec command 可使用选项 -exec 调用其他命令 例子 1&gt;find ~ -name kk* -type f –exec grep first {} \\; -print {} 这两个括号代表找到的并传递到命令 grep 的文件名的占位符。分号用于结束 -exec指令。由于它是特殊字符，所以在它前面放一个反斜杠，以此来标记它。 locate locate 是 find -name 的替代命令（必须装有软件包 findutils-locate）。首次使用要用updatedb生成/更新数据库。 查找命令所在目录whereis 命令 whereis 将返回二进制（选项 -b）、手册页（选项 -m）和指定命令的源代码（选项 -s）。该命令的速度比 find 快，但不如 find 全面。 123&gt;whereis -b ls&gt;whereis -m ls&gt;whereis -s ls which which 将搜索在变量 PATH 中为指定命令列出的所有路径，并返回该命令的完整路径。命令 which 特别适用于以下情况：不同目录中存在某个命令的几个版本，并且您想知道在未指定路径的情况下输入时将执行哪个版本。 1&gt;which find type命令 type command 可用来查找在输入 command 时执行哪类命令，是 shell 内置命令还是外部命令。选项 -a 在文件系统中传递采用该名称的命令的所有实例。12&gt;type type&gt;type grep 搜索文件内容 grep当需要查找包含特殊词、短语或项的所有文件，并且是扫描所有文件而不在编辑器中打开它们时&gt;grep search_pattern filename该命令将在文件名中进行搜索以寻找与 search_pattern 匹配的所有文本，并打印包含该模式的行。123456命令 grep 的可用选项如下： -i 忽略大小写。 -l 仅显示包含搜索字符串的文件的名称。 -r 递归地搜索整个目录树。 -v 给定不包含搜索字符串的所有行。 -n 显示行号。 1234&gt;grep test d* //显示所有以d开头的文件中包含test的行&gt;grep -n test aa bb cc//显示在aa，bb，cc文件中匹配test的行。 安装RPM包用rpm安装软件的命令格式如下： rpm -i [安装选项] rpm 软件包名 安装选项有很多，常用的如下： -vh ：显示安装过程中的详细信息； –percent：显示安装进度的百分比； –test：不进行安装软件包，只进行安装测试并显示简单的报告； –force：忽略任何错误，强制安装软件包。 更新、卸载RPM包 rpm -u rpm软件包名 rpm -e rpm软件包名 查询已安装的包版本rpm –qa |grep 软件包名","link":"/Linux/课堂笔记/学用linux/"},{"title":"10-Stochastic or Random Test","text":"Content What Why 特点 随机测试 黑盒测试 输入:Random，independent 输出:Compared against software specifications to verify that the test output is pass or fail 测试过程：自动化 覆盖范围：广泛但浅显 Why 随机测试可以让我们轻松的根据测试结果估算软件可靠性。 可以从随机测试中获得数据用于估计软件的可靠性(其他测试方法不能用这种方式来估算软件可靠性） 相比于其他更为周到的测试方法，可以节约精力和时间 特点 无需任何特定测试 在无文档、无计划下的软件测试 可以发现测试用例覆盖不到的bug 随机测试几乎可以在任何时候进行 测试软件的鲁棒性 发现低优先级高严重性的bug 对比与模糊测试的区别： 模糊测试：随机数据 随机测试：随机行为与探索性测试的区别： 随机测试：思维过程无序 探索性测试：思维过程具有有序性、合理性","link":"/软件质量保证/Individual techniques/10-Stochastic or Random Test/"},{"title":"5-Stress Testing","text":"Content 压力测试简述 压力测试特点 压力测试步骤 压力测试实例 Stress Testing 是指不断给被测系统增加压力，直到被测系统被压垮，并在系统被压垮的情况下持续测试。 以确定系统能承受的最大压力以及系统是否具有良好的容错能力和可恢复能力。 压力测试的特点 测试者：在软件压力测试方面具备专业知识和一定的操作技能的人 代码覆盖率：部分覆盖，难以界定是否覆盖完全 测试阶段：开发项目接近完成 粗颗粒度：压力测试极其粗糙 复杂性：根据软件自身的需求有所不同 优点 能暴露系统可能出现的缺陷 能暴露系统的安全风险 可能对评估性能、可靠性或效率有帮助 局限性 缺陷可能在压力测试下并不明显 当不知道问题的大致区间时，压力测试就会比较慢 易出现“不知道因为什么导致了问题”和“有没有遗漏什么”的问题 压力测试的步骤 Identify the Test Environment 确认测试环境 Identify Performance Acceptance Criteria 确认性能指标 Plan and Design Tests 计划并设计测试 Configure the Test Environment 配置测试环境 Implement the Test Design 实现设计好的测试 Execute the Test 执行测试 Analyze Results, Report, and Retest 分析、报告、重复测试 压力测试与其他测试的关系常见的测试有：负载测试、压力测试和性能测试。三者测试目的不同，但其手段和方法在一定程度上比较相似，通常会使用相同的测试环境和测试工具，而且都会监控系统所占用资源的情况以及其它相应的性能指标。 tester：三者都应该具有一定的专业水平 coverage：三者均为部分覆盖，存在局限性，难以确定是否覆盖了所有可能的缺陷 potential problem：压力测试是期望系统崩溃；负载测试是期望得到系统的响应时间和质量；性能测试时为了了解应用程序在常规参数下的行为方式 activities：压力测试往往要增加比负载测试多的并发用户，一般要比系统设计的并发量大，而性能测试验证产品资源的使用情况，可用性及可靠性 evaluation：压力测试是看服务器能否在崩溃后自我恢复，任何意外故障是否会损害系统安全性；负载测试是看系统的响应时间和质量是否符合设计要求及当前的基础设施是否足以运行应用程序；性能测试是看系统是否符合业务的性能需求，验证该应用程序能否正常运行 focus：性能测试的关注点在于程序运行的响应时间和并发量，负载测试的关注点在于系统并发量的多少，而压力测试更关注在超过了系统极限值的限制范围后系统的影响。","link":"/软件质量保证/Individual techniques/5-Stress Testing/"},{"title":"2-Equivalence analysis","text":"Content 等价类划分 等价类划分指南 等价类划分实例 等价类 等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的。 等价类划分 等价类划分，指一种典型的、重要的黑盒测试方法，它将程序所有可能的输入数据划分为若干个等价类。然后从每个部分中选取具有代表性的数据当做测试用例。利用这一方法设计测试用例可以不考虑程序的内部结构，以需求规格说明书为依据，选择适当的典型子集，认真分析和推敲说明书的各项需求，特别是功能需求，尽可能多地发现错误。等价类划分法是一种系统性的确定要输入的测试条件的方法。 有效等价类划分 有效等价类指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个，根据系统的输入域划分若干部分，然后从每个部分中选取少数有代表性数据当做数据测试的测试用例，等价类是输入域的集合。 以下是对有效等价类数据集的一些例子： 终端用户输入的命令 与最终用户交互的系统提示 接受相关的用户文件的名称 提供初始化值和边界等 提供格式化输出数据的命令 在图形模式（比如鼠标点击时）提供的数据 失败时显示的回应消息 无效等价类划分 无效等价类和有效等价类相反，无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。利用无效等价类，可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。 以下是无效等价类数据集的一些例子： 终端在一个不正确的地方提供适当的值 验证外部边界的值 验证与边界和外部边界值的数值数据 等价类划分指南 等价类划分的方法 输入条件制定了一个域 输入条件指定了一组值的集合: 为集合中的每个元素创建一个等价类，为一个无效输入也创建一个等价类 输入条件指定了每一个单独的值：如果系统对每一个有效输入的处理都不同，那么为每一个有效输入创建一个等价类 输入条件指定了有效值的数量：为正确的输入数量创建一个等价类，为无效输入创建两个等价类——一个数量为零，一个比N大 输入条件指定了一个必须值：为该必须值创建一个等价类，为非必须值创建一个等价类 分割等价类：如果系统以不同方式处理一个划分好的等价类中的元素，那么分割该等价类为更小的等价类 从等价类中识别测试用例 为每个等价类指定一个唯一的标识符 对于每个还未被测试用例覆盖到的有效输入等价类，生成新的测试用例，尽量多地覆盖还未覆盖到的等价类，按照这一步骤重复进行，直到所有的有效等价类都被覆盖为止 对于每个还未被测试用例覆盖到的无效输入等价类，生成新的测试用例，仅覆盖一个还未覆盖到的等价类，按照这一步骤重复进行，直到所有的无效等价类都被覆盖为止。 等价类划分实例Ex A申请账号时，用户必须输入用户名、密码、确认密码，对每一项输入条件要求如下：用户命要求为6位以上，18位以下，使用英文字母、数字、“-”、“”,并且首字符必须为字母或数字；密码在6~16位之间，只能用英文字母、数字、“-”、“”,并且区分大小写。列出等价类表和测试用例。 等价类表：等价类的测试用例： Ex B一个程序读入3个整数，把这3个数值看作一个三角形的3条边的长度值。这个程序要打印出信息，说明这个三个数值不构成三角形、或是一般三角形、或是等腰的三角形、或是等边三角形。列出等价类表和测试用例。分析题目中给出和隐含的对输入条件的要求： 整数 2. 三个数 3. 非零数 4. 正数 5. 两边之和大于第三边 6.等腰 7. 等边如果a、b、c满足条件1~4，则输出下列四种情况之一：1）如果不满足条件5，则程序输出为“非三角形”2）如果三条边相等即满足条件7，则程序输出为“等边三角形”3）如果只有两条边相等，及满足条件6，则程序输出为“等腰三角形”4）如果三条边都不相等，则程序输出为“一般三角形”等价类表覆盖有效等价类的测试用例覆盖无效类等价类的测试用例","link":"/软件质量保证/Individual techniques/2-Equivalence analysis/"},{"title":"3-Specification-based testing","text":"定义 黑盒测试、功能测试、数据驱动测试 测试者不了解程序的内部情况，不需具备应用程序的代码、内部结构和编程语言的专门知识。只知道程序的输入、输出和系统的功能，这是从用户的角度针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。 基本属性 目标：核验需求文档里每个要求的一致性。 测试者：可以任何人。 覆盖内容：文档化的需求以及一些特性。 潜在问题：实现与规格不匹配的问题。 评估方法：实现是否与规格匹配。 复杂度：由规格说明书决定 苛刻度：有规格说明书决定 如何在缺少规格说明书的情况下获取信息?有什么可行的替代方法？ 在缺少规格说明书或者是规格说明书不正确的时候可以使用使用如下资源 软件更新备忘录 用户手册草稿 产品资料 已发布的样式指南和UI标准 已发布的标准 第三方产品兼容性测试套件 内部备忘录 营销展示、产品概念 Bug报告 逆向工程 …. 规格说明 规格说明书要求做到精确和细化需求中描述的系统功能性需求和约束。 规格说明是为了技术人员编写的 规格说明书的形式可以是多种多样的。下面列出几个常见的规格说明书形式： 需求文档 用例 模型 形式化方法 原型 …","link":"/软件质量保证/Individual techniques/3-Specification-based testing/"},{"title":"11-structual testing","text":"DD-path覆盖 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的每个DD路径，则它们构成DD路径覆盖。 branch覆盖 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的决策（predicate）的每个分支（输出），则它们构成分支覆盖。 path coverage 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中从源节点到汇聚节点的每条路径，则它们构成路径覆盖。 node coverage 如果在程序上执行时，遍历程序图中的每个节点，则它们构成节点覆盖。 edge coverage 遍历程序图中的每个边，则它们构成边缘覆盖。语句覆盖使所有的判断语句都能执行一次的条件案例，例如当判断语句事组合语句的时候，并且用or连接，只满足一个案例即可判定覆盖（分支覆盖）针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况条件覆盖针对判断语句里面案例的取值都要去一次，不考虑条件的取值判定/条件覆盖判定覆盖各条件覆盖交叉，针对于判定中的条件取值组合覆盖判定-条件覆盖的加强版","link":"/软件质量保证/Individual techniques/11-structual testing/"},{"title":"4-Risk-based Testing","text":"Content Targets, concept and benefits of RBT Risk and Risk management Risk-based testing approach Risk-based testing in practice Risk matrix and Risk reporting Risk-based testing and test automation Why Risk-based Testing? Software projects are very rarely on time,schedule or budget. Very often early project phases are delayed. When eventually comes down to testing, the time to delivery is extremely short and there is no budget left due to the development overrun. During development everybody is as a rule extremely busy resulting the test preparation activities not receiving the appropriate attention. RBT RBT(Risk-based Testing) is a test method deciding the test strategy by analyzing and accessing the risk of product. Reduced resource consumption(i.e., more efficient testing) Improved quality by spending more time on critical functions. Risk and Risk management Risk Identification Risk Strategy Risk Assessment Risk Mitigation Risk Reporting","link":"/软件质量保证/Individual techniques/4-Risk-based Testing/"},{"title":"8-User Testing","text":"用户测试 定义：以用户为为参与主体的测试 引入原因：用户作为软件最终使用的主体 测试目标：测试软件的总体情况及用户体验 测试者：用户 覆盖面：很难度量 测试启动时间：软件开发基本完成 优点 暴露设计的问题 能找到高错误率的区域 测试过程能够被监控 能够通过内部实验室注意有争议的区域 缺点 覆盖面不能够保证 测试用例弱 结果好坏不一 必须区分营销测试与技术测试","link":"/软件质量保证/Individual techniques/8-User Testing/"},{"title":"6-Regression testing","text":"回归测试（Regression testing） 指在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，软件产生新版本都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。 回归测试通常被认为是“程序的重新确认”； “纠正型回归测试”指对程序修改后进行回归测试； “增量型回归测试”指程序增加新特性后进行测试。 回归测试多余？ 开发人员也可以通过适当的证据证明新增的方法对原方法没有影响，这种情况下回归测试是多余的。 必须进行回归测试的情况 当对软件的一个子系统进行修改，得到软件的一个新版本，此时回归测试是必需的； 当对软件的一个或多个构件进行了修改，整个软件也必须进行回归测试 在某些情况下，当底层硬件发生变化时，无论软件有无变更，也需要进行回归测试 回归测试过程 测试重确认/选择/最小化/优先级排序 测试重确认：检查p的测试用例，以确定哪些是对p’。重确认确保回归测试时只使用那些对p’有效的用例(p’为新版本) 测试选择：对p有效的测试对p’可能是多余的因为它们的执行轨迹不经过p’中已修改过的代码。识别那些执行轨迹经过p’修改部分的测试过程就称为测试选择，优势也称为回归测试选择(RTS)问题 测试最小化：根据某些准则丢弃那些多余的测试用例。例如t1和t2都测试了p的功能f，那么在测试最小化的时候，就可能丢弃t2而丢弃t1 测试优先级排序：是基于某些准则对测试用例进行排序。当资源受限，通过测试优先级排序，就会发挥作用 测试准备 测试准备是指将被测程序置于预期的或者模拟的测试环境中，准备接收数据，并产生，需要的输出信息 测试排序 测试过程中有可能关心对软件的测试输入顺序。对具有内部状态且连续运行的软件来讲，测试排序非常重要。银行结算软件、web服务、引擎控制器等都是这类软件 测试执行- 输出比较 故障消除","link":"/软件质量保证/Individual techniques/6-Regression testing/"},{"title":"7-Exploratory Testing","text":"探索性测试 探索性测试（ET）可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索测试强调测试人员的主观能动性，避免繁杂的测试计划和测试用例设计的文档制作过程，强调在碰到问题时及时改变测试策略 探索性测试的最大特色是在对测试对象进行测试的同时学习测试对象并设计测试，在测试过程中运用获得的关于测试对象的信息设计新的更好的测试.这相对于传统软件测试过程中严格的“先设计，后执行”来说，是具有很大区别的. 基本过程 识别软件系统的目的； 识别软件系统提供的功能； 识别软件系统潜在的不稳定的区域； 在探索软件系统的过程中记录关于软件的消息和问题； 创建一个测试纲要，使用它来执行测试。 优点 不需要太多的准备工作，能够很快的发现重要的错误。 测试人员可以根据先前的测试结果来调整之后的测试用例，这在某种意义上可以加快bug发现的过程。 对产品质量有个整体概念，可以作为整个项目里工作分级的一个基础。 缺点 测试用例很难全面覆盖。 容易出现重复测试，且测试难以跟踪。 需要测试人员具有较高水平。 适用范围 需要对新功能或是新产品提供快速的反馈的测试 为测试用例的设计,前期进行尝试性测试 已经过了传统测试,但需要进一步测试 对已有测试用例的改进 要求在短时间内发现一些重要缺陷的测试 管理人员需要测试一下测试人员的工作成果 测试某一特定类型的缺陷 测试一些已知的缺陷","link":"/软件质量保证/Individual techniques/7-Exploratory Testing/"},{"title":"9-Scenario testing","text":"场景测试 在软件开发过程的测试阶段中，由于实际系统过分庞大和复杂，很难测试其全部功能，而只能测试其与执行的任务有类似性的主要功能 目标 使用具有挑战性的案例来反映实际的使用 测试者 Anyone 覆盖率 场景所能覆盖的所有区域 可能存在的问题 有经验的用户在实际使用时的复杂交互 活动 采访相关人员，写场景剧本然后执行测试 复杂度 高 被测试系统阶段 后期 需要稳定 集成的功能 优势 可以帮助解决复杂、现实中的问题。解决一些因为复杂而难以建模分析的情况。 暴露随着时间的流逝而可能会出现的错误。 可以使测试情景与将来的工作情境尽可能相似，测出的结果具有很好的预测效果 缺陷 单个功能的错误会让这个测试变得效率底下。 必须思虑周详以达成好的覆盖。测试者需要较有经验。 分析过程较为人为化，客观性受到影响","link":"/软件质量保证/Individual techniques/9-Scenario testing/"},{"title":"2-Software Quality","text":"Objectives Introduce software quality Provide stakeholder-centric visions of quality and defect Identify software quality assurance Define quality Fitness for use –Dr. Joseph M. Juran The totality of features and characteristics of a product that bear on its ability to satisfy a given need –American Society for Quality Conformance with requirements –Philip Crosby conforms to specifications Quality is value to some person.– Gerald M. Weinberg key dimensions of quality Customer Satisfiers the right features adequate instruction Customer Dissatisfiers unreliable hard to use too slow incompatible with the customer’s equipment Dimensions of Quality: FURPS Functionality Test the accurate workings of each usage scenario Usability Test application from the perspective of convenience to end-user. Reliability Test the application behaves consistently and predictably. Performance Test online response under average and peak loading Supportability Test the ability to maintain and support application under production use A Broader Definition of Dimensions of Quality Accessibility Capability Compatibility Concurrency Conformance to standards Efficiency Installability and uninstallability Localizability Maintainability Performance Portability Reliability Scalability Security Supportability Testability Usability…… Definition of SQA Software quality assurance (SQA) is:A systematic, planned set of actions necessary to provide adequate confidence that the software development process or the maintenance process of a software system product conforms to established functional and technical requirements as well as with the managerial requirements of keeping the schedule and operating within the budgetary confines. 系统的，有计划的一系列行动，以充分确信软件开发过程或软件系统产品的维护过程符合既定的功能和技术要求，以及在预算范围内保持计划和操作的管理要求。 SQA system component classes Pre-project quality components Project life cycle quality components Infrastructure error preventive and improvement components Software quality management components Standardization, certification and SQA assessment components Organizing for SQA – the human components","link":"/软件质量保证/课堂笔记/2-Software Quality/"},{"title":"4-The RUP Test Discipline","text":"Objectives The terminology of RUP The testing discipline in RUP The testing workflow structure WHAT The Rational Unified Process (RUP) is a software engineering process framework that provides a disciplined yet flexible approach to assigning tasks and responsibilities within a software development organization. RUP’s goal is to support the production of high-quality software that meets the needs of its end users within a predictable schedule and budget. The RUP supports many software engineering practices The dynamic structure (phases and iterations) of the Rational Unified Process creates a basis for iterative development. The Project Management discipline describes how to set up and execute a project using phases and iterations. The Use-Case Model and Risk List of the Requirements discipline help determine what functionality you implement in each iteration. The Workflow Details of the Requirements discipline show the activities and artifacts that make requirements management possible. The iterative approach allows you to progressively identify components, decide which ones to develop, which ones to reuse, and which ones to buy. The Unified Modeling Language (UML) used in the process represents the basis of Visual Modeling and has become the de facto modeling language standard. The focus on software architecture allows you to articulate the structure: the components and the ways in which they integrate, the fundamental mechanisms and patterns by which they interact The Rational Unified Process has four phases: Inception - Define the project scope, gain agreement on project objectives, baseline the product Vision Elaboration - Address key technical risks, produce an evolutionary prototype, baseline the Architecture Construction - Iteratively and incrementally develop an operationally complete product Transition - Deliver the product into the live end-user environment 初始 - 定义项目范围，就项目目标达成一致，为产品愿景奠定基础 精化 - 解决关键技术风险，制作演化原型，建立基线 构建 - 迭代并逐步开发出操作完整的产品 过渡 - 将产品交付给实时最终用户环境 Roles in the Test Discipline Test Manager is tasked with the overall responsibility for the test effort’s success. Test Analyst is responsible for initially identifying and defining the required tests, and subsequently evaluating the results of the test effort. Test Designer is responsible for defining the test approach and ensuring its successful implementation. Tester is responsible for the core activities of the test effort, which involves conducting the necessary tests and logging the outcomes of that testing. Define Evaluation Mission Identify the appropriate focus of the test effort for the iteration. Gain agreement with stakeholders on the corresponding goals that will direct the test effort. Test and Evaluate Achieve appropriate breadth and depth of testing to enable a sufficient evaluation of the targeted test items. Achieve Acceptable Mission Deliver a useful evaluation result to the stakeholders of the test effort. Actively prioritize the test work that remains to be conducted. Verify Test Approach Demonstrate the techniques outlined in the Test Approach will support the required testing. Verify that the approach will work, produce accurate results and is appropriate for the available resources. Validate Build Stability Validate that the build is stable enough for detailed test and evaluation work to begin Improve Test Assets Maintain and improve the evolving test assets. (e.g. Maintain test suites and test data; harvest test-ideas into catalogs; clarify change request details)","link":"/软件质量保证/课堂笔记/4-The RUP Test Discipline/"},{"title":"3-Introduction to Software Testing","text":"Objectives Introduce foundation topics of software testing Explain test ideas Introduce test matrices Definition of Software Testing Software testing is a process, or a series of processes, designed to make sure computer code does what it was designed to do and that it does not do anything unintended. Software should be predictable and consistent, presenting no surprises to users. Testing is the process of executing a program with the intent of finding errors. Software testing objectives 在测试软件中识别和揭示尽可能多的错误 在将已识别的错误和重新测试校正后，将测试的软件带到可接受的质量水平。 在预算和调度限制内有效地执行所需的测试。 编译软件错误记录以用于错误预防（通过纠正和预防措施）。 Test model Classification of software testing Vital Program Testing Guidelines Functional Testing 是黑盒测试 对性能以外的任何外部可见或可测量的软件属性感兴趣。 Test Ideas A test idea is a brief statement that identifies a test that might be useful. A test idea differs from a test case, in that the test idea contains no specification of thetest workings, only the essence of the idea behind the test. Test ideas are generators for test cases: potential test cases are derived from a test ideas list. A key question for the tester or test analyst is which ones are the ones worth trying. Where Do Test Ideas Come From? Models Specifications Customer complaints Brainstorm sessions among colleagues Bug lists Representative exemplars","link":"/软件质量保证/课堂笔记/3-Introduction to Software Testing/"},{"title":"5-Define Evaluation Mission","text":"Content Define Evaluation Mission Defining the mission of the test group Defining the goal for test documentation In this module, we begin with the workflow detail Define Evaluation Mission The Mission focuses on the high-level objectives of the test team for the current iteration Define Evaluation Mission The purpose of this workflow detail is to: 确定迭代测试工作的适当重点。 与利益相关方就实现测试工作的相应目标达成协议 对于每次迭代，工作主要集中在： 确定测试工作的目标和可交付成果 确定良好的资源利用战略 为测试工作定义适当的范围和边界 概述将使用的方法 确定如何监控和评估进展情况。 Defining the Test Approach The test approach (testing strategy)specifies the techniques that will be used to accomplish the test mission. The test approach also specifies how the techniques will be used. A good test approach is: Diversified Include a variety of techniques. Each technique is tailored to expose certain types of problems, and is virtually blind to others. Combining them allows you to find problems that would be hard to find if you spent the same resource on a narrower collection of techniques. Risk-focused Tests give you the opportunity to find defects or attributes of the software that will disappoint, alienate, or harm a stakeholder. You can’t run all possible tests. To be efficient, you should think about the types of problems that are plausibly in this product or that would make a difference if they were in this product, and make sure that you test for them. Product-specific Generic test approaches don’t work. Your needs and resources will vary across products. The risks vary across products. Therefore the balance of investment in different techniques should vary across products. Practical here’s no point defining an approach that is beyond your project’s capabilities (including time, budget, equipment, and staff skills). Defensible Defining the goal for test documentation What Test Documentation Should You Use? Test planning standards and templates Requirements considerations Questions to elicit information about test documentation requirements for your project IEEE Standard 829 for Software Test Documentation","link":"/软件质量保证/课堂笔记/5-Define Evaluation Mission/"},{"title":"1-Software Engineering Practices","text":"Some things Testers should know about them Objectives Identify some common software development problems. Identify six software engineering practices for addressing common software development problems 常见的软件开发问题症状 User or business needs not met Requirements churn Modules don’t integrate Hard to maintain Late discovery of flaws Poor quality or poor user experience Poor performance under load No coordinated team effort Build-and-release issues 六种软件工程实践Develop IterativelyManage RequirementsUse Component ArchitecturesModel Visually (UML)Continuously Verify QualityManage Change Develop Iteratively 瀑布模型特点 Delays confirmation of critical risk resolution Measures progress by assessing work-products that are poor predictors of time-to-completion Delays and aggregates integration and testing Precludes early deployment Frequently results in major unplanned project extensions 迭代模型特点 最早的迭代可以解决最大的风险.每次迭代都会生成可执行版本. 每次迭代都包括集成和测试。迭代有助于: 在进行大量投资之前解决重大风险 实现早期客观反馈 使测试和集成持续进行 将项目重点放在可实现的短期目标里程碑上 可以部署完成的最终系统的部分实现 Manage Requirements 为了帮助管理需求与从这些需求派生的测试之间的关系，您可以在这些元素之间建立可跟踪性关系.可追溯性有助于我们做很多事情，包括： 评估项目对需求变更的影响 评估测试失败对需求的影响（如果测试失败，可能不满足要求） 验证应用程序是否仅执行预期的操作 验证实施是否满足系统的所有要求 管理项目范围 管理变更 Component-Based Architecture 弹性 满足当前和未来的要求 提高可扩展性 允许重用 封装系统依赖性 基于组件 重用或自定义组件 从市售组件中选择 逐步发展现有软件 Model Visually (UML)详情见软件分析与设计课程总结 Continuously Verify Quality详情见软件分析与设计课程总结 Manage Change Changes to enable iterative development Secure workspaces for each worker Parallel development possible Automated integration/build management","link":"/软件质量保证/课堂笔记/1-Software Engineering Practices/"},{"title":"6-Test & Evaluate","text":"Content Defining test techniques Individual techniques Using techniques together Dimensions of Test Techniques Think of the testing you do in terms of five dimensions: Testers: who does the testing. Coverage: what gets tested. Potential problems: why you’re testing (what risk you’re testing for). Activities: how you test. Evaluation: how to tell whether the test passed or failed. Of the 200+ published Functional Testing techniques, there are ten basic themes.They capture the techniques in actual practice. Function testing Equivalence analysis Specification-based testing Risk-based testing Stress testing Regression testing Exploratory testing User testing Scenario testing Stochastic or Random testing详情见 Individual techniques 目录","link":"/软件质量保证/课堂笔记/6-Test & Evaluate/"},{"title":"课堂笔记-3上下文无关文法","text":"目的 对语言的语法结构进行形式描述 从形式描述中,研究语法分析其的构造.(算符优先分析法,递归子程序分析法) 文法 grammar文法是描述语言的语法结构的形式规则文法的描述要求 : 形式上严格、准确;易于理解;具有较强的描述能力;有利于句子的分析和翻译，构造语法分析器。 文化分类: 0型文法 短语文法 1型文法 上下文有关文法 2型文法 上下文无关文法 3型文法 正规文法 上下文无关文法的形式化描述 一个上下文无关文法G是一个四元式(VT,VN,S,P) VN：是非空有限集，它的每个元素是非终结符号 VT：是非空有限集，它的每个元素是终结符号; S：S∈VN，称为开始符号; P ：产生式集合（有限），每个产生式形式是 { P-&gt;α| P∈VN， α∈(VT∪VN)*，S至少一次为P };","link":"/编译原理/课堂笔记-3上下文无关文法/"},{"title":"课堂笔记-2词法分析","text":"词法分析 任务 : 从左至右逐个字符地扫描源程序，产生一个个的单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。 输入 : 源程序 输出 : 单词符号={ 关键字 , 标识符 , 常数 , 运算符 , 界符 } 把词法分析从语法分析中脱离出来的优点 使编译程序的结构更加简洁、清晰和条理化。 词法分析和语法分析方法不同，词法分析可以使用正则文法自动构造scanner 有利于提高语法分析的效率 可以改善词法分析的细节，甚至于一个语法分析配几个scanner，把不同的输入变成一种内部表示。 词法分析器的设计1.预处理 2.单词符号的识别(超前搜索) 3.状态转换图 4.状态转换图的实现 预处理 必要性 : 编辑性字符如空白符、回车符等，除了出现在文字常数中以外，在别处出现都没有意义 功能 : 剔出无用字符 实现 : 预处理子程序 超前搜索 标识符的识别 常数的识别 算符和界符的识别 状态转换图 功能 : 用于识别一定的字符串 初态 : 圆圈表示 终态 : 双圈表示 * : 表示多读进了一个字符 状态转换图的实现详见代码实现","link":"/编译原理/课堂笔记-2词法分析/"},{"title":"课堂笔记-1引论","text":"引论编译理论应用 翻译程序 翻译程序={输入:某语言,输出:另外一种语言} 编译程序 编译程序={输入:高级语言源程序,输出:面向机器的代码} 面向机器的代码还可能要由汇编程序或装配程序作进一步加工，得出目标程序，交给计算机执行。 编译过程1.词法分析 2.语法分析 3.中间代码生成 4.代码优化 5.目标代码生成 1.词法分析 任务 : 输入源程序、扫描、分解字符串，识别出一个个单词（定义符、标识符、运算符、界符、常数）。 输入 : 源程序字符串 输出 : 单词符号 依据 : 构词规则 主要理论基础 : 自动机理论 2.语法分析 任务 : 在词法分析基础上，将单词符号串转化为语法单位（语法范畴）（短语、子句、句子、程序段、程序），并确定整个输入串是否构成语法上正确的程序。 输入 : 单词符号 输出 : 语法单位 依据 : 语法规则 主要理论基础 : 上下文无关文法 3.中间代码生成 任务 : 对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码） 输入 : 语法单位 输出 : 中间代码 依据 : 语义规则 主要理论基础 : 属性文法 4.代码优化 任务 : 对于代码（主要是中间代码）进行加工变换，以期能够产生更为高效（省时间和空间）的目标代码 输入 : 中间代码 输出 : 优化后的中间代码 依据 : 程序等价变换规则 主要理论基础 : 数据流方程 5.目标代码生成 任务 : 将中间代码变换成特定机器上的低级语言代码 输入 : 中间代码 输出 : 目标代码 依据 : 硬件体系结构、指令系统 表格与表格管理 编译各阶段均须维持表格并进行表格管理。 建表的技术支持是数据结构。 表格的分类、结构、处理方法决定于语言及机器，还有优化措施。 遍 是对源程序或源程序的中间结果从头到尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序 T型图","link":"/编译原理/课堂笔记-1引论/"},{"title":"课堂笔记-4语法分析","text":"本章内容语法分析的任务与分类自上而下分析面临的问题递归下降分析程序构造预测分析程序LL(1)文法 语法分析的任务与分类 任务 对任一给定 w ∈ VT*，判断 w ∈ L（G） 分类 自下而上 自上而下 自上而下分析面临的问题 文法的左递归 回溯 使用候选式的顺序会影响所接受的语言 如：A —＞ ab|a 改为 A —＞ a|ab 难以报告出错的确切位置 穷举试探法——低效的分析方法 自上而下分析的问题如何解决消除文法的左递归 三种类型的左递归 直接左递归 N -&gt; Nα 间接递归 N-&gt;Aα A-&gt;Bβ B-&gt;Nγ 潜在左递归 N-&gt;αNβ α经过1次或多次推导ε 直接左递归消除方法 若：A —＞ Aα|β ，其中β不以A开头,则修改规则为：A —＞ βA′ A′—＞ αA′|ε 间接和潜在左递归消除方法 代入法 消除一个文法一切左递归的算法 对文法G的所有非终结符进行排序； 按上述顺序对每一个非终结符Pi依次执行: for( j=1； j&lt; i-1；j++) 将Pj代入Pi的产生式（若可代入的话）； 消除关于Pi的直接左递归； 化简上述所得文法。 克服回溯问题 回溯原因","link":"/编译原理/课堂笔记-4语法分析/"},{"title":"课堂笔记-计网","text":"Chapter 1概念 modem 调制解调器 network of networks 网间网 protocols={format,order,actions} msg 报文 HFC hybrid fiber coax FTTH Fiber to the Home 光纤入户 throughput :rate (bits/time unit) at which bits transferred between sender/receiver Dial-up Modem 使用现有的电话基础设施 家与central office 直连 无法同时上网 打电话呢 无法一直在线 Asymmetric Digital Subscriber Line (ADSL) 使用现有的电话基础设施 使用专用的物理线路到电话central office Circuit SwitchingPacket SwitchingInternet protocol stack application: supporting network applications FTP, SMTP, HTTP transport: process-process data transfer TCP, UDP network: routing of datagrams from source to destination IP, routing protocols link: data transfer between neighboring network elements PPP, Ethernet physical: bits “on the wire” Chapter 2概念 Process:program running within a host Sockets:process send/receives msg to/from its socket FTP:the file transfer protocol Non-Persistent HTTP Response time=2RTT+ transmit time Persistent HTTP Response time 第一个对象2RTT 之后的都是1RTT HTTP request message request line GET POST HEAD 请求头信息 PUT 放 DELETED 删除 header lines Carriage return, linefeed indicatesend of message HTTP response message status line header line (data)* Web Caches Proxy Cache Goal:satisfy client request without involving origin server Client Cache Goal: don’t send object if cache has up-to-date cached version Distributed Caches Many caches are cooperative Difficult to operate Server Caches:cluster High parallelism reliability load balance needed object location algorithm needed 广泛采用 FTP FTP客户端连接FTP服务器端口21,TCP是传输协议 客户端被授权控制连接 客户端通过控制连接发送命令来浏览远程目录。 当服务器接收到文件传输命令时，服务器打开第二个TCP连接(用于文件)到客户端 传输一个文件后，服务器关闭数据连接。 Electronic Mail 3 magor components user agents mail servers SMTP(simple mail transfer protocol) Chapter 3 Chapter 4 Chapter 5 Chapter 6","link":"/计算机网络/课堂笔记-计网/"}],"tags":[],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"编译原理","slug":"编译原理","link":"/categories/编译原理/"},{"name":"实训","slug":"实训","link":"/categories/实训/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/categories/计算机组成原理/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"课堂笔记","slug":"Linux/课堂笔记","link":"/categories/Linux/课堂笔记/"},{"name":"软件质量保证","slug":"软件质量保证","link":"/categories/软件质量保证/"},{"name":"Individual techniques","slug":"软件质量保证/Individual-techniques","link":"/categories/软件质量保证/Individual-techniques/"},{"name":"课堂笔记","slug":"软件质量保证/课堂笔记","link":"/categories/软件质量保证/课堂笔记/"}]}