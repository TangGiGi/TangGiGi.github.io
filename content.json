{"pages":[],"posts":[{"title":"Android案例-弹出菜单","text":"MainActivity.java123456789public void OnMenu(View view){ // 获取自定义的菜单布局文件 View popupWindow_view = getLayoutInflater().inflate(R.layout.menu, null,false); // 创建PopupWindow实例,设置菜单宽度和高度为包裹其自身内容 popupWindow = new PopupWindow(popupWindow_view, ActionBar.LayoutParams.WRAP_CONTENT, ActionBar.LayoutParams.WRAP_CONTENT, true); //设置菜单显示在按钮的下面 popupWindow.showAsDropDown(findViewById(R.id.btn_menu),0,0); // 点击其他地方消失 menu.xml为弹出菜单 文档 public class PopupWindow extends Objectjava.lang.Object ↳ android.widget.PopupWindow 该类表示可用于显示任意视图的弹出窗口。弹出窗口是出现在当前活动顶部的浮动容器。This class represents a popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. Public constructors1234public PopupWindow (View contentView, int width, int height, boolean focusable) Create a new popup window which can display the contentView. The dimension of the window must be passed to this constructor.The popup does not provide any background. This should be handled by the content view. contentView:the popup’s contentwidth :the popup’s widthheight :the popup’s heightfocusable :true if the popup can be focused, false otherwise Public methods1234public void showAsDropDown (View anchor, int xoff, int yoff, int gravity) Parametersanchor:the view on which to pin the popup windowxoff:A horizontal offset from the anchor in pixelsyoff:A vertical offset from the anchor in pixelsgravity: Alignment of the popup relative to the anchor 12345678View inflate(int resource, ViewGroup root)//Inflate a new view hierarchy from the specified xml resource.View inflate(XmlPullParser parser, ViewGroup root)//Inflate a new view hierarchy from the specified xml node.View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)//Inflate a new view hierarchy from the specified XML node.View inflate(int resource, ViewGroup root, boolean attachToRoot)//Inflate a new view hierarchy from the specified xml resource.","link":"/2018/11/04/Android/Android案例-弹出菜单/"},{"title":"Linux网络服务-Internet服务","text":"Content Xinetd Ftp Http SSH Xinetd (Extended Internet Daemon) 守护进程Daemon 运行在后台的一种特殊程序，独立于控制终端执行某种任务或者等待处理某些发生的事件，如smbd，named等 Linux的大多数服务是用守护程序实现的，守护程序打开一个端口并且监听该端口，等待客户机的连接。一旦客户机提交了连接请求，守护程序就创建一个子进程来响应，而父进程继续监听更多的服务请求。因此每个守护程序可以处理多个客户服务的请求。 服务器上的许多服务都是通过超级守护程序包 inetd 或 xinetd 来管理和启动的。 超级守护程序充当一组服务发出连接请求时的中介者。它直接接受连接请求、启动所需的服务并将请求传递到新启动的服务器。如果客户机和服务器之间的连接终止，则由 xinetd 启动的服务器将从内存中删除。 通过 inetd 启动服务既有优点也有缺点。最大的优点就是节省资源（尤其是内存），因为服务器仅在需要时才启动。但是，缺点是在装载、启动和连接所需服务时将发生延迟。 守护程序的运行方式 独立运行的守护程序 由init脚本管理 其脚本存放在/etc/rc.d/init.d/目录下 由Xinetd运行的守护程序 由xinetd管理启动 服务的配置文件存放在/etc/xinetd.d/目录下 可用pstree查看当前进程树 Xinetd特点 强大的访问控制功能：提供对用户的审查和权限控制、限制连接数目、设定特定的连接时间 强大的日志功能：可以为每一个服务设置日志等级：为每个服务设置日志文件；记录起止时间；记录非法访问请求 专项功能：可以将客户端的请求交到另外的主机去处理 与客户端的交互功能 配置Xinetd 配置文件 /etc/xinetd.conf123456默认配置参数 defaults 为所有的服务指定缺省值 { key operator parameter parameter. . . instances ＝ 60 } includedir /etc/xinetd.d //指明配置文件目录将提示 xinetd 解释目录/etc/xinetd.d/ 中的所有文件以配置服务 配置其网络服务 123456 service service_name { key operator parameter parameter. . . }运算符有 =、-= 和 += 可在目录 /etc/xinetd.d/ 中为每个服务创建一个单独的配置文件 例子 1234567service telnet{ socket_type = stream wait = no user = root server = /usr/sbin/in.telnetd disable = no}","link":"/2018/12/07/Linux/Class Notes/Linux 网络服务- Internet服务/"},{"title":"Linux简介","text":"manman （/usr/share/man）如果输入命令 man 后英语手册页没有自动显示，则您可以使用参数LANG=en_EN来显示英语版本的手册页。1&gt; LANG=en_EN man man 给出关于man的具体描述，包括以下几个部分其中每个手册页标题的左右侧是命令名和手册页所属的章节号。标题的中间是章节的名称。 12345678910NAME 命令的名称和简短描述SYNOPSIS 语法的描述DESCRIPTION 命令的详细描述OPTIONS 提供的所有可用选项的描述COMMANDS 在程序运行时可以分配给该程序的说明FILES 使用某种方法连接到命令的文件SEE ALSO 相关命令的提示DIAGNOSTICS 程序可能出现的错误消息EXAMPLE 调用命令的示例BUGS 命令的已知错误和问题 手册页可以分为以下不同的小节 123456781 可执行程序和 shell 命令（用户命令）2 系统调用3 功能和库例程4 设备文件5 配置文件和文件格式6 游戏7 宏软件包和文件格式8 系统管理命令 例如12&gt;man 1 crontab&gt;man 5 crontab 使用命令 whatis 显示某个命令或实用程序的所有可用手册页的简短描述1&gt;whatis crontab Info/usr/share/info/Info工具是一个基于菜单的超文本系统，由GNU项目开发并由Linux发布。info工具包括一些关于Linux shell、工具、GNU项目开发程序的说明文档。与man相比，info工具可显示更完整的最新的GNU工具信息1&gt;info ls –help“–help”是一个工具选项1&gt;ls --help Howto文档/usr/share/doc/howtoor http://www.tldp.org/index.html 在线文档一些在线信息http://www.tldp.orghttp://www.linux.orghttp://www.redhat.comhttp://www.suse.comhttp://www.xfree86.orghttp://www.linuxplanet.comhttp://www.cert.orghttp://www.securityfocus.comhttp://www.kernel.orghttp://man.linuxde.net/ 在以下目录中提供了大多数已安装软件包包的帮助文件：/usr/share/doc/packages/package-name ls -l 查看文件的属性普通文件 -rw-r–r–目录文件 drwxr-xr-x字符设备文件 crw-rw-rw-块设备文件 brw-r—–套接字文件 srwxrwxrwx链接文件 lrwxrwxr—FIFO文件 prwxr—r–","link":"/2018/12/07/Linux/Class Notes/linux简介/"},{"title":"Linux网络服务","text":"Content NTP(network time protocol) Linux打印服务 NTP ntp通过与时间服务器同步使本机时间与UTC(世界协调时间）同步 UTC也称为GMT（格林尼治时间） 本地时间 /etc/sysconfig/clock ZONE UTC Linux 系统中有 2 个主要的时钟： 硬件时钟。这是一个独立于 CPU 中运行的所有控制程序而运行的时钟。也称为时间时钟、RTC、BIOS 时钟或 CMOS 时钟。 系统时间。这是 Linux 内核内部时钟的时间，并且由计时器中断驱动。 当 Linux 第一次启动时，系统时间与硬件时钟同步。之后， Linux 只使用系统时间。 date xntp 通过提供以下服务解决同步问题： xntp 定期根据收集到的更正数据更正本地计算机时钟。 xntp 会随时借助网络中的时间服务器更正本地时间。 xntp 支持对本地参考时钟（如无线电控制的时钟）进行管理。 Linux打印服务 CUPS (Common Unix Printing System ) 是行式打印机守护程序Line Print Daemon (LPD)的后继，在redhat中仍使用部分LPD命令进行打印机调整与监视。 LPD （行式打印机守护程序） 在发送实际打印数据之前，将先发送一些与作业相关的数据，例如打印机队列。LPD 服务的端口号是 515 IPP （因特网打印协议） 是一个基于HTTP 协议的相对较新的（自 1999）协议。使用 IPP，所传送的与作业有关的数据比其他协议要多得多。CUPS 使用 IPP 进行内部数据传送。这是在 CUPS 服务器之间转发队列的首选协议。IPP 的端口号是 631 SMB （服务讯息块）。CUPS 还支持在连接到 Windows 共享的打印机上进行打印，SMB 使用端口号 137、138 和 139","link":"/2018/12/07/Linux/Class Notes/Linux网络服务/"},{"title":"Vi常见命令","text":"","link":"/2018/12/07/Linux/Class Notes/Vi常见命令/"},{"title":"学用linux","text":"文件查找 findfind 在命令行上搜索文件1&gt;find path criterion action path：要搜索的文件系统部分（指定的目录及其所有子目录）。如果什么也没指定，则将使用当前目录下的文件系统。criterion：文件应该具有的属性：-name pattern 搜索名称中包含给定模式的文件。如果模式中包含元字符或通配符，则必须用引号将它括起。否则，它将由 shell 解释，而不是由 find 解释。-type file_type 搜索文件类型。适用的文件类型如下：“d”（用于目录）、“f”（用于文件）或者“l”（用于符号链接）。-ctime [+/-]days 搜索恰好在指定的几天前进行上一次修改的那些文件。action:影响以下条件或将搜索作为一个整体进行控制的选项，例如： -print -exec command 可使用选项 -exec 调用其他命令 例子 1&gt;find ~ -name kk* -type f –exec grep first {} \\; -print {} 这两个括号代表找到的并传递到命令 grep 的文件名的占位符。分号用于结束 -exec指令。由于它是特殊字符，所以在它前面放一个反斜杠，以此来标记它。 locate locate 是 find -name 的替代命令（必须装有软件包 findutils-locate）。首次使用要用updatedb生成/更新数据库。 查找命令所在目录whereis 命令 whereis 将返回二进制（选项 -b）、手册页（选项 -m）和指定命令的源代码（选项 -s）。该命令的速度比 find 快，但不如 find 全面。 123&gt;whereis -b ls&gt;whereis -m ls&gt;whereis -s ls which which 将搜索在变量 PATH 中为指定命令列出的所有路径，并返回该命令的完整路径。命令 which 特别适用于以下情况：不同目录中存在某个命令的几个版本，并且您想知道在未指定路径的情况下输入时将执行哪个版本。 1&gt;which find type命令 type command 可用来查找在输入 command 时执行哪类命令，是 shell 内置命令还是外部命令。选项 -a 在文件系统中传递采用该名称的命令的所有实例。12&gt;type type&gt;type grep 搜索文件内容 grep当需要查找包含特殊词、短语或项的所有文件，并且是扫描所有文件而不在编辑器中打开它们时&gt;grep search_pattern filename该命令将在文件名中进行搜索以寻找与 search_pattern 匹配的所有文本，并打印包含该模式的行。123456命令 grep 的可用选项如下： -i 忽略大小写。 -l 仅显示包含搜索字符串的文件的名称。 -r 递归地搜索整个目录树。 -v 给定不包含搜索字符串的所有行。 -n 显示行号。 1234&gt;grep test d* //显示所有以d开头的文件中包含test的行&gt;grep -n test aa bb cc//显示在aa，bb，cc文件中匹配test的行。 安装RPM包用rpm安装软件的命令格式如下： rpm -i [安装选项] rpm 软件包名 安装选项有很多，常用的如下： -vh ：显示安装过程中的详细信息； –percent：显示安装进度的百分比； –test：不进行安装软件包，只进行安装测试并显示简单的报告； –force：忽略任何错误，强制安装软件包。 更新、卸载RPM包 rpm -u rpm软件包名 rpm -e rpm软件包名 查询已安装的包版本rpm –qa |grep 软件包名","link":"/2018/12/07/Linux/Class Notes/学用linux/"},{"title":"Linux用户用户组和文件权限","text":"","link":"/2018/12/07/Linux/Class Notes/Linux用户用户组和文件权限/"},{"title":"1-Function testing","text":"Function testing 也叫黑盒单元测试 针对每个功能单元进行的一种黑盒测试。 测试人员 可以是任何人：编码人员、测试人员等 覆盖程度 覆盖所有的功能以及用户可见的变量 测试的目的 为了使每个功能能够单独运作 测试方法 穷举法 边界值分析法 基于单/多缺陷假设设计测试样例 等价类划分法 典型数据法 … 如何分析结果 寻找同类功能做对比.同类功能：例如显卡的功能测试，找同类显卡，在相同的输入条件下比较输出结果。 复杂程度 对已实现的各个功能设计测试样例进行测试 严格程度 指测试方法对软件错误的容忍程度，即其发现软件错误的能力大小 对系统完成度的要求 每一个功能单元完成后便可以进行功能测试 优点 对每个测试项目进行全面分析 Easy to do as each function is implemented 缺点 Misses interactions Misses exploration of the benefits offered by the program","link":"/2018/12/10/Software Quality Assurance/Individual techniques/1-Function testing/"},{"title":"2-Equivalence analysis","text":"Content 等价类划分 等价类划分指南 等价类划分实例 等价类 等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的。 等价类划分 等价类划分，指一种典型的、重要的黑盒测试方法，它将程序所有可能的输入数据划分为若干个等价类。然后从每个部分中选取具有代表性的数据当做测试用例。利用这一方法设计测试用例可以不考虑程序的内部结构，以需求规格说明书为依据，选择适当的典型子集，认真分析和推敲说明书的各项需求，特别是功能需求，尽可能多地发现错误。等价类划分法是一种系统性的确定要输入的测试条件的方法。 有效等价类划分 有效等价类指对于程序规格说明来说，是合理的、有意义的输入数据构成的集合。利用有效等价类可以检验程序是否实现了规格说明预先规定的功能和性能。有效等价类可以是一个，也可以是多个，根据系统的输入域划分若干部分，然后从每个部分中选取少数有代表性数据当做数据测试的测试用例，等价类是输入域的集合。 以下是对有效等价类数据集的一些例子： 终端用户输入的命令 与最终用户交互的系统提示 接受相关的用户文件的名称 提供初始化值和边界等 提供格式化输出数据的命令 在图形模式（比如鼠标点击时）提供的数据 失败时显示的回应消息 无效等价类划分 无效等价类和有效等价类相反，无效等价类是指对于软件规格说明而言，没有意义的、不合理的输入数据集合。利用无效等价类，可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。 以下是无效等价类数据集的一些例子： 终端在一个不正确的地方提供适当的值 验证外部边界的值 验证与边界和外部边界值的数值数据 等价类划分指南 等价类划分的方法 输入条件制定了一个域 输入条件指定了一组值的集合: 为集合中的每个元素创建一个等价类，为一个无效输入也创建一个等价类 输入条件指定了每一个单独的值：如果系统对每一个有效输入的处理都不同，那么为每一个有效输入创建一个等价类 输入条件指定了有效值的数量：为正确的输入数量创建一个等价类，为无效输入创建两个等价类——一个数量为零，一个比N大 输入条件指定了一个必须值：为该必须值创建一个等价类，为非必须值创建一个等价类 分割等价类：如果系统以不同方式处理一个划分好的等价类中的元素，那么分割该等价类为更小的等价类 从等价类中识别测试用例 为每个等价类指定一个唯一的标识符 对于每个还未被测试用例覆盖到的有效输入等价类，生成新的测试用例，尽量多地覆盖还未覆盖到的等价类，按照这一步骤重复进行，直到所有的有效等价类都被覆盖为止 对于每个还未被测试用例覆盖到的无效输入等价类，生成新的测试用例，仅覆盖一个还未覆盖到的等价类，按照这一步骤重复进行，直到所有的无效等价类都被覆盖为止。 等价类划分实例Ex A申请账号时，用户必须输入用户名、密码、确认密码，对每一项输入条件要求如下：用户命要求为6位以上，18位以下，使用英文字母、数字、“-”、“”,并且首字符必须为字母或数字；密码在6~16位之间，只能用英文字母、数字、“-”、“”,并且区分大小写。列出等价类表和测试用例。 等价类表：等价类的测试用例： Ex B一个程序读入3个整数，把这3个数值看作一个三角形的3条边的长度值。这个程序要打印出信息，说明这个三个数值不构成三角形、或是一般三角形、或是等腰的三角形、或是等边三角形。列出等价类表和测试用例。分析题目中给出和隐含的对输入条件的要求： 整数 2. 三个数 3. 非零数 4. 正数 5. 两边之和大于第三边 6.等腰 7. 等边如果a、b、c满足条件1~4，则输出下列四种情况之一：1）如果不满足条件5，则程序输出为“非三角形”2）如果三条边相等即满足条件7，则程序输出为“等边三角形”3）如果只有两条边相等，及满足条件6，则程序输出为“等腰三角形”4）如果三条边都不相等，则程序输出为“一般三角形”等价类表覆盖有效等价类的测试用例覆盖无效类等价类的测试用例","link":"/2018/12/10/Software Quality Assurance/Individual techniques/2-Equivalence analysis/"},{"title":"10-Stochastic or Random Test","text":"Content What Why 特点 随机测试 黑盒测试 输入:Random，independent 输出:Compared against software specifications to verify that the test output is pass or fail 测试过程：自动化 覆盖范围：广泛但浅显 Why 随机测试可以让我们轻松的根据测试结果估算软件可靠性。 可以从随机测试中获得数据用于估计软件的可靠性(其他测试方法不能用这种方式来估算软件可靠性） 相比于其他更为周到的测试方法，可以节约精力和时间 特点 无需任何特定测试 在无文档、无计划下的软件测试 可以发现测试用例覆盖不到的bug 随机测试几乎可以在任何时候进行 测试软件的鲁棒性 发现低优先级高严重性的bug 对比与模糊测试的区别： 模糊测试：随机数据 随机测试：随机行为与探索性测试的区别： 随机测试：思维过程无序 探索性测试：思维过程具有有序性、合理性","link":"/2018/12/10/Software Quality Assurance/Individual techniques/10-Stochastic or Random Test/"},{"title":"3-Specification-based testing","text":"定义 黑盒测试、功能测试、数据驱动测试 测试者不了解程序的内部情况，不需具备应用程序的代码、内部结构和编程语言的专门知识。只知道程序的输入、输出和系统的功能，这是从用户的角度针对软件界面、功能及外部结构进行测试，而不考虑程序内部逻辑结构。测试案例是依应用系统应该做的功能，照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。 基本属性 目标：核验需求文档里每个要求的一致性。 测试者：可以任何人。 覆盖内容：文档化的需求以及一些特性。 潜在问题：实现与规格不匹配的问题。 评估方法：实现是否与规格匹配。 复杂度：由规格说明书决定 苛刻度：有规格说明书决定 如何在缺少规格说明书的情况下获取信息?有什么可行的替代方法？ 在缺少规格说明书或者是规格说明书不正确的时候可以使用使用如下资源 软件更新备忘录 用户手册草稿 产品资料 已发布的样式指南和UI标准 已发布的标准 第三方产品兼容性测试套件 内部备忘录 营销展示、产品概念 Bug报告 逆向工程 …. 规格说明 规格说明书要求做到精确和细化需求中描述的系统功能性需求和约束。 规格说明是为了技术人员编写的 规格说明书的形式可以是多种多样的。下面列出几个常见的规格说明书形式： 需求文档 用例 模型 形式化方法 原型 …","link":"/2018/12/10/Software Quality Assurance/Individual techniques/3-Specification-based testing/"},{"title":"11-structual testing","text":"DD-path覆盖 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的每个DD路径，则它们构成DD路径覆盖。 branch覆盖 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中的决策（predicate）的每个分支（输出），则它们构成分支覆盖。 path coverage 给定程序的一组测试用例，如果在程序上执行时，遍历程序图中从源节点到汇聚节点的每条路径，则它们构成路径覆盖。 node coverage 如果在程序上执行时，遍历程序图中的每个节点，则它们构成节点覆盖。 edge coverage 遍历程序图中的每个边，则它们构成边缘覆盖。语句覆盖使所有的判断语句都能执行一次的条件案例，例如当判断语句事组合语句的时候，并且用or连接，只满足一个案例即可判定覆盖（分支覆盖）针对判断语句，在设定案例的时候，要设定True和False的两种案例；与语句覆盖不同的是增加了False的情况条件覆盖针对判断语句里面案例的取值都要去一次，不考虑条件的取值判定/条件覆盖判定覆盖各条件覆盖交叉，针对于判定中的条件取值组合覆盖判定-条件覆盖的加强版","link":"/2018/12/10/Software Quality Assurance/Individual techniques/11-structual testing/"},{"title":"5-Stress Testing","text":"Content 压力测试简述 压力测试特点 压力测试步骤 压力测试实例 Stress Testing 是指不断给被测系统增加压力，直到被测系统被压垮，并在系统被压垮的情况下持续测试。 以确定系统能承受的最大压力以及系统是否具有良好的容错能力和可恢复能力。 压力测试的特点 测试者：在软件压力测试方面具备专业知识和一定的操作技能的人 代码覆盖率：部分覆盖，难以界定是否覆盖完全 测试阶段：开发项目接近完成 粗颗粒度：压力测试极其粗糙 复杂性：根据软件自身的需求有所不同 优点 能暴露系统可能出现的缺陷 能暴露系统的安全风险 可能对评估性能、可靠性或效率有帮助 局限性 缺陷可能在压力测试下并不明显 当不知道问题的大致区间时，压力测试就会比较慢 易出现“不知道因为什么导致了问题”和“有没有遗漏什么”的问题 压力测试的步骤 Identify the Test Environment 确认测试环境 Identify Performance Acceptance Criteria 确认性能指标 Plan and Design Tests 计划并设计测试 Configure the Test Environment 配置测试环境 Implement the Test Design 实现设计好的测试 Execute the Test 执行测试 Analyze Results, Report, and Retest 分析、报告、重复测试 压力测试与其他测试的关系常见的测试有：负载测试、压力测试和性能测试。三者测试目的不同，但其手段和方法在一定程度上比较相似，通常会使用相同的测试环境和测试工具，而且都会监控系统所占用资源的情况以及其它相应的性能指标。 tester：三者都应该具有一定的专业水平 coverage：三者均为部分覆盖，存在局限性，难以确定是否覆盖了所有可能的缺陷 potential problem：压力测试是期望系统崩溃；负载测试是期望得到系统的响应时间和质量；性能测试时为了了解应用程序在常规参数下的行为方式 activities：压力测试往往要增加比负载测试多的并发用户，一般要比系统设计的并发量大，而性能测试验证产品资源的使用情况，可用性及可靠性 evaluation：压力测试是看服务器能否在崩溃后自我恢复，任何意外故障是否会损害系统安全性；负载测试是看系统的响应时间和质量是否符合设计要求及当前的基础设施是否足以运行应用程序；性能测试是看系统是否符合业务的性能需求，验证该应用程序能否正常运行 focus：性能测试的关注点在于程序运行的响应时间和并发量，负载测试的关注点在于系统并发量的多少，而压力测试更关注在超过了系统极限值的限制范围后系统的影响。","link":"/2018/12/10/Software Quality Assurance/Individual techniques/5-Stress Testing/"},{"title":"4-Risk-based Testing","text":"Content Targets, concept and benefits of RBT Risk and Risk management Risk-based testing approach Risk-based testing in practice Risk matrix and Risk reporting Risk-based testing and test automation Why Risk-based Testing? Software projects are very rarely on time,schedule or budget. Very often early project phases are delayed. When eventually comes down to testing, the time to delivery is extremely short and there is no budget left due to the development overrun. During development everybody is as a rule extremely busy resulting the test preparation activities not receiving the appropriate attention. RBT RBT(Risk-based Testing) is a test method deciding the test strategy by analyzing and accessing the risk of product. Reduced resource consumption(i.e., more efficient testing) Improved quality by spending more time on critical functions. Risk and Risk management Risk Identification Risk Strategy Risk Assessment Risk Mitigation Risk Reporting","link":"/2018/12/10/Software Quality Assurance/Individual techniques/4-Risk-based Testing/"},{"title":"7-Exploratory Testing","text":"探索性测试 探索性测试（ET）可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索测试强调测试人员的主观能动性，避免繁杂的测试计划和测试用例设计的文档制作过程，强调在碰到问题时及时改变测试策略 探索性测试的最大特色是在对测试对象进行测试的同时学习测试对象并设计测试，在测试过程中运用获得的关于测试对象的信息设计新的更好的测试.这相对于传统软件测试过程中严格的“先设计，后执行”来说，是具有很大区别的. 基本过程 识别软件系统的目的； 识别软件系统提供的功能； 识别软件系统潜在的不稳定的区域； 在探索软件系统的过程中记录关于软件的消息和问题； 创建一个测试纲要，使用它来执行测试。 优点 不需要太多的准备工作，能够很快的发现重要的错误。 测试人员可以根据先前的测试结果来调整之后的测试用例，这在某种意义上可以加快bug发现的过程。 对产品质量有个整体概念，可以作为整个项目里工作分级的一个基础。 缺点 测试用例很难全面覆盖。 容易出现重复测试，且测试难以跟踪。 需要测试人员具有较高水平。 适用范围 需要对新功能或是新产品提供快速的反馈的测试 为测试用例的设计,前期进行尝试性测试 已经过了传统测试,但需要进一步测试 对已有测试用例的改进 要求在短时间内发现一些重要缺陷的测试 管理人员需要测试一下测试人员的工作成果 测试某一特定类型的缺陷 测试一些已知的缺陷","link":"/2018/12/10/Software Quality Assurance/Individual techniques/7-Exploratory Testing/"},{"title":"6-Regression testing","text":"回归测试（Regression testing） 指在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，软件产生新版本都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。 回归测试通常被认为是“程序的重新确认”； “纠正型回归测试”指对程序修改后进行回归测试； “增量型回归测试”指程序增加新特性后进行测试。 回归测试多余？ 开发人员也可以通过适当的证据证明新增的方法对原方法没有影响，这种情况下回归测试是多余的。 必须进行回归测试的情况 当对软件的一个子系统进行修改，得到软件的一个新版本，此时回归测试是必需的； 当对软件的一个或多个构件进行了修改，整个软件也必须进行回归测试 在某些情况下，当底层硬件发生变化时，无论软件有无变更，也需要进行回归测试 回归测试过程 测试重确认/选择/最小化/优先级排序 测试重确认：检查p的测试用例，以确定哪些是对p’。重确认确保回归测试时只使用那些对p’有效的用例(p’为新版本) 测试选择：对p有效的测试对p’可能是多余的因为它们的执行轨迹不经过p’中已修改过的代码。识别那些执行轨迹经过p’修改部分的测试过程就称为测试选择，优势也称为回归测试选择(RTS)问题 测试最小化：根据某些准则丢弃那些多余的测试用例。例如t1和t2都测试了p的功能f，那么在测试最小化的时候，就可能丢弃t2而丢弃t1 测试优先级排序：是基于某些准则对测试用例进行排序。当资源受限，通过测试优先级排序，就会发挥作用 测试准备 测试准备是指将被测程序置于预期的或者模拟的测试环境中，准备接收数据，并产生，需要的输出信息 测试排序 测试过程中有可能关心对软件的测试输入顺序。对具有内部状态且连续运行的软件来讲，测试排序非常重要。银行结算软件、web服务、引擎控制器等都是这类软件 测试执行- 输出比较 故障消除","link":"/2018/12/10/Software Quality Assurance/Individual techniques/6-Regression testing/"},{"title":"2-Software Quality","text":"Objectives Introduce software quality Provide stakeholder-centric visions of quality and defect Identify software quality assurance Define quality Fitness for use –Dr. Joseph M. Juran The totality of features and characteristics of a product that bear on its ability to satisfy a given need –American Society for Quality Conformance with requirements –Philip Crosby conforms to specifications Quality is value to some person.– Gerald M. Weinberg key dimensions of quality Customer Satisfiers the right features adequate instruction Customer Dissatisfiers unreliable hard to use too slow incompatible with the customer’s equipment Dimensions of Quality: FURPS Functionality Test the accurate workings of each usage scenario Usability Test application from the perspective of convenience to end-user. Reliability Test the application behaves consistently and predictably. Performance Test online response under average and peak loading Supportability Test the ability to maintain and support application under production use A Broader Definition of Dimensions of Quality Accessibility Capability Compatibility Concurrency Conformance to standards Efficiency Installability and uninstallability Localizability Maintainability Performance Portability Reliability Scalability Security Supportability Testability Usability…… Definition of SQA Software quality assurance (SQA) is:A systematic, planned set of actions necessary to provide adequate confidence that the software development process or the maintenance process of a software system product conforms to established functional and technical requirements as well as with the managerial requirements of keeping the schedule and operating within the budgetary confines. 系统的，有计划的一系列行动，以充分确信软件开发过程或软件系统产品的维护过程符合既定的功能和技术要求，以及在预算范围内保持计划和操作的管理要求。 SQA system component classes Pre-project quality components Project life cycle quality components Infrastructure error preventive and improvement components Software quality management components Standardization, certification and SQA assessment components Organizing for SQA – the human components","link":"/2018/12/08/Software Quality Assurance/Class Notes/2-Software Quality/"},{"title":"1-Software Engineering Practices","text":"Some things Testers should know about them Objectives Identify some common software development problems. Identify six software engineering practices for addressing common software development problems 常见的软件开发问题症状 User or business needs not met Requirements churn Modules don’t integrate Hard to maintain Late discovery of flaws Poor quality or poor user experience Poor performance under load No coordinated team effort Build-and-release issues 六种软件工程实践Develop IterativelyManage RequirementsUse Component ArchitecturesModel Visually (UML)Continuously Verify QualityManage Change Develop Iteratively 瀑布模型特点 Delays confirmation of critical risk resolution Measures progress by assessing work-products that are poor predictors of time-to-completion Delays and aggregates integration and testing Precludes early deployment Frequently results in major unplanned project extensions 迭代模型特点 最早的迭代可以解决最大的风险.每次迭代都会生成可执行版本. 每次迭代都包括集成和测试。迭代有助于: 在进行大量投资之前解决重大风险 实现早期客观反馈 使测试和集成持续进行 将项目重点放在可实现的短期目标里程碑上 可以部署完成的最终系统的部分实现 Manage Requirements 为了帮助管理需求与从这些需求派生的测试之间的关系，您可以在这些元素之间建立可跟踪性关系.可追溯性有助于我们做很多事情，包括： 评估项目对需求变更的影响 评估测试失败对需求的影响（如果测试失败，可能不满足要求） 验证应用程序是否仅执行预期的操作 验证实施是否满足系统的所有要求 管理项目范围 管理变更 Component-Based Architecture 弹性 满足当前和未来的要求 提高可扩展性 允许重用 封装系统依赖性 基于组件 重用或自定义组件 从市售组件中选择 逐步发展现有软件 Model Visually (UML)详情见软件分析与设计课程总结 Continuously Verify Quality详情见软件分析与设计课程总结 Manage Change Changes to enable iterative development Secure workspaces for each worker Parallel development possible Automated integration/build management","link":"/2018/12/08/Software Quality Assurance/Class Notes/1-Software Engineering Practices/"},{"title":"8-User Testing","text":"用户测试 定义：以用户为为参与主体的测试 引入原因：用户作为软件最终使用的主体 测试目标：测试软件的总体情况及用户体验 测试者：用户 覆盖面：很难度量 测试启动时间：软件开发基本完成 优点 暴露设计的问题 能找到高错误率的区域 测试过程能够被监控 能够通过内部实验室注意有争议的区域 缺点 覆盖面不能够保证 测试用例弱 结果好坏不一 必须区分营销测试与技术测试","link":"/2018/12/10/Software Quality Assurance/Individual techniques/8-User Testing/"},{"title":"3-Introduction to Software Testing","text":"Objectives Introduce foundation topics of software testing Explain test ideas Introduce test matrices Definition of Software Testing Software testing is a process, or a series of processes, designed to make sure computer code does what it was designed to do and that it does not do anything unintended. Software should be predictable and consistent, presenting no surprises to users. Testing is the process of executing a program with the intent of finding errors. Software testing objectives 在测试软件中识别和揭示尽可能多的错误 在将已识别的错误和重新测试校正后，将测试的软件带到可接受的质量水平。 在预算和调度限制内有效地执行所需的测试。 编译软件错误记录以用于错误预防（通过纠正和预防措施）。 Test model Classification of software testing Vital Program Testing Guidelines Functional Testing 是黑盒测试 对性能以外的任何外部可见或可测量的软件属性感兴趣。 Test Ideas A test idea is a brief statement that identifies a test that might be useful. A test idea differs from a test case, in that the test idea contains no specification of thetest workings, only the essence of the idea behind the test. Test ideas are generators for test cases: potential test cases are derived from a test ideas list. A key question for the tester or test analyst is which ones are the ones worth trying. Where Do Test Ideas Come From? Models Specifications Customer complaints Brainstorm sessions among colleagues Bug lists Representative exemplars","link":"/2018/12/08/Software Quality Assurance/Class Notes/3-Introduction to Software Testing/"},{"title":"9-Scenario testing","text":"场景测试 在软件开发过程的测试阶段中，由于实际系统过分庞大和复杂，很难测试其全部功能，而只能测试其与执行的任务有类似性的主要功能 目标 使用具有挑战性的案例来反映实际的使用 测试者 Anyone 覆盖率 场景所能覆盖的所有区域 可能存在的问题 有经验的用户在实际使用时的复杂交互 活动 采访相关人员，写场景剧本然后执行测试 复杂度 高 被测试系统阶段 后期 需要稳定 集成的功能 优势 可以帮助解决复杂、现实中的问题。解决一些因为复杂而难以建模分析的情况。 暴露随着时间的流逝而可能会出现的错误。 可以使测试情景与将来的工作情境尽可能相似，测出的结果具有很好的预测效果 缺陷 单个功能的错误会让这个测试变得效率底下。 必须思虑周详以达成好的覆盖。测试者需要较有经验。 分析过程较为人为化，客观性受到影响","link":"/2018/12/10/Software Quality Assurance/Individual techniques/9-Scenario testing/"},{"title":"5-Define Evaluation Mission","text":"Content Define Evaluation Mission Defining the mission of the test group Defining the goal for test documentation In this module, we begin with the workflow detail Define Evaluation Mission The Mission focuses on the high-level objectives of the test team for the current iteration Define Evaluation Mission The purpose of this workflow detail is to: 确定迭代测试工作的适当重点。 与利益相关方就实现测试工作的相应目标达成协议 对于每次迭代，工作主要集中在： 确定测试工作的目标和可交付成果 确定良好的资源利用战略 为测试工作定义适当的范围和边界 概述将使用的方法 确定如何监控和评估进展情况。 Defining the Test Approach The test approach (testing strategy)specifies the techniques that will be used to accomplish the test mission. The test approach also specifies how the techniques will be used. A good test approach is: Diversified Include a variety of techniques. Each technique is tailored to expose certain types of problems, and is virtually blind to others. Combining them allows you to find problems that would be hard to find if you spent the same resource on a narrower collection of techniques. Risk-focused Tests give you the opportunity to find defects or attributes of the software that will disappoint, alienate, or harm a stakeholder. You can’t run all possible tests. To be efficient, you should think about the types of problems that are plausibly in this product or that would make a difference if they were in this product, and make sure that you test for them. Product-specific Generic test approaches don’t work. Your needs and resources will vary across products. The risks vary across products. Therefore the balance of investment in different techniques should vary across products. Practical here’s no point defining an approach that is beyond your project’s capabilities (including time, budget, equipment, and staff skills). Defensible Defining the goal for test documentation What Test Documentation Should You Use? Test planning standards and templates Requirements considerations Questions to elicit information about test documentation requirements for your project IEEE Standard 829 for Software Test Documentation","link":"/2018/12/08/Software Quality Assurance/Class Notes/5-Define Evaluation Mission/"},{"title":"4-The RUP Test Discipline","text":"Objectives The terminology of RUP The testing discipline in RUP The testing workflow structure WHAT The Rational Unified Process (RUP) is a software engineering process framework that provides a disciplined yet flexible approach to assigning tasks and responsibilities within a software development organization. RUP’s goal is to support the production of high-quality software that meets the needs of its end users within a predictable schedule and budget. The RUP supports many software engineering practices The dynamic structure (phases and iterations) of the Rational Unified Process creates a basis for iterative development. The Project Management discipline describes how to set up and execute a project using phases and iterations. The Use-Case Model and Risk List of the Requirements discipline help determine what functionality you implement in each iteration. The Workflow Details of the Requirements discipline show the activities and artifacts that make requirements management possible. The iterative approach allows you to progressively identify components, decide which ones to develop, which ones to reuse, and which ones to buy. The Unified Modeling Language (UML) used in the process represents the basis of Visual Modeling and has become the de facto modeling language standard. The focus on software architecture allows you to articulate the structure: the components and the ways in which they integrate, the fundamental mechanisms and patterns by which they interact The Rational Unified Process has four phases: Inception - Define the project scope, gain agreement on project objectives, baseline the product Vision Elaboration - Address key technical risks, produce an evolutionary prototype, baseline the Architecture Construction - Iteratively and incrementally develop an operationally complete product Transition - Deliver the product into the live end-user environment 初始 - 定义项目范围，就项目目标达成一致，为产品愿景奠定基础 精化 - 解决关键技术风险，制作演化原型，建立基线 构建 - 迭代并逐步开发出操作完整的产品 过渡 - 将产品交付给实时最终用户环境 Roles in the Test Discipline Test Manager is tasked with the overall responsibility for the test effort’s success. Test Analyst is responsible for initially identifying and defining the required tests, and subsequently evaluating the results of the test effort. Test Designer is responsible for defining the test approach and ensuring its successful implementation. Tester is responsible for the core activities of the test effort, which involves conducting the necessary tests and logging the outcomes of that testing. Define Evaluation Mission Identify the appropriate focus of the test effort for the iteration. Gain agreement with stakeholders on the corresponding goals that will direct the test effort. Test and Evaluate Achieve appropriate breadth and depth of testing to enable a sufficient evaluation of the targeted test items. Achieve Acceptable Mission Deliver a useful evaluation result to the stakeholders of the test effort. Actively prioritize the test work that remains to be conducted. Verify Test Approach Demonstrate the techniques outlined in the Test Approach will support the required testing. Verify that the approach will work, produce accurate results and is appropriate for the available resources. Validate Build Stability Validate that the build is stable enough for detailed test and evaluation work to begin Improve Test Assets Maintain and improve the evolving test assets. (e.g. Maintain test suites and test data; harvest test-ideas into catalogs; clarify change request details)","link":"/2018/12/08/Software Quality Assurance/Class Notes/4-The RUP Test Discipline/"},{"title":"6-Test & Evaluate","text":"Content Defining test techniques Individual techniques Using techniques together Dimensions of Test Techniques Think of the testing you do in terms of five dimensions: Testers: who does the testing. Coverage: what gets tested. Potential problems: why you’re testing (what risk you’re testing for). Activities: how you test. Evaluation: how to tell whether the test passed or failed. Of the 200+ published Functional Testing techniques, there are ten basic themes.They capture the techniques in actual practice. Function testing Equivalence analysis Specification-based testing Risk-based testing Stress testing Regression testing Exploratory testing User testing Scenario testing Stochastic or Random testing详情见 Individual techniques 目录","link":"/2018/12/08/Software Quality Assurance/Class Notes/6-Test & Evaluate/"}],"tags":[],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Software Quality Assurance","slug":"Software-Quality-Assurance","link":"/categories/Software-Quality-Assurance/"},{"name":"Individual techniques","slug":"Software-Quality-Assurance/Individual-techniques","link":"/categories/Software-Quality-Assurance/Individual-techniques/"},{"name":"Class Notes","slug":"Software-Quality-Assurance/Class-Notes","link":"/categories/Software-Quality-Assurance/Class-Notes/"}]}